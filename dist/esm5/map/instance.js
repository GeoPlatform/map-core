/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import * as jquery from "jquery";
/** @type {?} */
var jQuery = jquery;
import * as Q from "q";
import { circleMarker, geoJSON, featureGroup, LayerGroup } from 'leaflet';
import { Config, ItemTypes, ServiceFactory, JQueryHttpClient } from 'geoplatform.client';
import LayerFactory from '../layer/factory';
import DefaultBaseLayer from '../layer/baselayer-default';
var Listener = /** @class */ (function () {
    function Listener() {
        //listeners to be unregistered upon destroy
        this._listeners = {};
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    Listener.prototype.on = /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    function (type, listener) {
        if (!this._listeners[type])
            this._listeners[type] = [];
        this._listeners[type].push(listener);
    };
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    Listener.prototype.off = /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    function (type, listener) {
        if (!type)
            this._listeners = {};
        if (!this._listeners[type])
            return;
        if (!listener)
            this._listeners[type] = [];
        else {
            /** @type {?} */
            var idx = this._listeners[type].indexOf(listener);
            if (idx >= 0)
                this._listeners[type].splice(idx, 1);
        }
    };
    /**
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    Listener.prototype.notify = /**
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    function (type) {
        var options = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            options[_i - 1] = arguments[_i];
        }
        if (!this._listeners[type])
            return;
        /** @type {?} */
        var args = Array.prototype.slice.call(arguments, 1);
        this._listeners[type].forEach(function (l) { l.apply(null, args); });
    };
    return Listener;
}());
if (false) {
    /** @type {?} */
    Listener.prototype._listeners;
}
var MapInstance = /** @class */ (function (_super) {
    tslib_1.__extends(MapInstance, _super);
    function MapInstance(key) {
        var _this = _super.call(this) || this;
        _this.setHttpClient(new JQueryHttpClient());
        _this.setServiceFactory(ServiceFactory);
        //generate random key (see factory below)
        //generate random key (see factory below)
        _this._key = key || Math.ceil(Math.random() * 9999);
        //registry id of current map if available
        //registry id of current map if available
        _this._mapId = null,
            //definition of map (ie, from server)
            //definition of map (ie, from server)
            _this._mapDef = _this.initializeMapDefinition(),
            //primary map instance (ie, leaflet)
            //primary map instance (ie, leaflet)
            _this._mapInstance = null,
            //default map extent (if map doesn't have one for being saved)
            //default map extent (if map doesn't have one for being saved)
            _this._defaultExtent = null,
            //current base layer object and leaflet instance
            //current base layer object and leaflet instance
            _this._baseLayerDef = null,
            _this._baseLayer = null,
            //set definitions of layer states (including layer info) on map
            //set definitions of layer states (including layer info) on map
            _this._layerStates = [],
            //map layer def ids with leaflet instances
            //map layer def ids with leaflet instances
            _this._layerCache = {},
            //errors generated by layers loading
            //errors generated by layers loading
            _this._layerErrors = [],
            _this._layerErrorHandler = function (e) {
                console.log("MapInstance.defaultLayerErrorHandler() - " + e.id + " : " + e.message);
            },
            //layer used to store features on map
            //layer used to store features on map
            _this._featureLayer = null,
            _this._featureLayerVisible = true,
            //set of registered map tools
            //set of registered map tools
            _this._tools = [],
            //state management
            //state management
            _this.state = { dirty: false }; // jshint ignore:line
        _this._geoJsonLayerOpts = {
            style: function (feature) {
                if (feature.properties.style)
                    return feature.properties.style;
            },
            onEachFeature: function (feature, layer) {
                /** @type {?} */
                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };
                if (~feature.geometry.type.indexOf('Point')) {
                    style.fillOpacity = 0.9;
                }
                /** @type {?} */
                var props = feature.properties = feature.properties || {};
                if (feature.properties.id === undefined || feature.properties.id === null)
                    feature.properties.id = Math.floor(Math.random() * 999999);
                feature.properties.label = props.label || props.title || props.name || "Untitled " + feature.geometry.type + " Feature";
                feature.properties.description = props.description || props.desc || "This feature needs a description!";
                feature.properties.style = props.style || style;
                layer.bindTooltip(props.label);
                /*
                                toggle: setLabelNoHide(bool)
                                it may only exist on markers!
                                */
            },
            pointToLayer: function (feature, latlng) {
                /** @type {?} */
                var style = feature.properties.style || {};
                style.radius = style.radius || 4;
                style.weight = style.weight || 2;
                style.color = style.color || '#03f';
                style.opacity = style.opacity || 0.9;
                style.fillOpacity = style.opacity;
                style.fillColor = style.color;
                return circleMarker(latlng, style);
            }
        };
        return _this;
    }
    /**
     * @return {?}
     */
    MapInstance.prototype.dispose = /**
     * @return {?}
     */
    function () {
        this.destroyMap();
        this.svcCache = null;
        this.serviceFactory = null;
        this.httpClient = null;
        this._key = null;
        this._mapId = null;
        this._mapDef = null;
        this._mapInstance = null;
        this._defaultExtent = null;
        this._baseLayerDef = null;
        this._baseLayer = null;
        this._layerStates = null;
        this._layerCache = null;
        this._layerErrors = null;
        this._featureLayer = null;
        this._featureLayerVisible = true;
        this._tools = null;
        this.state = null;
        this._geoJsonLayerOpts = null;
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.getKey = /**
     * @return {?}
     */
    function () {
        return this._key;
    };
    /**
     * Override default (JQuery-based) map service used by this instance
     * @param mapService - service to use to CRUD map objects
     * @deprecated use setServiceFactory instead
     */
    /**
     * Override default (JQuery-based) map service used by this instance
     * @deprecated use setServiceFactory instead
     * @param {?} mapService - service to use to CRUD map objects
     * @return {?}
     */
    MapInstance.prototype.setService = /**
     * Override default (JQuery-based) map service used by this instance
     * @deprecated use setServiceFactory instead
     * @param {?} mapService - service to use to CRUD map objects
     * @return {?}
     */
    function (mapService) {
        // this.mapService = mapService;
    };
    /**
     * @param factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     */
    /**
     * @param {?} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     * @return {?}
     */
    MapInstance.prototype.setServiceFactory = /**
     * @param {?} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     * @return {?}
     */
    function (factory) {
        this.svcCache = {}; //wipe out cached services
        this.serviceFactory = factory;
    };
    /**
     * @param httpClient - HttpClient impl to use with the new factory
     */
    /**
     * @param {?} httpClient - HttpClient impl to use with the new factory
     * @return {?}
     */
    MapInstance.prototype.setHttpClient = /**
     * @param {?} httpClient - HttpClient impl to use with the new factory
     * @return {?}
     */
    function (httpClient) {
        this.svcCache = {}; //wipe out cached services
        this.httpClient = httpClient;
    };
    /**
     * @param type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return item service implementation for the requested type
     */
    /**
     * @param {?} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {?} item service implementation for the requested type
     */
    MapInstance.prototype.getService = /**
     * @param {?} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {?} item service implementation for the requested type
     */
    function (type) {
        if (!this.svcCache[type])
            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);
        return this.svcCache[type];
    };
    /**
     * @param fn - callback when an error is encountered
     */
    /**
     * @param {?} fn - callback when an error is encountered
     * @return {?}
     */
    MapInstance.prototype.setErrorHandler = /**
     * @param {?} fn - callback when an error is encountered
     * @return {?}
     */
    function (fn) {
        this._layerErrorHandler = fn;
    };
    //-----------------
    /**
     * @param {?} layerId
     * @return {?}
     */
    MapInstance.prototype.getLayerStateIndex = /**
     * @param {?} layerId
     * @return {?}
     */
    function (layerId) {
        if (!layerId)
            return -1;
        for (var i = 0; i < this._layerStates.length; ++i) {
            if (this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {
                return i;
            }
        }
        return -1;
        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );
    };
    /**
     * @param {?} layerId
     * @return {?}
     */
    MapInstance.prototype.getLayerState = /**
     * @param {?} layerId
     * @return {?}
     */
    function (layerId) {
        /** @type {?} */
        var index = this.getLayerStateIndex(layerId);
        return index >= 0 ? this._layerStates[index] : null;
    };
    //-----------------
    /**
     * @return {?}
     */
    MapInstance.prototype.initializeMapDefinition = /**
     * @return {?}
     */
    function () {
        return {
            type: ItemTypes.MAP,
            title: "My New Map",
            label: "My New Map",
            description: "This map needs a description",
            createdBy: null,
            baseLayer: this._baseLayerDef,
            layers: [],
            keywords: [],
            themes: [],
            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']
        };
    };
    /**
     * @param metadata object
     * @return object definition of the current map suitable for sending to WMVR
     */
    /**
     * @param {?=} metadata object
     * @return {?} object definition of the current map suitable for sending to WMVR
     */
    MapInstance.prototype.getMapResourceContent = /**
     * @param {?=} metadata object
     * @return {?} object definition of the current map suitable for sending to WMVR
     */
    function (metadata) {
        metadata = metadata || {};
        //map layers
        metadata.layers = this._layerStates.slice(0);
        // ... UAL should support accepting just an id here, so we'll do just that
        metadata.baseLayer = this._baseLayerDef;
        metadata.annotations = this._featureLayer ?
            { title: "Map Features", geoJSON: this._featureLayer.toGeoJSON() } : null;
        /** @type {?} */
        var extent = this._mapInstance.getBounds();
        metadata.extent = {
            minx: extent.getWest(),
            miny: extent.getSouth(),
            maxx: extent.getEast(),
            maxy: extent.getNorth()
        };
        return metadata;
    };
    /**
     * @return Leaflet toolbar
     */
    /**
     * @return {?} Leaflet toolbar
     */
    MapInstance.prototype.getDrawControlToolbar = /**
     * @return {?} Leaflet toolbar
     */
    function () {
        if (!(/** @type {?} */ (this._mapInstance)).drawControl)
            return null;
        /** @type {?} */
        var toolbars = (/** @type {?} */ (this._mapInstance)).drawControl._toolbars;
        /** @type {?} */
        var toolbar = null;
        for (var key in toolbars) {
            if (toolbars.hasOwnProperty(key)) {
                if (toolbars[key]._modes) {
                    toolbar = toolbars[key];
                    break;
                }
            }
        }
        return toolbar;
    };
    /**
     * @param error Leaflet tile load error (.target is layer, .tile is image)
     */
    /**
     * @param {?} error Leaflet tile load error (.target is layer, .tile is image)
     * @return {?}
     */
    MapInstance.prototype.handleLayerError = /**
     * @param {?} error Leaflet tile load error (.target is layer, .tile is image)
     * @return {?}
     */
    function (error) {
        // console.log("MapInstance.handleLayerError() - " +
        //     "Layer's tile failed to load: " + error.tile.src);
        if (!this._layerCache) {
            console.log("Unable to find layer in layer cache. Layer error is " + error);
            return;
        }
        /** @type {?} */
        var layer = error.target;
        for (var id in this._layerCache) {
            if (this._layerCache[id] === layer) {
                this.processLayerError(error, id);
                break;
            }
        }
    };
    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     */
    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     * @param {?} error
     * @param {?} id
     * @return {?}
     */
    MapInstance.prototype.processLayerError = /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     * @param {?} error
     * @param {?} id
     * @return {?}
     */
    function (error, id) {
        var _this = this;
        /** @type {?} */
        var finder = function (l) { return l.id === id || (l.layer && l.layer.id === id); };
        if (!this._layerErrors.find(finder)) {
            /** @type {?} */
            var obj_1 = this.logLayerError(id, "Layer ('" + id + "') failed to completely load. " +
                "It may be inaccessible or misconfigured.");
            /** @type {?} */
            var url = (/** @type {?} */ (error)).tile.src;
            /** @type {?} */
            var params = { id: id };
            url.substring(url.indexOf("?") + 1, url.length).split('&').forEach(function (param) {
                /** @type {?} */
                var p = param.split('=');
                params[p[0]] = p[1];
            });
            /** @type {?} */
            var layerService = this.getService(ItemTypes.LAYER);
            if (layerService) {
                layerService.validate(id, params)
                    .catch(function (e) {
                    /** @type {?} */
                    var def = _this._layerStates.find(finder);
                    if (def) {
                        obj_1.message = "Layer '" + def.layer.label + "' failed to completely load. " +
                            "Reported cause: " + e.message;
                    }
                    _this.notify('layer:error', obj_1);
                });
            }
        }
    };
    /**
     * @param layerId - identifier of layer generating the error
     * @param errorMsg - message of the error
     */
    /**
     * @param {?} layerId - identifier of layer generating the error
     * @param {?} errorMsg - message of the error
     * @return {?}
     */
    MapInstance.prototype.logLayerError = /**
     * @param {?} layerId - identifier of layer generating the error
     * @param {?} errorMsg - message of the error
     * @return {?}
     */
    function (layerId, errorMsg) {
        /** @type {?} */
        var err = { id: layerId, message: errorMsg };
        this._layerErrors.push(err);
        if (this._layerErrorHandler) {
            this._layerErrorHandler(err);
        }
        return err;
    };
    /* -- State Management of internal model -- */
    /**
     * @param {?=} event
     * @param {...?} options
     * @return {?}
     */
    MapInstance.prototype.touch = /**
     * @param {?=} event
     * @param {...?} options
     * @return {?}
     */
    function (event) {
        var options = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            options[_i - 1] = arguments[_i];
        }
        this.state.dirty = true;
        if (event) {
            if (arguments.length > 1) {
                this.notify.apply(this, Array.prototype.slice.call(arguments));
            }
            else
                this.notify(event);
            // console.log("Dirtying map for " + event);
        }
        // else console.log("Dirtying map");
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.clean = /**
     * @return {?}
     */
    function () {
        // console.log("Cleaning map");
        this.state.dirty = false;
    };
    /* --------------------------------------- */
    /* ==============================================
        Map manipulation operations
       ============================================== */
    /**
     * @param {?} map
     * @return {?}
     */
    MapInstance.prototype.setMap = /**
     * @param {?} map
     * @return {?}
     */
    function (map) { this._mapInstance = map; };
    /**
     * @return  map instance
     */
    /**
     * @return {?} map instance
     */
    MapInstance.prototype.getMap = /**
     * @return {?} map instance
     */
    function () { return this._mapInstance; };
    /** @return definition of map */
    /**
     * @return {?} definition of map
     */
    MapInstance.prototype.getMapDefinition = /**
     * @return {?} definition of map
     */
    function () { return this._mapDef; };
    /** @return identifier of map */
    /**
     * @return {?} identifier of map
     */
    MapInstance.prototype.getMapId = /**
     * @return {?} identifier of map
     */
    function () { return this._mapId; };
    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param lat number
     * @param lng number
     * @param zoom number (optional)
     */
    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param {?} lat number
     * @param {?} lng number
     * @param {?=} zoom number (optional)
     * @return {?}
     */
    MapInstance.prototype.setView = /**
     * Focuses the map on the specified lat/lng coordinate
     * @param {?} lat number
     * @param {?} lng number
     * @param {?=} zoom number (optional)
     * @return {?}
     */
    function (lat, lng, zoom) {
        /** @type {?} */
        var z = zoom;
        if (typeof (z) === 'undefined')
            z = this._mapInstance.getZoom();
        this._mapInstance.setView([lat, lng], z);
        this.touch('map:view:changed');
    };
    /**
     * Retrieve the current center of the map
     * @return [lat,lng]
     */
    /**
     * Retrieve the current center of the map
     * @return {?} [lat,lng]
     */
    MapInstance.prototype.getView = /**
     * Retrieve the current center of the map
     * @return {?} [lat,lng]
     */
    function () {
        /** @type {?} */
        var latLng = this._mapInstance.getCenter();
        return [latLng.lat, latLng.lng];
    };
    /**
     * @return integer current zoom level of the map
     */
    /**
     * @return {?} integer current zoom level of the map
     */
    MapInstance.prototype.getZoom = /**
     * @return {?} integer current zoom level of the map
     */
    function () {
        return this._mapInstance.getZoom();
    };
    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     */
    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     * @return {?}
     */
    MapInstance.prototype.zoomToDefault = /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     * @return {?}
     */
    function () {
        if (!this._mapInstance)
            return;
        if (this._defaultExtent) {
            this._mapInstance.fitBounds([
                [this._defaultExtent.miny, this._defaultExtent.minx],
                [this._defaultExtent.maxy, this._defaultExtent.maxx]
            ]);
        }
        else {
            console.log("MapInstance.zoomToDefault() - No default extent specified");
            this._mapInstance.setView([38, -96], 5);
        }
        try {
            this.touch('map:view:changed');
        }
        catch (e) { }
    };
    /**
     * @param extent - either a GP extent object or Leaflet LatLngBounds object
     */
    /**
     * @param {?} extent - either a GP extent object or Leaflet LatLngBounds object
     * @return {?}
     */
    MapInstance.prototype.setExtent = /**
     * @param {?} extent - either a GP extent object or Leaflet LatLngBounds object
     * @return {?}
     */
    function (extent) {
        if (!extent)
            return;
        if (typeof (extent.minx) !== 'undefined' &&
            typeof (extent.miny) !== 'undefined' &&
            typeof (extent.maxx) !== 'undefined' &&
            typeof (extent.maxy) !== 'undefined') {
            //GP model extent
            this._mapInstance.fitBounds([
                [extent.miny, extent.minx],
                [extent.maxy, extent.maxx]
            ]);
        }
        else if (typeof (extent.getWest) !== 'undefined') {
            //L.LatLngBounds
            this._mapInstance.fitBounds(extent);
        }
        else {
        }
    };
    /* ==============================================
        Layer operations
       ============================================== */
    /**
     * @param layer Leaflet Layer instance or object definition
     */
    /**
     * @param {?} layer Leaflet Layer instance or object definition
     * @return {?}
     */
    MapInstance.prototype.setBaseLayer = /**
     * @param {?} layer Leaflet Layer instance or object definition
     * @return {?}
     */
    function (layer) {
        var _this = this;
        /** @type {?} */
        var promise = null;
        if (!layer) {
            promise = DefaultBaseLayer.get(this.getService(ItemTypes.LAYER));
        }
        else
            promise = Q.resolve(layer);
        promise.then(function (layer) {
            /** @type {?} */
            var leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                console.log("Warning: MapInstance could not create base " +
                    "layer for '" + layer.id + "'");
                return;
            }
            _this._mapInstance.addLayer(leafletLayer);
            (/** @type {?} */ (leafletLayer)).setZIndex(0);
            /** @type {?} */
            var oldBaseLayer = _this._baseLayer;
            if (oldBaseLayer) {
                _this._mapInstance.removeLayer(oldBaseLayer);
            }
            //remember new base layer
            //remember new base layer
            _this._baseLayer = leafletLayer;
            _this._baseLayerDef = layer;
            //will notify listeners
            //will notify listeners
            _this.touch('baselayer:changed', layer, leafletLayer);
            // this.notify('baselayer:changed', layer, leafletLayer);
        })
            .catch(function (e) {
            console.log("MapInstance.setBaseLayer() - Error getting base layer for map : " + e.message);
            _this.logLayerError(layer.id, "Error setting baselayer on map " +
                "because of the following error(s): " + e.message);
        });
    };
    /**
     * @return array of base layers definitions that can be used
     */
    // getBaseLayerOptions () {
    //     return this._baseLayerOptions;
    // },
    /**
     * @return {?} array of base layers definitions that can be used
     */
    MapInstance.prototype.getBaseLayer = /**
     * @return {?} array of base layers definitions that can be used
     */
    function () { return this._baseLayerDef; };
    /**
     * @return list of layer states containing layer information
     */
    /**
     * @return {?} list of layer states containing layer information
     */
    MapInstance.prototype.getLayers = /**
     * @return {?} list of layer states containing layer information
     */
    function () { return this._layerStates; };
    /**
     * @return {?}
     */
    MapInstance.prototype.getLayerErrors = /**
     * @return {?}
     */
    function () { return this._layerErrors; };
    /**
     * @return {?}
     */
    MapInstance.prototype.clearLayerErrors = /**
     * @return {?}
     */
    function () {
        this._layerErrors = [];
        this.notify('layer:error');
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.clearOverlays = /**
     * @return {?}
     */
    function () {
        if (!this._layerCache)
            return;
        for (var i = this._layerStates.length - 1; i >= 0; --i) {
            /** @type {?} */
            var state = this._layerStates[i];
            /** @type {?} */
            var layerInstance = this._layerCache[state.layer.id];
            if (layerInstance) {
                layerInstance.off("layer:error");
                this._layerCache[state.layer.id] = null;
                this._mapInstance.removeLayer(layerInstance);
            }
        }
        this._layerStates = [];
        this.touch('layers:changed');
        //TODO stop listening for layer events
    };
    /**
     * @param layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     */
    /**
     * @param {?} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     * @return {?}
     */
    MapInstance.prototype.addLayers = /**
     * @param {?} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     * @return {?}
     */
    function (layers) {
        var _this = this;
        if (!this._layerCache) {
            console.log("WARN: attempting to add layers to an empty cache");
            return;
        }
        if (!this._layerCache) {
            console.log("WARN: Attempting to add layers to a map with no layer cache");
            return;
        }
        if (!layers)
            return;
        if (typeof (layers.push) === 'undefined') {
            layers = [layers];
        }
        layers.forEach(function (obj, index) {
            /** @type {?} */
            var layer = null;
            /** @type {?} */
            var state = null;
            if (obj.type && obj.type === ItemTypes.LAYER) { //is a layer
                //is a layer
                layer = obj;
            }
            else if (obj.layer) { //is layer state
                //is layer state
                layer = obj.layer; // containing a layer
                state = obj;
            }
            if (!layer) {
                console.log("MapInstance.addLayers() - layer (" + index +
                    ") is not a Layer or a Layer state. Ignoring...");
                return; //layer info is missing, skip it
            }
            //DT-442 prevent adding layer that already exists on map
            if (_this._layerCache[layer.id])
                return;
            if (!state) {
                try {
                    /** @type {?} */
                    var layerCopy = JSON.parse(JSON.stringify(layer));
                    state = {
                        opacity: 1,
                        visibility: true,
                        layer: layerCopy
                    };
                }
                catch (e) {
                    throw new Error("Unable to add layer to map because of " + e.message);
                }
            }
            /** @type {?} */
            var z = layers.length - index;
            state.zIndex = z;
            _this.addLayerWithState(layer, state);
        });
        this.touch('layers:changed');
    };
    /**
     * @param layer - GeoPlatform Layer instance
     * @param state - GeoPlatform Layer State
     */
    /**
     * @param {?} layer - GeoPlatform Layer instance
     * @param {?} state - GeoPlatform Layer State
     * @return {?}
     */
    MapInstance.prototype.addLayerWithState = /**
     * @param {?} layer - GeoPlatform Layer instance
     * @param {?} state - GeoPlatform Layer State
     * @return {?}
     */
    function (layer, state) {
        var _this = this;
        /** @type {?} */
        var leafletLayer = null;
        try {
            if (!layer || !state)
                throw new Error("Invalid argument, missing layer and or state");
            leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                throw new Error("Could not create leaflet layer for GP Layer '" +
                    layer.id + "'");
            }
        }
        catch (e) {
            this.logLayerError(layer.id, "Layer '" + layer.label + "' could not be added to the " +
                "map instance; " + e.message);
        }
        if (!leafletLayer)
            return;
        //cache leaflet object first
        if (this._layerCache)
            this._layerCache[layer.id] = leafletLayer;
        //listen for layer errors so we can inform the user
        // that a layer hasn't been loaded in a useful way
        leafletLayer.on('tileerror', function (e) { _this.handleLayerError(e); });
        this._mapInstance.addLayer(leafletLayer);
        if (!isNaN(state.zIndex) && leafletLayer.setZIndex)
            leafletLayer.setZIndex(state.zIndex);
        this._layerStates.push(state);
        this.notify('layer:added', layer, leafletLayer);
        // if layer is initially "off" or...
        // if layer is initially not 100% opaque
        if (!state.visibility || state.opacity < 1) {
            // initialize layer visibility and opacity async, or else
            // some of the layers won't get properly initialized
            setTimeout(function (layer, state) {
                _this.setLayerVisibility(layer, state.visibility);
                _this.setLayerOpacity(layer, state.opacity);
                //TODO notify of change
                //DT-2102 timeout needs to be large enough or else
                // feature layers won't get opacity updated on map load
            }, 2000, leafletLayer, state);
        }
    };
    /**
     * @param from - position of layer being moved
     * @param to - desired position to move layer to
     */
    /**
     * @param {?} from - position of layer being moved
     * @param {?} to - desired position to move layer to
     * @return {?}
     */
    MapInstance.prototype.moveLayer = /**
     * @param {?} from - position of layer being moved
     * @param {?} to - desired position to move layer to
     * @return {?}
     */
    function (from, to) {
        if (!this._layerCache)
            return;
        if (!this._layerCache)
            return;
        if (isNaN(from))
            return;
        //end of list
        if (isNaN(to))
            to = this._layerStates.length - 1;
        /** @type {?} */
        var copy = this._layerStates.splice(from, 1)[0]; //grab layer being moved
        this._layerStates.splice(to, 0, copy);
        for (var z = 1, i = this._layerStates.length - 1; i >= 0; --i, ++z) {
            /** @type {?} */
            var layerState = this._layerStates[i];
            /** @type {?} */
            var layerInstance = this._layerCache[layerState.layer.id];
            if (layerInstance) {
                layerInstance.setZIndex(z);
                layerState.zIndex = z;
            }
        }
        this.touch('layers:changed', this.getLayers());
    };
    /**
     *
     */
    /**
     *
     * @param {?} id
     * @return {?}
     */
    MapInstance.prototype.removeLayer = /**
     *
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            var index = this.getLayerStateIndex(id);
            // console.log("MapInstance.removeLayer(" + id + ")");
            if (index >= 0 && index < this._layerStates.length)
                this._layerStates.splice(index, 1);
            //stop listening for errors
            layerInstance.off("layer:error");
            //remove layer from map
            this._mapInstance.removeLayer(layerInstance);
            //remove layer from cache
            this._layerCache[id] = null;
        }
        this.touch('layers:changed');
    };
    /**
     *
     */
    /**
     *
     * @param {?} id
     * @return {?}
     */
    MapInstance.prototype.toggleLayerVisibility = /**
     *
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            var state = this.getLayerState(id);
            state.visibility = !state.visibility;
            if (layerInstance._currentImage) {
                //ESRI Image Service layers have an IMG element
                // that gets modified and replaced every map event (zoom/pan)
                // so we can't just toggle classes like on other layers.
                //Instead, we need to use the ESRI setOpacity method to toggle
                // but need to update layer state as well.
                layerInstance.setOpacity(state.visibility ? 1 : 0);
                state.opacity = layerInstance.getOpacity();
                return;
            }
            this.setLayerVisibility(layerInstance, state.visibility);
        }
    };
    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param layerInstance - leaflet layer instance
     * @param visible - flag indicating visibility of layer
     */
    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} visible - flag indicating visibility of layer
     * @return {?}
     */
    MapInstance.prototype.setLayerVisibility = /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} visible - flag indicating visibility of layer
     * @return {?}
     */
    function (layerInstance, visible) {
        if ((/** @type {?} */ (layerInstance)).setVisibility) {
            //using custom method provided in src/layer/module.js
            (/** @type {?} */ (layerInstance)).setVisibility(visible);
        }
        else if ((/** @type {?} */ (layerInstance))._container) {
            /** @type {?} */
            var el = jQuery((/** @type {?} */ (layerInstance))._container);
            // if(visible) el.removeClass("invisible");
            // else el.addClass('invisible');
            el.css({ 'display': visible ? '' : 'none' });
        }
        this.touch('map:layer:changed');
    };
    /**
     *
     */
    /**
     *
     * @param {?} id
     * @param {?} opacity
     * @return {?}
     */
    MapInstance.prototype.updateLayerOpacity = /**
     *
     * @param {?} id
     * @param {?} opacity
     * @return {?}
     */
    function (id, opacity) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        //if layer id is for base layer...
        if (!layerInstance && this._baseLayerDef.id === id) {
            layerInstance = this._baseLayer;
        }
        //adjust rendered leaflet layer
        opacity = this.setLayerOpacity(layerInstance, opacity);
        /** @type {?} */
        var state = this.getLayerState(id);
        if (state)
            state.opacity = opacity;
    };
    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param layerInstance - leaflet layer instance
     * @param opacity - value between 0 and 1.0 or 0 and 100
     * @return normalized opacity value between 0 and 1.0
     */
    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} opacity - value between 0 and 1.0 or 0 and 100
     * @return {?} normalized opacity value between 0 and 1.0
     */
    MapInstance.prototype.setLayerOpacity = /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} opacity - value between 0 and 1.0 or 0 and 100
     * @return {?} normalized opacity value between 0 and 1.0
     */
    function (layerInstance, opacity) {
        if (layerInstance && (/** @type {?} */ (layerInstance)).setOpacity) {
            if (opacity > 1.0)
                opacity = opacity / 100.0;
            (/** @type {?} */ (layerInstance)).setOpacity(opacity);
            this.touch('map:layer:changed');
        }
        return opacity;
    };
    /**
     * @param GeoPlatform Layer instance
     * @return Leaflet layer instance representing that layer or null
     */
    /**
     * @param {?} gpLayer
     * @return {?} Leaflet layer instance representing that layer or null
     */
    MapInstance.prototype.getLeafletLayerFor = /**
     * @param {?} gpLayer
     * @return {?} Leaflet layer instance representing that layer or null
     */
    function (gpLayer) {
        if (!gpLayer || !this._layerCache)
            return null;
        /** @type {?} */
        var leafletLayer = this._layerCache[gpLayer.id];
        return leafletLayer || null;
    };
    /**
     *
     */
    /**
     *
     * @param {?} layerId
     * @return {?}
     */
    MapInstance.prototype.toggleGetFeatureInfo = /**
     *
     * @param {?} layerId
     * @return {?}
     */
    function (layerId) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[layerId];
        if (layerInstance) {
            if (typeof (layerInstance.enableGetFeatureInfo) !== 'undefined') {
                if (layerInstance.isGetFeatureInfoEnabled()) {
                    layerInstance.disableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).removeClass('selectable-cursor');
                }
                else {
                    layerInstance.enableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).addClass('selectable-cursor');
                }
            }
        }
    };
    /* ==============================================
       Feature operations
       ============================================== */
    /**
     * @return array of features on the map
     */
    /**
     * @return {?} array of features on the map
     */
    MapInstance.prototype.getFeatures = /**
     * @return {?} array of features on the map
     */
    function () {
        if (this._featureLayer) {
            /** @type {?} */
            var geojson_1 = this._featureLayer.toGeoJSON();
            return (/** @type {?} */ (geojson_1)).features;
        }
        return [];
    };
    /**
     * @param json geojson object or array of geojson objects
     */
    /**
     * @param {?} json geojson object or array of geojson objects
     * @return {?}
     */
    MapInstance.prototype.addFeatures = /**
     * @param {?} json geojson object or array of geojson objects
     * @return {?}
     */
    function (json) {
        if (!json)
            return;
        if (typeof (json.push) !== 'undefined') {
            //array of features
            for (var i = 0; i < json.length; ++i)
                this.addFeature(json[i], false);
            this.touch('features:changed');
        }
        else if (json.features) {
            this.addFeatures(json.features);
        }
        else { //single feature
            //single feature
            this.addFeature(json, true);
        }
    };
    /**
     * @param json geojson object
     */
    /**
     * @param {?} json geojson object
     * @param {?=} fireEvent
     * @return {?}
     */
    MapInstance.prototype.addFeature = /**
     * @param {?} json geojson object
     * @param {?=} fireEvent
     * @return {?}
     */
    function (json, fireEvent) {
        var _this = this;
        // var type = json.type;
        // var coordinates = json.coordinates;
        if (!this._featureLayer) {
            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);
            this._featureLayer = featureGroup().addTo(this._mapInstance);
        }
        /** @type {?} */
        var opts = jQuery.extend({}, this._geoJsonLayerOpts);
        geoJSON(json, opts).eachLayer(function (l) { return _this.addFeatureLayer(l); });
        if (typeof (fireEvent) === 'undefined' || fireEvent === true)
            this.touch('features:changed');
        else
            this.touch();
        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));
    };
    /**
     * @param featureJson object defining a GeoJSON feature
     */
    /**
     * @param {?} featureJson object defining a GeoJSON feature
     * @return {?}
     */
    MapInstance.prototype.updateFeature = /**
     * @param {?} featureJson object defining a GeoJSON feature
     * @return {?}
     */
    function (featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            (/** @type {?} */ (layer)).feature = featureJson;
            //update style
            layer.setStyle(featureJson.properties.style);
            /** @type {?} */
            var label = featureJson.properties.label ||
                "Untitled " + featureJson.geometry.type + " Feature";
            layer.bindTooltip(label);
            // layer.redraw();
            this.touch("map:feature:changed");
        }
    };
    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param featureJson object defining GeoJSON feature
     */
    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param {?} featureJson object defining GeoJSON feature
     * @return {?}
     */
    MapInstance.prototype.replaceFeature = /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param {?} featureJson object defining GeoJSON feature
     * @return {?}
     */
    function (featureJson) {
        var _this = this;
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            //remove existing
            this._featureLayer.removeLayer(layer);
            //add replacement
            geoJSON(featureJson, this._geoJsonLayerOpts)
                .eachLayer(function (l) { return _this.addFeatureLayer(l); });
            this.touch("map:feature:changed");
        }
    };
    /**
     * @param featureId identifier of feature to focus the map on
     */
    /**
     * @param {?} featureId identifier of feature to focus the map on
     * @return {?}
     */
    MapInstance.prototype.focusFeature = /**
     * @param {?} featureId identifier of feature to focus the map on
     * @return {?}
     */
    function (featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer) {
            if (typeof (layer.getBounds) !== 'undefined') {
                /** @type {?} */
                var extent = layer.getBounds();
                this._mapInstance.fitBounds(extent);
            }
            else if (typeof ((/** @type {?} */ (layer)).getLatLng) !== 'undefined') {
                /** @type {?} */
                var latLng = (/** @type {?} */ (layer)).getLatLng();
                this._mapInstance.panTo(latLng);
            }
            else {
                console.log("MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng");
            }
        }
        else {
            console.log("MapInstance.focusFeature() - Cannot focus feature because it has no layer");
        }
    };
    /**
     * @param featureId : string
     */
    /**
     * @param {?} featureId : string
     * @return {?}
     */
    MapInstance.prototype.removeFeature = /**
     * @param {?} featureId : string
     * @return {?}
     */
    function (featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer && this._featureLayer) {
            this._featureLayer.removeLayer(layer);
            this.touch('features:changed');
        }
    };
    /**
     *
     */
    /**
     *
     * @return {?}
     */
    MapInstance.prototype.removeFeatures = /**
     *
     * @return {?}
     */
    function () {
        if (this._featureLayer) {
            this._featureLayer.clearLayers();
            this.touch("features:changed");
        }
    };
    /**
     *
     */
    /**
     *
     * @param {?=} featureId
     * @return {?}
     */
    MapInstance.prototype.getFeatureLayer = /**
     *
     * @param {?=} featureId
     * @return {?}
     */
    function (featureId) {
        //if no feature was specified, return root feature layer
        if (!featureId)
            return this._featureLayer;
        //otherwise, find feature...
        if (!this._featureLayer)
            return null;
        /** @type {?} */
        var features = this._featureLayer.getLayers();
        for (var i = 0; i < features.length; ++i) {
            if ((/** @type {?} */ (features[i])).feature &&
                (/** @type {?} */ (features[i])).feature.properties.id === featureId) {
                return (/** @type {?} */ (features[i]));
            }
        }
        return null;
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.toggleFeaturesLayer = /**
     * @return {?}
     */
    function () {
        if (!this._featureLayer)
            return false; //ignore if not rendered yet
        this._featureLayerVisible = !this._featureLayerVisible;
        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);
        return this._featureLayerVisible;
    };
    /**
     * @param  feature - Leaflet feature instance
     * @param  visibility - flag
     */
    /**
     * @param {?} feature - Leaflet feature instance
     * @param {?} visibility - flag
     * @return {?}
     */
    MapInstance.prototype.setFeatureVisibility = /**
     * @param {?} feature - Leaflet feature instance
     * @param {?} visibility - flag
     * @return {?}
     */
    function (feature, visibility) {
        this.setFeatureLayerVisibility(feature, visibility);
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.getFeaturesLayerVisibility = /**
     * @return {?}
     */
    function () {
        return this._featureLayerVisible;
    };
    /*
     * method for adding feature layers to the map
     * when these layers may be layer groups.
     * finds leaf node layers and adds them to the
     * map's feature group
     */
    /**
     * @param {?} layer
     * @return {?}
     */
    MapInstance.prototype.addFeatureLayer = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        this._addFeatureLayer(layer);
        this.touch("features:changed");
    };
    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param layer
     */
    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {?} layer
     * @return {?}
     */
    MapInstance.prototype._addFeatureLayer = /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        var _this = this;
        if (!(/** @type {?} */ (layer)).feature && layer instanceof LayerGroup) {
            layer.eachLayer(function (child) {
                _this._addFeatureLayer(child);
            });
        }
        else {
            this._featureLayer.addLayer(layer);
        }
    };
    //toggle visibility of parent feature layer
    /**
     * @param {?} layer
     * @param {?} visibility
     * @return {?}
     */
    MapInstance.prototype.setFeatureLayerVisibility = /**
     * @param {?} layer
     * @param {?} visibility
     * @return {?}
     */
    function (layer, visibility) {
        var _this = this;
        if (!layer)
            return;
        this._featureLayerVisible = visibility;
        if (layer.getLayers) {
            layer.getLayers().forEach(function (child) {
                _this.setFeatureLayerVisibility(child, visibility);
            });
        }
        else {
            /** @type {?} */
            var container = layer._container || layer._path;
            if (container)
                container.style.display = visibility ? '' : 'none';
        }
    };
    /* ==============================================
       Map lifecycle operations
       ============================================== */
    /**
     * @param metadata
     * @return resolving persisted map
     */
    /**
     * @param {?} metadata
     * @return {?} resolving persisted map
     */
    MapInstance.prototype.save = /**
     * @param {?} metadata
     * @return {?} resolving persisted map
     */
    function (metadata) {
        return this.saveMap(metadata);
    };
    /**
     * @param md object containing metadata properties for map
     */
    /**
     * @param {?} md object containing metadata properties for map
     * @return {?}
     */
    MapInstance.prototype.saveMap = /**
     * @param {?} md object containing metadata properties for map
     * @return {?}
     */
    function (md) {
        var _this = this;
        /** @type {?} */
        var metadata = md || {};
        /** @type {?} */
        var gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';
        metadata.resourceTypes = metadata.resourceTypes || [];
        if (metadata.resourceTypes.indexOf(gpMapType) < 0)
            metadata.resourceTypes.push(gpMapType);
        /** @type {?} */
        var content = this.getMapResourceContent(metadata);
        //ensure the two name properties line up
        if (content.title && content.title !== content.label) {
            content.label = content.title;
        }
        else if (content.label && !content.title) {
            content.title = content.label;
        }
        // console.log("Updating: " + JSON.stringify(map));
        return this.getService(ItemTypes.MAP)
            .save(content)
            .then(function (result) {
            //track new map's info so we can update it with next save
            if (!_this._mapId)
                _this._mapId = result.id;
            _this._mapDef = result;
            _this._defaultExtent = result.extent;
            _this.clean();
            return result;
        })
            .catch(function (err) {
            console.log("MapCore MapInstance.saveMap() - " +
                "The requested map could not be saved because: " + err.message);
            /** @type {?} */
            var e = new Error("The requested map could not be saved because of the following error(s): " +
                err.message);
            return Q.reject(e);
        });
    };
    /**
     * Retrieve a map's descriptor from the registry
     * @param mapId identifier of map
     * @return resolving the map object
     */
    /**
     * Retrieve a map's descriptor from the registry
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    MapInstance.prototype.fetchMap = /**
     * Retrieve a map's descriptor from the registry
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    function (mapId) {
        //Having to send cache busting parameter to avoid CORS header cache
        // not sending correct Origin value
        return this.getService(ItemTypes.MAP).get(mapId);
    };
    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param mapId identifier of map
     * @return resolving the map object
     */
    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    MapInstance.prototype.loadMap = /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    function (mapId) {
        var _this = this;
        return this.fetchMap(mapId).then(function (map) {
            if (!map) {
                throw new Error("The requested map ('" + mapId +
                    "') came back null");
            }
            else if (typeof (map) === 'string') {
                throw new Error("The requested map ('" + mapId +
                    "') came back as a string");
            }
            else if (map.message) {
                throw new Error("There was an error loading the requested map ('" +
                    mapId + "'): " + map.message);
            }
            //loading a map by its ID, so we need to increment it's view count
            if ('development' !== Config.env) {
                setTimeout(function (map) {
                    /** @type {?} */
                    var views = map.statistics ? (map.statistics.numViews || 0) : 0;
                    /** @type {?} */
                    var patch = [{ op: 'replace', path: '/statistics/numViews', value: views + 1 }];
                    _this.getService(ItemTypes.MAP).patch(map.id, patch)
                        // this.mapService.patch(map.id, patch)
                        .then(function (updated) { map.statistics = updated.statistics; })
                        .catch(function (e) {
                        console.log("MapInstance.saveMap() - Error updating view " +
                            "count for map ('" + mapId + "'): " + e);
                    });
                }, 1000, map);
            }
            //load the map into the viewer
            //load the map into the viewer
            _this.loadMapFromObj(map);
            return map;
        })
            .catch(function (err) {
            console.log("MapInstance.loadMap() - " +
                "The requested map could not be loaded because " + err.message);
            /** @type {?} */
            var e = new Error("The requested map ('" + mapId +
                "') could not be loaded because of the following error(s): " +
                err.message);
            return Q.reject(e);
        });
    };
    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param map object
     */
    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param {?} map object
     * @return {?}
     */
    MapInstance.prototype.loadMapFromObj = /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param {?} map object
     * @return {?}
     */
    function (map) {
        var _this = this;
        // console.log("Loading Map Object");
        // console.log(map);
        this._mapId = map.id;
        this._mapDef = map;
        map.extent = map.extent || {};
        /** @type {?} */
        var west = isNaN(map.extent.minx) ? -179.0 : map.extent.minx * 1.0;
        /** @type {?} */
        var east = isNaN(map.extent.maxx) ? 179.0 : map.extent.maxx * 1.0;
        /** @type {?} */
        var south = isNaN(map.extent.miny) ? -89.0 : map.extent.miny * 1.0;
        /** @type {?} */
        var north = isNaN(map.extent.maxy) ? 89.0 : map.extent.maxy * 1.0;
        /** @type {?} */
        var t;
        if (west > east) {
            t = Math.min(west, east);
            east = map.extent.maxx = Math.max(west, east);
            west = map.extent.minx = t;
        }
        if (south > north) {
            t = Math.min(south, north);
            north = map.extent.maxy = Math.max(south, north);
            south = map.extent.miny = t;
        }
        //prevent out-of-bounds extents
        if (west < -180.0)
            west = -179.0;
        if (east > 180.0)
            east = 179.0;
        if (south < -90.0)
            south = -89.0;
        if (north > 90.0)
            north = 89.0;
        //set extent from loaded map
        this._defaultExtent = map.extent;
        /** @type {?} */
        var extent = map.extent;
        //remove existing layers
        this._mapInstance.eachLayer(function (l) {
            _this._mapInstance.removeLayer(l);
        });
        this._layerCache = {};
        this._layerStates = [];
        //set new base layer
        this.setBaseLayer(map.baseLayer);
        //add layers from loaded map
        this.addLayers(map.layers);
        //add features
        if (map.annotations && map.annotations.geoJSON) {
            /** @type {?} */
            var fc = map.annotations.geoJSON;
            if (fc.features)
                this.addFeatures(fc.features);
            else
                this.addFeatures([fc]);
        }
        this._mapInstance.fitBounds([
            [extent.miny, extent.minx],
            [extent.maxy, extent.maxx]
        ]);
        this.clean();
        this.notify('map:loaded', map);
    };
    /**
     *
     */
    /**
     *
     * @return {?}
     */
    MapInstance.prototype.destroyMap = /**
     *
     * @return {?}
     */
    function () {
        // console.log("Destroying Map");
        this._mapInstance = null;
        this._layerCache = null;
        this._layerStates = null;
        this._featureLayer = null;
    };
    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     */
    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     * @param {?} mapToUse
     * @return {?}
     */
    MapInstance.prototype.setAsNewMap = /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     * @param {?} mapToUse
     * @return {?}
     */
    function (mapToUse) {
        this._mapId = null;
        this._mapDef = mapToUse || this.initializeMapDefinition();
    };
    /* ==============================================
        Tool operations
       ============================================== */
    /**
     * @param {?} id
     * @param {?} tool
     * @return {?}
     */
    MapInstance.prototype.registerTool = /**
     * @param {?} id
     * @param {?} tool
     * @return {?}
     */
    function (id, tool) {
        this._tools[id] = tool;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    MapInstance.prototype.unregisterTool = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        this._tools[id] = null;
    };
    /**
     * @param {?} id
     * @param {?} finish
     * @return {?}
     */
    MapInstance.prototype.enableTool = /**
     * @param {?} id
     * @param {?} finish
     * @return {?}
     */
    function (id, finish) {
        if (!this._tools[id])
            return false;
        this._tools[id].activate(function () {
            this.notify('tool:disabled', id);
        });
        this.notify('tool:enabled', id);
    };
    /* ----------- MISC ------------ */
    //https://github.com/gsklee/ngStorage
    /**
     * @return {?}
     */
    MapInstance.prototype.cacheMap = /**
     * @return {?}
     */
    function () {
        if (this.state && this.state.dirty) {
            /** @type {?} */
            var map = this.getMapResourceContent();
            //use exploded layer info
            map.layers = this._layerStates.slice(0);
            // $sessionStorage.map = map;
        }
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.restoreMap = /**
     * @return {?}
     */
    function () {
        // if($sessionStorage.map) {
        //     console.log("Restoring cached map");
        //     let map = $sessionStorage.map;
        //     // console.log(JSON.stringify(map));
        //     $sessionStorage.map = null;
        //     this.loadMapFromObj(map);
        // }
    };
    return MapInstance;
}(Listener));
export default MapInstance;
if (false) {
    /** @type {?} */
    MapInstance.prototype.svcCache;
    /** @type {?} */
    MapInstance.prototype.serviceFactory;
    /** @type {?} */
    MapInstance.prototype.httpClient;
    /** @type {?} */
    MapInstance.prototype._key;
    /** @type {?} */
    MapInstance.prototype._mapId;
    /** @type {?} */
    MapInstance.prototype._mapDef;
    /** @type {?} */
    MapInstance.prototype._mapInstance;
    /** @type {?} */
    MapInstance.prototype._defaultExtent;
    /** @type {?} */
    MapInstance.prototype._baseLayerDef;
    /** @type {?} */
    MapInstance.prototype._baseLayer;
    /** @type {?} */
    MapInstance.prototype._layerStates;
    /** @type {?} */
    MapInstance.prototype._layerCache;
    /** @type {?} */
    MapInstance.prototype._layerErrors;
    /** @type {?} */
    MapInstance.prototype._layerErrorHandler;
    /** @type {?} */
    MapInstance.prototype._featureLayer;
    /** @type {?} */
    MapInstance.prototype._featureLayerVisible;
    /** @type {?} */
    MapInstance.prototype._tools;
    /** @type {?} */
    MapInstance.prototype.state;
    /** @type {?} */
    MapInstance.prototype._geoJsonLayerOpts;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdGFuY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ2VvcGxhdGZvcm0vbWFwY29yZS8iLCJzb3VyY2VzIjpbIm1hcC9pbnN0YW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUVBLE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDOztBQUNqQyxJQUFNLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFFdEIsT0FBTyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUM7QUFFdkIsT0FBTyxFQUVILFlBQVksRUFBRSxPQUFPLEVBQ3JCLFlBQVksRUFBZ0IsVUFBVSxFQUN6QyxNQUFNLFNBQVMsQ0FBQztBQUVqQixPQUFPLEVBQ0gsTUFBTSxFQUFFLFNBQVMsRUFDakIsY0FBYyxFQUNkLGdCQUFnQixFQUNuQixNQUFNLG9CQUFvQixDQUFDO0FBRTVCLE9BQU8sWUFBWSxNQUFNLGtCQUFrQixDQUFDO0FBRTVDLE9BQU8sZ0JBQWdCLE1BQU0sNEJBQTRCLENBQUM7QUFHMUQsSUFBQTtJQUlJOztRQUVJLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO0tBQ3hCOzs7Ozs7SUFFRCxxQkFBRTs7Ozs7SUFBRixVQUFJLElBQUksRUFBRSxRQUFRO1FBQ2QsSUFBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ3hDOzs7Ozs7SUFFRCxzQkFBRzs7Ozs7SUFBSCxVQUFLLElBQUksRUFBRSxRQUFRO1FBQ2YsSUFBRyxDQUFDLElBQUk7WUFBRSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUMvQixJQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPO1FBQ2xDLElBQUcsQ0FBQyxR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QUMsR0FBRyxDQUFDOztRQUNsRSxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFDLEdBQUcsQ0FBQzs7UUFDbEUsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUMsR0FBRyxDQUFDOztRQUdsRSxJQUFJLENBQUMsQ0FBQztRQUNOLElBQUcsSUFBSSxHQUFHLElBQUksRUFBRTtZQUNaLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN6QixJQUFJLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDOUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztTQUM5QjtRQUNELElBQUcsS0FBSyxHQUFHLEtBQUssRUFBRTtZQUNkLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMzQixLQUFLLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDakQsS0FBSyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztTQUMvQjs7UUFHRCxJQUFHLElBQUksR0FBRyxDQUFDLEtBQUs7WUFBRSxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUM7UUFDaEMsSUFBRyxJQUFJLEdBQUcsS0FBSztZQUFHLElBQUksR0FBSSxLQUFLLENBQUM7UUFDaEMsSUFBRyxLQUFLLEdBQUcsQ0FBQyxJQUFJO1lBQUUsS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ2hDLElBQUcsS0FBSyxHQUFHLElBQUk7WUFBRyxLQUFLLEdBQUksSUFBSSxDQUFDOztRQUdoQyxJQUFJLENBQUMsY0FBYyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUM7O1FBQ2pDLElBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUM7O1FBR3hCLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLFVBQUMsQ0FBQztZQUMxQixLQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQzs7UUFHdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7O1FBR2pDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDOztRQUczQixJQUFHLEdBQUcsQ0FBQyxXQUFXLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUU7O1lBQzNDLElBQUksRUFBRSxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDO1lBQ2pDLElBQUcsRUFBRSxDQUFDLFFBQVE7Z0JBQ1YsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7O2dCQUU5QixJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUM5QjtRQUVELElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDO1lBQ3hCLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQzFCLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDO1NBQzdCLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNiLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBRWxDO0lBR0Q7O09BRUc7Ozs7O0lBQ0gsZ0NBQVU7Ozs7SUFBVjs7UUFFSSxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUN6QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUN4QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUN6QixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztLQUM3QjtJQUdEOzs7O09BSUc7Ozs7Ozs7O0lBQ0gsaUNBQVc7Ozs7Ozs7SUFBWCxVQUFhLFFBQVE7UUFDakIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLElBQUksSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUM7S0FDN0Q7SUFHRDs7d0RBRW9EOzs7Ozs7SUFFcEQsa0NBQVk7Ozs7O0lBQVosVUFBYyxFQUFFLEVBQUUsSUFBSTtRQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztLQUMxQjs7Ozs7SUFFRCxvQ0FBYzs7OztJQUFkLFVBQWdCLEVBQUU7UUFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztLQUMxQjs7Ozs7O0lBRUQsZ0NBQVU7Ozs7O0lBQVYsVUFBWSxFQUFFLEVBQUUsTUFBTTtRQUNsQixJQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUNsQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQztZQUNyQixJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNwQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQztLQUNuQztJQUdELG1DQUFtQztJQUVuQyxxQ0FBcUM7Ozs7SUFDckMsOEJBQVE7OztJQUFSO1FBRUksSUFBRyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFOztZQUMvQixJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQzs7WUFFdkMsR0FBRyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzs7U0FFM0M7S0FDSjs7OztJQUVELGdDQUFVOzs7SUFBVjs7Ozs7Ozs7S0FRQztzQkFqM0NMO0VBNER5QyxRQUFRLEVBdXpDaEQsQ0FBQTtBQXZ6Q0QsMkJBdXpDQyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG5pbXBvcnQgKiBhcyBqcXVlcnkgZnJvbSBcImpxdWVyeVwiO1xuY29uc3QgalF1ZXJ5ID0ganF1ZXJ5O1xuXG5pbXBvcnQgKiBhcyBRIGZyb20gXCJxXCI7XG5pbXBvcnQgKiBhcyBnZW9qc29uIGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHtcbiAgICBNYXAsIExheWVyLCBMYXRMbmcsIExhdExuZ0JvdW5kcyxcbiAgICBjaXJjbGVNYXJrZXIsIGdlb0pTT04sXG4gICAgZmVhdHVyZUdyb3VwLCBGZWF0dXJlR3JvdXAsIExheWVyR3JvdXBcbn0gZnJvbSAnbGVhZmxldCc7XG5cbmltcG9ydCB7XG4gICAgQ29uZmlnLCBJdGVtVHlwZXMsXG4gICAgU2VydmljZUZhY3RvcnksIEl0ZW1TZXJ2aWNlLCBNYXBTZXJ2aWNlLCBMYXllclNlcnZpY2UsXG4gICAgSlF1ZXJ5SHR0cENsaWVudFxufSBmcm9tICdnZW9wbGF0Zm9ybS5jbGllbnQnO1xuXG5pbXBvcnQgTGF5ZXJGYWN0b3J5IGZyb20gJy4uL2xheWVyL2ZhY3RvcnknO1xuaW1wb3J0IE9TTSBmcm9tIFwiLi4vbGF5ZXIvb3NtXCI7XG5pbXBvcnQgRGVmYXVsdEJhc2VMYXllciBmcm9tICcuLi9sYXllci9iYXNlbGF5ZXItZGVmYXVsdCc7XG5cblxuY2xhc3MgTGlzdGVuZXIge1xuXG4gICAgX2xpc3RlbmVycyA6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvL2xpc3RlbmVycyB0byBiZSB1bnJlZ2lzdGVyZWQgdXBvbiBkZXN0cm95XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIH1cblxuICAgIG9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZighdGhpcy5fbGlzdGVuZXJzW3R5cGVdKVxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBvZmYgKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmKCF0eXBlKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYoIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSkgcmV0dXJuO1xuICAgICAgICBpZighbGlzdGVuZXIpIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZihpZHggPj0gMClcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub3RpZnkodHlwZSwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZighdGhpcy5fbGlzdGVuZXJzW3R5cGVdKSByZXR1cm47XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLmZvckVhY2goZnVuY3Rpb24obCkgeyBsLmFwcGx5KG51bGwsIGFyZ3MpOyB9KTtcbiAgICB9XG5cbn1cblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcEluc3RhbmNlIGV4dGVuZHMgTGlzdGVuZXIge1xuXG4gICAgcHJpdmF0ZSBzdmNDYWNoZSAgICAgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBzZXJ2aWNlRmFjdG9yeSAgOiBhbnk7XG4gICAgcHJpdmF0ZSBodHRwQ2xpZW50ICAgICAgOiBhbnk7XG4gICAgcHVibGljIF9rZXkgICAgICAgICAgICA6IHN0cmluZztcbiAgICBwcml2YXRlIF9tYXBJZCAgICAgICAgICA6IHN0cmluZztcbiAgICBwcml2YXRlIF9tYXBEZWYgICAgICAgICA6IGFueTtcbiAgICBwcml2YXRlIF9tYXBJbnN0YW5jZSAgICA6IE1hcDtcbiAgICBwcml2YXRlIF9kZWZhdWx0RXh0ZW50ICA6IGFueTtcbiAgICBwcml2YXRlIF9iYXNlTGF5ZXJEZWYgICA6IGFueTtcbiAgICBwcml2YXRlIF9iYXNlTGF5ZXIgICAgICA6IExheWVyO1xuICAgIHByaXZhdGUgX2xheWVyU3RhdGVzICAgIDogYW55O1xuICAgIHByaXZhdGUgX2xheWVyQ2FjaGUgICAgIDogYW55O1xuICAgIHByaXZhdGUgX2xheWVyRXJyb3JzICAgIDogYW55W107XG4gICAgcHJpdmF0ZSBfbGF5ZXJFcnJvckhhbmRsZXIgOiBGdW5jdGlvbjtcbiAgICBwcml2YXRlIF9mZWF0dXJlTGF5ZXIgICA6IEZlYXR1cmVHcm91cDtcbiAgICBwcml2YXRlIF9mZWF0dXJlTGF5ZXJWaXNpYmxlICA6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBfdG9vbHMgICAgICAgICAgOiBhbnlbXTtcbiAgICBwcml2YXRlIHN0YXRlICAgICAgICAgICA6IGFueTtcbiAgICBwcml2YXRlIF9nZW9Kc29uTGF5ZXJPcHRzIDogYW55O1xuXG5cblxuXG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5zZXRIdHRwQ2xpZW50KG5ldyBKUXVlcnlIdHRwQ2xpZW50KCkpO1xuICAgICAgICB0aGlzLnNldFNlcnZpY2VGYWN0b3J5KFNlcnZpY2VGYWN0b3J5KTtcblxuICAgICAgICAvL2dlbmVyYXRlIHJhbmRvbSBrZXkgKHNlZSBmYWN0b3J5IGJlbG93KVxuICAgICAgICB0aGlzLl9rZXkgPSBrZXkgfHwgTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkqOTk5OSk7XG5cbiAgICAgICAgLy9yZWdpc3RyeSBpZCBvZiBjdXJyZW50IG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgdGhpcy5fbWFwSWQgPSBudWxsLFxuXG4gICAgICAgIC8vZGVmaW5pdGlvbiBvZiBtYXAgKGllLCBmcm9tIHNlcnZlcilcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gdGhpcy5pbml0aWFsaXplTWFwRGVmaW5pdGlvbigpLFxuXG4gICAgICAgIC8vcHJpbWFyeSBtYXAgaW5zdGFuY2UgKGllLCBsZWFmbGV0KVxuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGwsXG5cbiAgICAgICAgLy9kZWZhdWx0IG1hcCBleHRlbnQgKGlmIG1hcCBkb2Vzbid0IGhhdmUgb25lIGZvciBiZWluZyBzYXZlZClcbiAgICAgICAgdGhpcy5fZGVmYXVsdEV4dGVudCA9IG51bGwsXG5cbiAgICAgICAgLy9jdXJyZW50IGJhc2UgbGF5ZXIgb2JqZWN0IGFuZCBsZWFmbGV0IGluc3RhbmNlXG4gICAgICAgIHRoaXMuX2Jhc2VMYXllckRlZiA9IG51bGwsXG4gICAgICAgIHRoaXMuX2Jhc2VMYXllciA9IG51bGwsXG5cbiAgICAgICAgLy9zZXQgZGVmaW5pdGlvbnMgb2YgbGF5ZXIgc3RhdGVzIChpbmNsdWRpbmcgbGF5ZXIgaW5mbykgb24gbWFwXG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gW10sXG5cbiAgICAgICAgLy9tYXAgbGF5ZXIgZGVmIGlkcyB3aXRoIGxlYWZsZXQgaW5zdGFuY2VzXG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSB7fSxcblxuICAgICAgICAvL2Vycm9ycyBnZW5lcmF0ZWQgYnkgbGF5ZXJzIGxvYWRpbmdcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvcnM9IFtdLFxuICAgICAgICB0aGlzLl9sYXllckVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNYXBJbnN0YW5jZS5kZWZhdWx0TGF5ZXJFcnJvckhhbmRsZXIoKSAtICR7ZS5pZH0gOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvL2xheWVyIHVzZWQgdG8gc3RvcmUgZmVhdHVyZXMgb24gbWFwXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllciA9IG51bGwsXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSB0cnVlLFxuXG4gICAgICAgIC8vc2V0IG9mIHJlZ2lzdGVyZWQgbWFwIHRvb2xzXG4gICAgICAgIHRoaXMuX3Rvb2xzID0gW10sXG5cbiAgICAgICAgLy9zdGF0ZSBtYW5hZ2VtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IGRpcnR5OiBmYWxzZSB9OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgICB0aGlzLl9nZW9Kc29uTGF5ZXJPcHRzICA9IHtcbiAgICAgICAgICAgIHN0eWxlOiBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgaWYoZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRWFjaEZlYXR1cmU6IGZ1bmN0aW9uKGZlYXR1cmUsIGxheWVyKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB7IHdlaWdodDogMiwgY29sb3I6ICcjMDNmJywgb3BhY2l0eTogMC45LCByYWRpdXM6IDQsIGZpbGxDb2xvcjogJyMwM2YnLCBmaWxsT3BhY2l0eTogMC41IH07XG4gICAgICAgICAgICAgICAgaWYofmZlYXR1cmUuZ2VvbWV0cnkudHlwZS5pbmRleE9mKCdQb2ludCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gMC45O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZlYXR1cmUucHJvcGVydGllcyA9IGZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZihmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IHVuZGVmaW5lZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo5OTk5OTkpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5sYWJlbCA9IHByb3BzLmxhYmVsIHx8IHByb3BzLnRpdGxlIHx8IHByb3BzLm5hbWUgfHwgXCJVbnRpdGxlZCBcIiArIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSArIFwiIEZlYXR1cmVcIjtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb24gPSBwcm9wcy5kZXNjcmlwdGlvbiB8fCBwcm9wcy5kZXNjIHx8IFwiVGhpcyBmZWF0dXJlIG5lZWRzIGEgZGVzY3JpcHRpb24hXCI7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlID0gcHJvcHMuc3R5bGUgfHwgc3R5bGU7XG5cbiAgICAgICAgICAgICAgICBsYXllci5iaW5kVG9vbHRpcChwcm9wcy5sYWJlbCk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICB0b2dnbGU6IHNldExhYmVsTm9IaWRlKGJvb2wpXG4gICAgICAgICAgICAgICAgaXQgbWF5IG9ubHkgZXhpc3Qgb24gbWFya2VycyFcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvaW50VG9MYXllcjogZnVuY3Rpb24gKGZlYXR1cmUgOiBhbnksIGxhdGxuZyA6IExhdExuZyApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgc3R5bGUucmFkaXVzID0gc3R5bGUucmFkaXVzIHx8IDQ7XG4gICAgICAgICAgICAgICAgc3R5bGUud2VpZ2h0ID0gc3R5bGUud2VpZ2h0IHx8IDI7XG4gICAgICAgICAgICAgICAgc3R5bGUuY29sb3IgPSBzdHlsZS5jb2xvciB8fCAnIzAzZic7XG4gICAgICAgICAgICAgICAgc3R5bGUub3BhY2l0eSA9IHN0eWxlLm9wYWNpdHkgfHwgMC45O1xuICAgICAgICAgICAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgICAgICBzdHlsZS5maWxsQ29sb3IgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lyY2xlTWFya2VyKGxhdGxuZywgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGRpc3Bvc2UgKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lNYXAoKTtcbiAgICAgICAgdGhpcy5zdmNDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmljZUZhY3RvcnkgPSBudWxsO1xuICAgICAgICB0aGlzLmh0dHBDbGllbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9rZXkgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXBJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcERlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEV4dGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Jhc2VMYXllckRlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Jhc2VMYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JzPSBudWxsO1xuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdG9vbHMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZ2VvSnNvbkxheWVyT3B0cyA9IG51bGw7XG4gICAgfVxuXG5cbiAgICBnZXRLZXkgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGRlZmF1bHQgKEpRdWVyeS1iYXNlZCkgbWFwIHNlcnZpY2UgdXNlZCBieSB0aGlzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG1hcFNlcnZpY2UgLSBzZXJ2aWNlIHRvIHVzZSB0byBDUlVEIG1hcCBvYmplY3RzXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIHNldFNlcnZpY2VGYWN0b3J5IGluc3RlYWRcbiAgICAgKi9cbiAgICBzZXRTZXJ2aWNlKG1hcFNlcnZpY2UgOiBNYXBTZXJ2aWNlKSB7XG4gICAgICAgIC8vIHRoaXMubWFwU2VydmljZSA9IG1hcFNlcnZpY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZhY3RvcnkgLSBHZW9QbGF0Zm9ybSBTZXJ2aWNlRmFjdG9yeSB0byBpbnN0YW50aWF0ZSBzZXJ2aWNlcyBmb3IgbWFwcyBhbmQgbGF5ZXJzXG4gICAgICovXG4gICAgc2V0U2VydmljZUZhY3RvcnkoZmFjdG9yeSA6IGFueSkge1xuICAgICAgICB0aGlzLnN2Y0NhY2hlID0ge307IC8vd2lwZSBvdXQgY2FjaGVkIHNlcnZpY2VzXG4gICAgICAgIHRoaXMuc2VydmljZUZhY3RvcnkgPSBmYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBodHRwQ2xpZW50IC0gSHR0cENsaWVudCBpbXBsIHRvIHVzZSB3aXRoIHRoZSBuZXcgZmFjdG9yeVxuICAgICAqL1xuICAgIHNldEh0dHBDbGllbnQoaHR0cENsaWVudCA6IGFueSkge1xuICAgICAgICB0aGlzLnN2Y0NhY2hlID0ge307IC8vd2lwZSBvdXQgY2FjaGVkIHNlcnZpY2VzXG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHR5cGUgLSBHZW9QbGF0Zm9ybSBPYmplY3QgbW9kZWwgdHlwZSB0byBzdXBwb3J0IChcIk1hcFwiLCBcIkxheWVyXCIsIGV0YylcbiAgICAgKiBAcmV0dXJuIGl0ZW0gc2VydmljZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCB0eXBlXG4gICAgICovXG4gICAgZ2V0U2VydmljZSh0eXBlIDogc3RyaW5nKSA6IEl0ZW1TZXJ2aWNlIHtcbiAgICAgICAgaWYoIXRoaXMuc3ZjQ2FjaGVbdHlwZV0pXG4gICAgICAgICAgICB0aGlzLnN2Y0NhY2hlW3R5cGVdID0gdGhpcy5zZXJ2aWNlRmFjdG9yeSh0eXBlLCBDb25maWcudWFsVXJsLCB0aGlzLmh0dHBDbGllbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdmNDYWNoZVt0eXBlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZm4gLSBjYWxsYmFjayB3aGVuIGFuIGVycm9yIGlzIGVuY291bnRlcmVkXG4gICAgICovXG4gICAgc2V0RXJyb3JIYW5kbGVyKGZuKSB7XG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JIYW5kbGVyID0gZm47XG4gICAgfVxuXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0TGF5ZXJTdGF0ZUluZGV4IChsYXllcklkKSB7XG4gICAgICAgIGlmKCFsYXllcklkKSByZXR1cm4gLTE7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpPHRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZih0aGlzLl9sYXllclN0YXRlc1tpXS5sYXllciAmJiBsYXllcklkID09PSB0aGlzLl9sYXllclN0YXRlc1tpXS5sYXllci5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMuX2xheWVyU3RhdGVzLmluZGV4T2ZPYmoobGF5ZXJJZCwgKGlkLCBzdGF0ZSkgPT4gc3RhdGUubGF5ZXIuaWQgPT09IGlkICk7XG4gICAgfVxuXG4gICAgZ2V0TGF5ZXJTdGF0ZSAobGF5ZXJJZCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldExheWVyU3RhdGVJbmRleChsYXllcklkKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyB0aGlzLl9sYXllclN0YXRlc1tpbmRleF0gOiBudWxsO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgIGluaXRpYWxpemVNYXBEZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogSXRlbVR5cGVzLk1BUCxcbiAgICAgICAgICAgIHRpdGxlOiBcIk15IE5ldyBNYXBcIixcbiAgICAgICAgICAgIGxhYmVsOiBcIk15IE5ldyBNYXBcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgbWFwIG5lZWRzIGEgZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGNyZWF0ZWRCeTogbnVsbCxcbiAgICAgICAgICAgIGJhc2VMYXllcjogdGhpcy5fYmFzZUxheWVyRGVmLFxuICAgICAgICAgICAgbGF5ZXJzOiBbXSxcbiAgICAgICAgICAgIGtleXdvcmRzOiBbXSxcbiAgICAgICAgICAgIHRoZW1lczogW10sXG4gICAgICAgICAgICByZXNvdXJjZVR5cGVzOiBbJ2h0dHA6Ly93d3cuZ2VvcGxhdGZvcm0uZ292L29udC9vcGVubWFwL0dlb3BsYXRmb3JtTWFwJ11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBvYmplY3QgZGVmaW5pdGlvbiBvZiB0aGUgY3VycmVudCBtYXAgc3VpdGFibGUgZm9yIHNlbmRpbmcgdG8gV01WUlxuICAgICAqL1xuICAgIGdldE1hcFJlc291cmNlQ29udGVudChtZXRhZGF0YSA/OiBhbnkpIHtcblxuICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhIHx8IHt9O1xuXG4gICAgICAgIC8vbWFwIGxheWVyc1xuICAgICAgICBtZXRhZGF0YS5sYXllcnMgPSB0aGlzLl9sYXllclN0YXRlcy5zbGljZSgwKTtcbiAgICAgICAgLy8gLi4uIFVBTCBzaG91bGQgc3VwcG9ydCBhY2NlcHRpbmcganVzdCBhbiBpZCBoZXJlLCBzbyB3ZSdsbCBkbyBqdXN0IHRoYXRcbiAgICAgICAgbWV0YWRhdGEuYmFzZUxheWVyID0gdGhpcy5fYmFzZUxheWVyRGVmO1xuXG4gICAgICAgIG1ldGFkYXRhLmFubm90YXRpb25zID0gdGhpcy5fZmVhdHVyZUxheWVyID9cbiAgICAgICAgICAgIHsgdGl0bGU6IFwiTWFwIEZlYXR1cmVzXCIsIGdlb0pTT046IHRoaXMuX2ZlYXR1cmVMYXllci50b0dlb0pTT04oKSB9IDogbnVsbDtcblxuICAgICAgICAvL2dlb2dyYXBoaWMgZXh0ZW50XG4gICAgICAgIGxldCBleHRlbnQgPSB0aGlzLl9tYXBJbnN0YW5jZS5nZXRCb3VuZHMoKTtcbiAgICAgICAgbWV0YWRhdGEuZXh0ZW50ID0ge1xuICAgICAgICAgICAgbWlueDogZXh0ZW50LmdldFdlc3QoKSxcbiAgICAgICAgICAgIG1pbnk6IGV4dGVudC5nZXRTb3V0aCgpLFxuICAgICAgICAgICAgbWF4eDogZXh0ZW50LmdldEVhc3QoKSxcbiAgICAgICAgICAgIG1heHk6IGV4dGVudC5nZXROb3J0aCgpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gTGVhZmxldCB0b29sYmFyXG4gICAgICovXG4gICAgZ2V0RHJhd0NvbnRyb2xUb29sYmFyKCkge1xuICAgICAgICBpZighKHRoaXMuX21hcEluc3RhbmNlIGFzIGFueSkuZHJhd0NvbnRyb2wpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgdG9vbGJhcnMgPSAodGhpcy5fbWFwSW5zdGFuY2UgYXMgYW55KS5kcmF3Q29udHJvbC5fdG9vbGJhcnM7XG4gICAgICAgIHZhciB0b29sYmFyID0gbnVsbDtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdG9vbGJhcnMpIHtcbiAgICAgICAgICAgIGlmKHRvb2xiYXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZih0b29sYmFyc1trZXldLl9tb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyID0gdG9vbGJhcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b29sYmFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBlcnJvciBMZWFmbGV0IHRpbGUgbG9hZCBlcnJvciAoLnRhcmdldCBpcyBsYXllciwgLnRpbGUgaXMgaW1hZ2UpXG4gICAgICovXG4gICAgaGFuZGxlTGF5ZXJFcnJvcihlcnJvcikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmhhbmRsZUxheWVyRXJyb3IoKSAtIFwiICtcbiAgICAgICAgLy8gICAgIFwiTGF5ZXIncyB0aWxlIGZhaWxlZCB0byBsb2FkOiBcIiArIGVycm9yLnRpbGUuc3JjKTtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5hYmxlIHRvIGZpbmQgbGF5ZXIgaW4gbGF5ZXIgY2FjaGUuIExheWVyIGVycm9yIGlzIFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXllciA9IGVycm9yLnRhcmdldDtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLl9sYXllckNhY2hlKSB7XG4gICAgICAgICAgICBpZih0aGlzLl9sYXllckNhY2hlW2lkXSA9PT0gbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NMYXllckVycm9yKGVycm9yLCBpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIExlYWZsZXQgdGlsZSBsb2FkIGVycm9yIGFuZCB0aGUgcmVzcG9uc2libGUgbGF5ZXIgaWQsXG4gICAgICogVHJ5IHRvIGlzb2xhdGUgdGhlIGNhdXNlIG9mIHRoZSBlcnJvciB1c2luZyB0aGUgcHJveHlcbiAgICAgKiBhbmQgbm90aWZ5IGxpc3RlbmVycyB0aGF0IGFuIGVycm9yIGhhcyBvY2N1cnJlZFxuICAgICAqL1xuICAgIHByb2Nlc3NMYXllckVycm9yKGVycm9yIDogRXJyb3IsIGlkIDogc3RyaW5nKSB7XG5cbiAgICAgICAgdmFyIGZpbmRlciA9IChsKSA9PiB7IHJldHVybiBsLmlkID09PSBpZCB8fCAobC5sYXllciAmJiBsLmxheWVyLmlkID09PSBpZCk7IH07XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyRXJyb3JzLmZpbmQoZmluZGVyKSkge1xuXG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5sb2dMYXllckVycm9yKGlkLCBcIkxheWVyICgnXCIgKyBpZCArIFwiJykgZmFpbGVkIHRvIGNvbXBsZXRlbHkgbG9hZC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiSXQgbWF5IGJlIGluYWNjZXNzaWJsZSBvciBtaXNjb25maWd1cmVkLlwiKTtcblxuICAgICAgICAgICAgdmFyIHVybCA9IChlcnJvciBhcyBhbnkpLnRpbGUuc3JjO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtpZDppZH07XG4gICAgICAgICAgICB1cmwuc3Vic3RyaW5nKHVybC5pbmRleE9mKFwiP1wiKSsxLCB1cmwubGVuZ3RoKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhcmFtLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3BbMF1dID0gcFsxXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgbGF5ZXJTZXJ2aWNlID0gdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5MQVlFUik7XG4gICAgICAgICAgICBpZihsYXllclNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICBsYXllclNlcnZpY2UudmFsaWRhdGUoaWQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSB0aGlzLl9sYXllclN0YXRlcy5maW5kKGZpbmRlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm1lc3NhZ2UgPSBcIkxheWVyICdcIiArIGRlZi5sYXllci5sYWJlbCArIFwiJyBmYWlsZWQgdG8gY29tcGxldGVseSBsb2FkLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVwb3J0ZWQgY2F1c2U6IFwiICsgZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KCdsYXllcjplcnJvcicsIG9iaik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXJJZCAtIGlkZW50aWZpZXIgb2YgbGF5ZXIgZ2VuZXJhdGluZyB0aGUgZXJyb3JcbiAgICAgKiBAcGFyYW0gZXJyb3JNc2cgLSBtZXNzYWdlIG9mIHRoZSBlcnJvclxuICAgICAqL1xuICAgIGxvZ0xheWVyRXJyb3IobGF5ZXJJZCwgZXJyb3JNc2cpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5sb2dMYXllckVycm9yKCkgLSBsYXllciBcIiAgKyBpZCArXG4gICAgICAgIC8vICAgICBcIiBnZW5lcmF0ZWQgZXJyb3IgJ1wiICsgZXJyb3JNc2cgKyBcIidcIik7XG4gICAgICAgIGxldCBlcnIgPSB7IGlkOiBsYXllcklkLCBtZXNzYWdlOiBlcnJvck1zZyB9O1xuICAgICAgICB0aGlzLl9sYXllckVycm9ycy5wdXNoKGVycik7XG4gICAgICAgIGlmKHRoaXMuX2xheWVyRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllckVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgLyogLS0gU3RhdGUgTWFuYWdlbWVudCBvZiBpbnRlcm5hbCBtb2RlbCAtLSAqL1xuXG4gICAgdG91Y2ggKGV2ZW50ID86IGFueSwgLi4ub3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0YXRlLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShldmVudCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkRpcnR5aW5nIG1hcCBmb3IgXCIgKyBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBjb25zb2xlLmxvZyhcIkRpcnR5aW5nIG1hcFwiKTtcbiAgICB9XG4gICAgY2xlYW4oKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQ2xlYW5pbmcgbWFwXCIpO1xuICAgICAgICB0aGlzLnN0YXRlLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBNYXAgbWFuaXB1bGF0aW9uIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBzZXRNYXAgKG1hcCA6IE1hcCkgeyB0aGlzLl9tYXBJbnN0YW5jZSA9IG1hcDsgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiAgbWFwIGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0TWFwICgpIDogTWFwIHsgcmV0dXJuIHRoaXMuX21hcEluc3RhbmNlOyB9XG5cbiAgICAvKiogQHJldHVybiBkZWZpbml0aW9uIG9mIG1hcCAqL1xuICAgIGdldE1hcERlZmluaXRpb24gKCkgOiBhbnkgeyByZXR1cm4gdGhpcy5fbWFwRGVmOyB9XG5cbiAgICAvKiogQHJldHVybiBpZGVudGlmaWVyIG9mIG1hcCAqL1xuICAgIGdldE1hcElkICgpIDogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX21hcElkOyB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBtYXAgb24gdGhlIHNwZWNpZmllZCBsYXQvbG5nIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbGF0IG51bWJlclxuICAgICAqIEBwYXJhbSBsbmcgbnVtYmVyXG4gICAgICogQHBhcmFtIHpvb20gbnVtYmVyIChvcHRpb25hbClcbiAgICAgKi9cbiAgICBzZXRWaWV3IChsYXQgOiBudW1iZXIsIGxuZyA6IG51bWJlciwgem9vbSA/OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHogPSB6b29tO1xuICAgICAgICBpZih0eXBlb2YoeikgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgeiA9IHRoaXMuX21hcEluc3RhbmNlLmdldFpvb20oKTtcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2Uuc2V0VmlldyhbbGF0LGxuZ10sIHopO1xuICAgICAgICB0aGlzLnRvdWNoKCdtYXA6dmlldzpjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHRoZSBtYXBcbiAgICAgKiBAcmV0dXJuIFtsYXQsbG5nXVxuICAgICAqL1xuICAgIGdldFZpZXcgKCkgOiBudW1iZXJbXSB7XG4gICAgICAgIHZhciBsYXRMbmcgPSB0aGlzLl9tYXBJbnN0YW5jZS5nZXRDZW50ZXIoKTtcbiAgICAgICAgcmV0dXJuIFtsYXRMbmcubGF0LCBsYXRMbmcubG5nXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGludGVnZXIgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXBcbiAgICAgKi9cbiAgICBnZXRab29tICgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcEluc3RhbmNlLmdldFpvb20oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tIHRvIHRoZSBtYXAncyBkZWZhdWx0IGV4dGVudFxuICAgICAqIElmIHRoZSBtYXAgaXMgc2F2ZWQsIHRoaXMgd2lsbCBiZSB0aGUgc2F2ZWQgdmlld3BvcnRcbiAgICAgKiBvdGhlcndpc2UsIGl0IHdpbGwgYmUgQ09OVVNcbiAgICAgKi9cbiAgICB6b29tVG9EZWZhdWx0ICgpIHtcbiAgICAgICAgaWYoIXRoaXMuX21hcEluc3RhbmNlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuX2RlZmF1bHRFeHRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhbXG4gICAgICAgICAgICAgICAgW3RoaXMuX2RlZmF1bHRFeHRlbnQubWlueSwgdGhpcy5fZGVmYXVsdEV4dGVudC5taW54XSxcbiAgICAgICAgICAgICAgICBbdGhpcy5fZGVmYXVsdEV4dGVudC5tYXh5LCB0aGlzLl9kZWZhdWx0RXh0ZW50Lm1heHhdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2Uuem9vbVRvRGVmYXVsdCgpIC0gTm8gZGVmYXVsdCBleHRlbnQgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2Uuc2V0VmlldyhbMzgsIC05Nl0sIDUpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdtYXA6dmlldzpjaGFuZ2VkJyk7XG4gICAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV4dGVudCAtIGVpdGhlciBhIEdQIGV4dGVudCBvYmplY3Qgb3IgTGVhZmxldCBMYXRMbmdCb3VuZHMgb2JqZWN0XG4gICAgICovXG4gICAgc2V0RXh0ZW50KGV4dGVudCA6IExhdExuZ0JvdW5kc3xhbnkpIHtcbiAgICAgICAgaWYoIWV4dGVudCkgcmV0dXJuO1xuICAgICAgICBpZiggdHlwZW9mKGV4dGVudC5taW54KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZihleHRlbnQubWlueSkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YoZXh0ZW50Lm1heHgpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mKGV4dGVudC5tYXh5KSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICAvL0dQIG1vZGVsIGV4dGVudFxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKFtcbiAgICAgICAgICAgICAgICBbZXh0ZW50Lm1pbnksIGV4dGVudC5taW54XSxcbiAgICAgICAgICAgICAgICBbZXh0ZW50Lm1heHksIGV4dGVudC5tYXh4XVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YoZXh0ZW50LmdldFdlc3QpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy9MLkxhdExuZ0JvdW5kc1xuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKGV4dGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBMYXllciBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXIgTGVhZmxldCBMYXllciBpbnN0YW5jZSBvciBvYmplY3QgZGVmaW5pdGlvblxuICAgICAqL1xuICAgIHNldEJhc2VMYXllciAobGF5ZXIgOiBhbnkpIHtcblxuICAgICAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGlmKCFsYXllcikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IERlZmF1bHRCYXNlTGF5ZXIuZ2V0KHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTEFZRVIpKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBwcm9taXNlID0gUS5yZXNvbHZlKGxheWVyKTtcblxuICAgICAgICBwcm9taXNlLnRoZW4oIGxheWVyID0+IHtcblxuICAgICAgICAgICAgbGV0IGxlYWZsZXRMYXllciA9IExheWVyRmFjdG9yeS5jcmVhdGUobGF5ZXIpO1xuICAgICAgICAgICAgaWYoIWxlYWZsZXRMYXllcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogTWFwSW5zdGFuY2UgY291bGQgbm90IGNyZWF0ZSBiYXNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJsYXllciBmb3IgJ1wiICsgbGF5ZXIuaWQgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5hZGRMYXllcihsZWFmbGV0TGF5ZXIpO1xuXG4gICAgICAgICAgICAobGVhZmxldExheWVyIGFzIGFueSkuc2V0WkluZGV4KDApOyAgLy9zZXQgYXQgYm90dG9tXG5cbiAgICAgICAgICAgIGxldCBvbGRCYXNlTGF5ZXIgPSB0aGlzLl9iYXNlTGF5ZXI7XG4gICAgICAgICAgICBpZihvbGRCYXNlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihvbGRCYXNlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JlbWVtYmVyIG5ldyBiYXNlIGxheWVyXG4gICAgICAgICAgICB0aGlzLl9iYXNlTGF5ZXIgPSBsZWFmbGV0TGF5ZXI7XG4gICAgICAgICAgICB0aGlzLl9iYXNlTGF5ZXJEZWYgPSBsYXllcjtcblxuICAgICAgICAgICAgLy93aWxsIG5vdGlmeSBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ2Jhc2VsYXllcjpjaGFuZ2VkJywgbGF5ZXIsIGxlYWZsZXRMYXllcik7XG4gICAgICAgICAgICAvLyB0aGlzLm5vdGlmeSgnYmFzZWxheWVyOmNoYW5nZWQnLCBsYXllciwgbGVhZmxldExheWVyKTtcblxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTWFwSW5zdGFuY2Uuc2V0QmFzZUxheWVyKCkgLSBFcnJvciBnZXR0aW5nIGJhc2UgbGF5ZXIgZm9yIG1hcCA6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgdGhpcy5sb2dMYXllckVycm9yKCBsYXllci5pZCwgXCJFcnJvciBzZXR0aW5nIGJhc2VsYXllciBvbiBtYXAgXCIgK1xuICAgICAgICAgICAgICAgIFwiYmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGVycm9yKHMpOiBcIiArIGUubWVzc2FnZSApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGFycmF5IG9mIGJhc2UgbGF5ZXJzIGRlZmluaXRpb25zIHRoYXQgY2FuIGJlIHVzZWRcbiAgICAgKi9cbiAgICAvLyBnZXRCYXNlTGF5ZXJPcHRpb25zICgpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuX2Jhc2VMYXllck9wdGlvbnM7XG4gICAgLy8gfSxcblxuICAgIGdldEJhc2VMYXllciAoKSA6IGFueSB7IHJldHVybiB0aGlzLl9iYXNlTGF5ZXJEZWY7IH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gbGlzdCBvZiBsYXllciBzdGF0ZXMgY29udGFpbmluZyBsYXllciBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGdldExheWVycyAoKSA6IGFueVtdIHsgcmV0dXJuIHRoaXMuX2xheWVyU3RhdGVzOyB9XG5cbiAgICBnZXRMYXllckVycm9ycyAoKSA6IGFueVtdIHsgcmV0dXJuIHRoaXMuX2xheWVyRXJyb3JzOyB9XG5cbiAgICBjbGVhckxheWVyRXJyb3JzICgpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xheWVyOmVycm9yJyk7XG4gICAgfVxuXG4gICAgY2xlYXJPdmVybGF5cyAoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIGZvcih2YXIgaT10aGlzLl9sYXllclN0YXRlcy5sZW5ndGgtMTsgaT49MDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9sYXllclN0YXRlc1tpXTtcbiAgICAgICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtzdGF0ZS5sYXllci5pZF07XG4gICAgICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5vZmYoXCJsYXllcjplcnJvclwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllckNhY2hlW3N0YXRlLmxheWVyLmlkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIobGF5ZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy50b3VjaCgnbGF5ZXJzOmNoYW5nZWQnKTtcblxuICAgICAgICAvL1RPRE8gc3RvcCBsaXN0ZW5pbmcgZm9yIGxheWVyIGV2ZW50c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsYXllcnMgLSBsaXN0IG9mIGxheWVycyAoTk9URTogbm90IHdyYXBwZWQgYnkgbGF5ZXIgc3RhdGVzLCB0aGlzIG1ldGhvZCBhcHBsaWVzIHRoYXQpXG4gICAgICovXG4gICAgYWRkTGF5ZXJzIChsYXllcnMgOiBhbnl8YW55W10gKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk46IGF0dGVtcHRpbmcgdG8gYWRkIGxheWVycyB0byBhbiBlbXB0eSBjYWNoZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk46IEF0dGVtcHRpbmcgdG8gYWRkIGxheWVycyB0byBhIG1hcCB3aXRoIG5vIGxheWVyIGNhY2hlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWxheWVycykgcmV0dXJuO1xuICAgICAgICBpZih0eXBlb2YobGF5ZXJzLnB1c2gpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGF5ZXJzID0gW2xheWVyc107XG4gICAgICAgIH1cblxuICAgICAgICBsYXllcnMuZm9yRWFjaCggKG9iaixpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgbGF5ZXIgPSBudWxsLCBzdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmKG9iai50eXBlICYmIG9iai50eXBlPT09SXRlbVR5cGVzLkxBWUVSKSB7IC8vaXMgYSBsYXllclxuICAgICAgICAgICAgICAgIGxheWVyID0gb2JqO1xuICAgICAgICAgICAgfSBlbHNlIGlmKG9iai5sYXllcikgeyAgLy9pcyBsYXllciBzdGF0ZVxuICAgICAgICAgICAgICAgIGxheWVyID0gb2JqLmxheWVyOyAgLy8gY29udGFpbmluZyBhIGxheWVyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBvYmo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFsYXllcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UuYWRkTGF5ZXJzKCkgLSBsYXllciAoXCIgKyBpbmRleCArXG4gICAgICAgICAgICAgICAgICAgIFwiKSBpcyBub3QgYSBMYXllciBvciBhIExheWVyIHN0YXRlLiBJZ25vcmluZy4uLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAvL2xheWVyIGluZm8gaXMgbWlzc2luZywgc2tpcCBpdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL0RULTQ0MiBwcmV2ZW50IGFkZGluZyBsYXllciB0aGF0IGFscmVhZHkgZXhpc3RzIG9uIG1hcFxuICAgICAgICAgICAgaWYodGhpcy5fbGF5ZXJDYWNoZVtsYXllci5pZF0pIHJldHVybjtcblxuICAgICAgICAgICAgaWYoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy93cmFwcGVkIGluIHRyeXt9Y2F0Y2ggYmVjYXVzZSBsYXllciBtYXkgY29udGFpbiBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSBlcnJvciB3aGVuIHVzZWQgYnkgSlNPTiBtZXRob2RzXG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXllckNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxheWVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogbGF5ZXJDb3B5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBhZGQgbGF5ZXIgdG8gbWFwIGJlY2F1c2Ugb2YgXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHogPSBsYXllcnMubGVuZ3RoIC0gaW5kZXg7XG4gICAgICAgICAgICBzdGF0ZS56SW5kZXggPSB6O1xuXG4gICAgICAgICAgICB0aGlzLmFkZExheWVyV2l0aFN0YXRlKGxheWVyLCBzdGF0ZSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50b3VjaCgnbGF5ZXJzOmNoYW5nZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBHZW9QbGF0Zm9ybSBMYXllciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEdlb1BsYXRmb3JtIExheWVyIFN0YXRlXG4gICAgICovXG4gICAgYWRkTGF5ZXJXaXRoU3RhdGUobGF5ZXIsIHN0YXRlKSB7XG5cbiAgICAgICAgdmFyIGxlYWZsZXRMYXllciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZighbGF5ZXIgfHwgIXN0YXRlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQsIG1pc3NpbmcgbGF5ZXIgYW5kIG9yIHN0YXRlXCIpO1xuXG4gICAgICAgICAgICBsZWFmbGV0TGF5ZXIgPSBMYXllckZhY3RvcnkuY3JlYXRlKGxheWVyKTtcbiAgICAgICAgICAgIGlmKCFsZWFmbGV0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY3JlYXRlIGxlYWZsZXQgbGF5ZXIgZm9yIEdQIExheWVyICdcIiArXG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmlkICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dMYXllckVycm9yKCBsYXllci5pZCxcbiAgICAgICAgICAgICAgICBcIkxheWVyICdcIiArIGxheWVyLmxhYmVsICsgXCInIGNvdWxkIG5vdCBiZSBhZGRlZCB0byB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIFwibWFwIGluc3RhbmNlOyBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighbGVhZmxldExheWVyKSByZXR1cm47XG5cbiAgICAgICAgLy9jYWNoZSBsZWFmbGV0IG9iamVjdCBmaXJzdFxuICAgICAgICBpZih0aGlzLl9sYXllckNhY2hlKSB0aGlzLl9sYXllckNhY2hlW2xheWVyLmlkXSA9IGxlYWZsZXRMYXllcjtcblxuICAgICAgICAvL2xpc3RlbiBmb3IgbGF5ZXIgZXJyb3JzIHNvIHdlIGNhbiBpbmZvcm0gdGhlIHVzZXJcbiAgICAgICAgLy8gdGhhdCBhIGxheWVyIGhhc24ndCBiZWVuIGxvYWRlZCBpbiBhIHVzZWZ1bCB3YXlcbiAgICAgICAgbGVhZmxldExheWVyLm9uKCd0aWxlZXJyb3InLCAoZSkgPT4geyB0aGlzLmhhbmRsZUxheWVyRXJyb3IoZSk7IH0pO1xuXG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmFkZExheWVyKGxlYWZsZXRMYXllcik7XG5cbiAgICAgICAgaWYoICFpc05hTihzdGF0ZS56SW5kZXgpICYmIGxlYWZsZXRMYXllci5zZXRaSW5kZXggKVxuICAgICAgICAgICAgbGVhZmxldExheWVyLnNldFpJbmRleChzdGF0ZS56SW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzLnB1c2goc3RhdGUpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdsYXllcjphZGRlZCcsIGxheWVyLCBsZWFmbGV0TGF5ZXIpO1xuXG5cbiAgICAgICAgLy8gaWYgbGF5ZXIgaXMgaW5pdGlhbGx5IFwib2ZmXCIgb3IuLi5cbiAgICAgICAgLy8gaWYgbGF5ZXIgaXMgaW5pdGlhbGx5IG5vdCAxMDAlIG9wYXF1ZVxuICAgICAgICBpZighc3RhdGUudmlzaWJpbGl0eSB8fCBzdGF0ZS5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBsYXllciB2aXNpYmlsaXR5IGFuZCBvcGFjaXR5IGFzeW5jLCBvciBlbHNlXG4gICAgICAgICAgICAvLyBzb21lIG9mIHRoZSBsYXllcnMgd29uJ3QgZ2V0IHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCAobGF5ZXIsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMYXllclZpc2liaWxpdHkobGF5ZXIsIHN0YXRlLnZpc2liaWxpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF5ZXJPcGFjaXR5KGxheWVyLCBzdGF0ZS5vcGFjaXR5KTtcbiAgICAgICAgICAgICAgICAvL1RPRE8gbm90aWZ5IG9mIGNoYW5nZVxuXG4gICAgICAgICAgICAgICAgLy9EVC0yMTAyIHRpbWVvdXQgbmVlZHMgdG8gYmUgbGFyZ2UgZW5vdWdoIG9yIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBmZWF0dXJlIGxheWVycyB3b24ndCBnZXQgb3BhY2l0eSB1cGRhdGVkIG9uIG1hcCBsb2FkXG4gICAgICAgICAgICB9LCAyMDAwLCBsZWFmbGV0TGF5ZXIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmcm9tIC0gcG9zaXRpb24gb2YgbGF5ZXIgYmVpbmcgbW92ZWRcbiAgICAgKiBAcGFyYW0gdG8gLSBkZXNpcmVkIHBvc2l0aW9uIHRvIG1vdmUgbGF5ZXIgdG9cbiAgICAgKi9cbiAgICBtb3ZlTGF5ZXIgKGZyb20gOiBudW1iZXIsIHRvIDogbnVtYmVyKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcblxuICAgICAgICBpZihpc05hTihmcm9tKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vZW5kIG9mIGxpc3RcbiAgICAgICAgaWYoaXNOYU4odG8pKSB0byA9IHRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aC0xO1xuXG4gICAgICAgIGxldCBjb3B5ID0gdGhpcy5fbGF5ZXJTdGF0ZXMuc3BsaWNlKGZyb20sIDEpWzBdOyAgICAvL2dyYWIgbGF5ZXIgYmVpbmcgbW92ZWRcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMuc3BsaWNlKHRvLCAwLCBjb3B5KTtcblxuICAgICAgICBmb3IobGV0IHo9MSwgaT10aGlzLl9sYXllclN0YXRlcy5sZW5ndGgtMTsgaT49MDsgLS1pLCsreikge1xuICAgICAgICAgICAgbGV0IGxheWVyU3RhdGUgPSB0aGlzLl9sYXllclN0YXRlc1tpXTtcbiAgICAgICAgICAgIGxldCBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVsgbGF5ZXJTdGF0ZS5sYXllci5pZCBdO1xuICAgICAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2Uuc2V0WkluZGV4KHopO1xuICAgICAgICAgICAgICAgIGxheWVyU3RhdGUuekluZGV4ID0gejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG91Y2goJ2xheWVyczpjaGFuZ2VkJywgdGhpcy5nZXRMYXllcnMoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVMYXllciAoaWQpIHtcblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbaWRdO1xuICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGxheWVyIGZyb20gdHJhY2tlZCBkZWZzIGFycmF5XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldExheWVyU3RhdGVJbmRleChpZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLnJlbW92ZUxheWVyKFwiICsgaWQgKyBcIilcIik7XG4gICAgICAgICAgICBpZihpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU3RhdGVzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIC8vc3RvcCBsaXN0ZW5pbmcgZm9yIGVycm9yc1xuICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5vZmYoXCJsYXllcjplcnJvclwiKTtcblxuICAgICAgICAgICAgLy9yZW1vdmUgbGF5ZXIgZnJvbSBtYXBcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnJlbW92ZUxheWVyKGxheWVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBsYXllciBmcm9tIGNhY2hlXG4gICAgICAgICAgICB0aGlzLl9sYXllckNhY2hlW2lkXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaCgnbGF5ZXJzOmNoYW5nZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUxheWVyVmlzaWJpbGl0eSAoaWQpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW2lkXTtcbiAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKGlkKTtcbiAgICAgICAgICAgIHN0YXRlLnZpc2liaWxpdHkgPSAhc3RhdGUudmlzaWJpbGl0eTtcblxuICAgICAgICAgICAgaWYobGF5ZXJJbnN0YW5jZS5fY3VycmVudEltYWdlKSB7XG4gICAgICAgICAgICAgICAgLy9FU1JJIEltYWdlIFNlcnZpY2UgbGF5ZXJzIGhhdmUgYW4gSU1HIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGdldHMgbW9kaWZpZWQgYW5kIHJlcGxhY2VkIGV2ZXJ5IG1hcCBldmVudCAoem9vbS9wYW4pXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuJ3QganVzdCB0b2dnbGUgY2xhc3NlcyBsaWtlIG9uIG90aGVyIGxheWVycy5cbiAgICAgICAgICAgICAgICAvL0luc3RlYWQsIHdlIG5lZWQgdG8gdXNlIHRoZSBFU1JJIHNldE9wYWNpdHkgbWV0aG9kIHRvIHRvZ2dsZVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBuZWVkIHRvIHVwZGF0ZSBsYXllciBzdGF0ZSBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2Uuc2V0T3BhY2l0eShzdGF0ZS52aXNpYmlsaXR5ID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wYWNpdHkgPSBsYXllckluc3RhbmNlLmdldE9wYWNpdHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0TGF5ZXJWaXNpYmlsaXR5KGxheWVySW5zdGFuY2UsIHN0YXRlLnZpc2liaWxpdHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCB1cGRhdGUgbGF5ZXIgZGVmaW5pdGlvbiBzdGF0ZS4gVXNlXG4gICAgICogTWFwSW5zdGFuY2UudG9nZ2xlTGF5ZXJWaXNpYmlsaXR5IHRvIGRvIHRoYXQgYW5kIGFkanVzdFxuICAgICAqIHJlbmRlcmVkIGxheWVyJ3MgdmlzaWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllckluc3RhbmNlIC0gbGVhZmxldCBsYXllciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gZmxhZyBpbmRpY2F0aW5nIHZpc2liaWxpdHkgb2YgbGF5ZXJcbiAgICAgKi9cbiAgICBzZXRMYXllclZpc2liaWxpdHkgKGxheWVySW5zdGFuY2UgOiBMYXllciwgdmlzaWJsZSA6IGJvb2xlYW4pIHtcblxuICAgICAgICBpZigobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLnNldFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIC8vdXNpbmcgY3VzdG9tIG1ldGhvZCBwcm92aWRlZCBpbiBzcmMvbGF5ZXIvbW9kdWxlLmpzXG4gICAgICAgICAgICAobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLnNldFZpc2liaWxpdHkodmlzaWJsZSk7XG5cbiAgICAgICAgfSBlbHNlIGlmKChsYXllckluc3RhbmNlIGFzIGFueSkuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgLy9vdGhlcndpc2UsIHVzaW5nIGpxdWVyeSBvbiBkb20gZGlyZWN0bHlcbiAgICAgICAgICAgIGxldCBlbCA9IGpRdWVyeSgobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gaWYodmlzaWJsZSkgZWwucmVtb3ZlQ2xhc3MoXCJpbnZpc2libGVcIik7XG4gICAgICAgICAgICAvLyBlbHNlIGVsLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgICAgICAgIGVsLmNzcyh7J2Rpc3BsYXknOiB2aXNpYmxlID8gJycgOiAnbm9uZSd9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG91Y2goJ21hcDpsYXllcjpjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVMYXllck9wYWNpdHkgKGlkIDogc3RyaW5nLCBvcGFjaXR5IDogbnVtYmVyKSB7XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW2lkXTtcblxuICAgICAgICAvL2lmIGxheWVyIGlkIGlzIGZvciBiYXNlIGxheWVyLi4uXG4gICAgICAgIGlmKCFsYXllckluc3RhbmNlICYmIHRoaXMuX2Jhc2VMYXllckRlZi5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIGxheWVySW5zdGFuY2UgPSB0aGlzLl9iYXNlTGF5ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvL2FkanVzdCByZW5kZXJlZCBsZWFmbGV0IGxheWVyXG4gICAgICAgIG9wYWNpdHkgPSB0aGlzLnNldExheWVyT3BhY2l0eShsYXllckluc3RhbmNlLCBvcGFjaXR5KTtcblxuICAgICAgICAvLyBpZiBvdmVybGF5IGxheWVyLCB1cGRhdGUgc3RhdGUgdmFsdWVcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKGlkKTtcbiAgICAgICAgaWYoc3RhdGUpIHN0YXRlLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgZG9lcyBub3QgdXBkYXRlIHRoZSBhc3NvY2lhdGVkIExheWVyIERlZmluaXRpb25cbiAgICAgKiBzdGF0ZSB2YWx1ZSBmb3Igb3BhY2l0eS4gVXNlIE1hcEluc3RhbmNlLnVwZGF0ZUxheWVyT3BhY2l0eSgpIHRvXG4gICAgICogYm90aCB1cGRhdGUgc3RhdGUgYW5kIGFkanVzdCByZW5kZXJlZCBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllckluc3RhbmNlIC0gbGVhZmxldCBsYXllciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBvcGFjaXR5IC0gdmFsdWUgYmV0d2VlbiAwIGFuZCAxLjAgb3IgMCBhbmQgMTAwXG4gICAgICogQHJldHVybiBub3JtYWxpemVkIG9wYWNpdHkgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLjBcbiAgICAgKi9cbiAgICBzZXRMYXllck9wYWNpdHkgKGxheWVySW5zdGFuY2UgOiBMYXllciwgb3BhY2l0eSA6IG51bWJlcikgOiBudW1iZXIge1xuICAgICAgICBpZihsYXllckluc3RhbmNlICYmIChsYXllckluc3RhbmNlIGFzIGFueSkuc2V0T3BhY2l0eSkge1xuICAgICAgICAgICAgaWYob3BhY2l0eSA+IDEuMCkgb3BhY2l0eSA9IG9wYWNpdHkgLyAxMDAuMDtcbiAgICAgICAgICAgIChsYXllckluc3RhbmNlIGFzIGFueSkuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ21hcDpsYXllcjpjaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wYWNpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIEdlb1BsYXRmb3JtIExheWVyIGluc3RhbmNlXG4gICAgICogQHJldHVybiBMZWFmbGV0IGxheWVyIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGF0IGxheWVyIG9yIG51bGxcbiAgICAgKi9cbiAgICBnZXRMZWFmbGV0TGF5ZXJGb3IgKGdwTGF5ZXIgOiBhbnkpIDogTGF5ZXIge1xuICAgICAgICBpZighZ3BMYXllciB8fCAhdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBsZWFmbGV0TGF5ZXIgPSB0aGlzLl9sYXllckNhY2hlW2dwTGF5ZXIuaWRdO1xuICAgICAgICByZXR1cm4gbGVhZmxldExheWVyIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVHZXRGZWF0dXJlSW5mbyAobGF5ZXJJZCA6IHN0cmluZykge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbbGF5ZXJJZF07XG4gICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZihsYXllckluc3RhbmNlLmVuYWJsZUdldEZlYXR1cmVJbmZvKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZihsYXllckluc3RhbmNlLmlzR2V0RmVhdHVyZUluZm9FbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5kaXNhYmxlR2V0RmVhdHVyZUluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCh0aGlzLl9tYXBJbnN0YW5jZSBhcyBhbnkpLl9jb250YWluZXIpLnJlbW92ZUNsYXNzKCdzZWxlY3RhYmxlLWN1cnNvcicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2UuZW5hYmxlR2V0RmVhdHVyZUluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCh0aGlzLl9tYXBJbnN0YW5jZSBhcyBhbnkpLl9jb250YWluZXIpLmFkZENsYXNzKCdzZWxlY3RhYmxlLWN1cnNvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgRmVhdHVyZSBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGFycmF5IG9mIGZlYXR1cmVzIG9uIHRoZSBtYXBcbiAgICAgKi9cbiAgICBnZXRGZWF0dXJlcyAoKSA6IGFueVtdIHtcbiAgICAgICAgaWYodGhpcy5fZmVhdHVyZUxheWVyKSB7XG4gICAgICAgICAgICBsZXQgZ2VvanNvbiA9IHRoaXMuX2ZlYXR1cmVMYXllci50b0dlb0pTT04oKTtcbiAgICAgICAgICAgIHJldHVybiAoZ2VvanNvbiBhcyBhbnkpLmZlYXR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ganNvbiBnZW9qc29uIG9iamVjdCBvciBhcnJheSBvZiBnZW9qc29uIG9iamVjdHNcbiAgICAgKi9cbiAgICBhZGRGZWF0dXJlcyAoanNvbiA6IGFueSkge1xuXG4gICAgICAgIGlmKCFqc29uKSByZXR1cm47XG5cbiAgICAgICAgaWYodHlwZW9mKGpzb24ucHVzaCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvL2FycmF5IG9mIGZlYXR1cmVzXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxqc29uLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZShqc29uW2ldLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdmZWF0dXJlczpjaGFuZ2VkJyk7XG5cbiAgICAgICAgfSBlbHNlIGlmKGpzb24uZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZXMoanNvbi5mZWF0dXJlcyk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy9zaW5nbGUgZmVhdHVyZVxuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGpzb24sIHRydWUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ganNvbiBnZW9qc29uIG9iamVjdFxuICAgICAqL1xuICAgIGFkZEZlYXR1cmUgKGpzb24gOiBhbnksIGZpcmVFdmVudCA/OiBib29sZWFuKSB7XG4gICAgICAgIC8vIHZhciB0eXBlID0ganNvbi50eXBlO1xuICAgICAgICAvLyB2YXIgY29vcmRpbmF0ZXMgPSBqc29uLmNvb3JkaW5hdGVzO1xuXG4gICAgICAgIGlmKCF0aGlzLl9mZWF0dXJlTGF5ZXIpIHtcblxuICAgICAgICAgICAgLy8gX2ZlYXR1cmVMYXllciA9IGdlb0pTT04oW10sIF9nZW9Kc29uTGF5ZXJPcHRzKS5hZGRUbyhfbWFwSW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gZmVhdHVyZUdyb3VwKCkuYWRkVG8odGhpcy5fbWFwSW5zdGFuY2UpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBfZmVhdHVyZUxheWVyLmFkZERhdGEoanNvbik7XG4gICAgICAgIHZhciBvcHRzID0galF1ZXJ5LmV4dGVuZCh7fSwgdGhpcy5fZ2VvSnNvbkxheWVyT3B0cyk7XG4gICAgICAgIGdlb0pTT04oanNvbiwgb3B0cykuZWFjaExheWVyKChsKT0+dGhpcy5hZGRGZWF0dXJlTGF5ZXIobCkpO1xuXG4gICAgICAgIGlmKHR5cGVvZihmaXJlRXZlbnQpID09PSAndW5kZWZpbmVkJyB8fCBmaXJlRXZlbnQgPT09IHRydWUpXG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdmZWF0dXJlczpjaGFuZ2VkJyk7XG4gICAgICAgIGVsc2UgdGhpcy50b3VjaCgpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KF9mZWF0dXJlTGF5ZXIudG9HZW9KU09OKCkpKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmZWF0dXJlSnNvbiBvYmplY3QgZGVmaW5pbmcgYSBHZW9KU09OIGZlYXR1cmVcbiAgICAgKi9cbiAgICB1cGRhdGVGZWF0dXJlIChmZWF0dXJlSnNvbiA6IGFueSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldEZlYXR1cmVMYXllcihmZWF0dXJlSnNvbi5wcm9wZXJ0aWVzLmlkKTtcbiAgICAgICAgaWYobGF5ZXIpIHtcblxuICAgICAgICAgICAgKGxheWVyIGFzIGFueSkuZmVhdHVyZSA9IGZlYXR1cmVKc29uO1xuXG4gICAgICAgICAgICAvL3VwZGF0ZSBzdHlsZVxuICAgICAgICAgICAgbGF5ZXIuc2V0U3R5bGUoZmVhdHVyZUpzb24ucHJvcGVydGllcy5zdHlsZSk7XG5cbiAgICAgICAgICAgIC8vcmViaW5kIGxhYmVsIGluIGNhc2UgdGhhdCBjaGFuZ2VkXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBmZWF0dXJlSnNvbi5wcm9wZXJ0aWVzLmxhYmVsIHx8XG4gICAgICAgICAgICAgICAgXCJVbnRpdGxlZCBcIiArIGZlYXR1cmVKc29uLmdlb21ldHJ5LnR5cGUgKyBcIiBGZWF0dXJlXCI7XG4gICAgICAgICAgICBsYXllci5iaW5kVG9vbHRpcChsYWJlbCk7XG5cbiAgICAgICAgICAgIC8vIGxheWVyLnJlZHJhdygpO1xuICAgICAgICAgICAgdGhpcy50b3VjaChcIm1hcDpmZWF0dXJlOmNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIGFuIGV4aXN0aW5nIEwuUGF0aC1iYXNlZCBsYXllciB3aXRoIG9uZSB1c2luZ1xuICAgICAqIHRoZSBzdXBwbGllZCBGZWF0dXJlIEdlb0pTT04gb2JqZWN0LiAgUmVtb3ZlcyB0aGUgZXhpc3RpbmdcbiAgICAgKiBsYXllciBhbmQgYWRkcyBhIG5ldyBvbmUgY3JlYXRlZCBmcm9tIHRoZSBHZW9KU09OLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZlYXR1cmVKc29uIG9iamVjdCBkZWZpbmluZyBHZW9KU09OIGZlYXR1cmVcbiAgICAgKi9cbiAgICByZXBsYWNlRmVhdHVyZSAoZmVhdHVyZUpzb24gOiBhbnkpIHtcblxuICAgICAgICAvL2ZpbmQgZXhpc3RpbmcgbGF5ZXIgZm9yIHRoaXMgZmVhdHVyZVxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldEZlYXR1cmVMYXllcihmZWF0dXJlSnNvbi5wcm9wZXJ0aWVzLmlkKTtcbiAgICAgICAgaWYobGF5ZXIpIHtcblxuICAgICAgICAgICAgLy9yZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllci5yZW1vdmVMYXllcihsYXllcik7XG5cbiAgICAgICAgICAgIC8vYWRkIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBnZW9KU09OKGZlYXR1cmVKc29uLCB0aGlzLl9nZW9Kc29uTGF5ZXJPcHRzKVxuICAgICAgICAgICAgICAgIC5lYWNoTGF5ZXIoKGwpPT50aGlzLmFkZEZlYXR1cmVMYXllcihsKSk7XG5cbiAgICAgICAgICAgIHRoaXMudG91Y2goXCJtYXA6ZmVhdHVyZTpjaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZlYXR1cmVJZCBpZGVudGlmaWVyIG9mIGZlYXR1cmUgdG8gZm9jdXMgdGhlIG1hcCBvblxuICAgICAqL1xuICAgIGZvY3VzRmVhdHVyZSAoZmVhdHVyZUlkIDogc3RyaW5nKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0RmVhdHVyZUxheWVyKGZlYXR1cmVJZCk7XG4gICAgICAgIGlmKGxheWVyKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mKGxheWVyLmdldEJvdW5kcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVudCA9IGxheWVyLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhleHRlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiggKGxheWVyIGFzIGFueSkuZ2V0TGF0TG5nKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF0TG5nID0gKGxheWVyIGFzIGFueSkuZ2V0TGF0TG5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucGFuVG8obGF0TG5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5mb2N1c0ZlYXR1cmUoKSAtIENhbm5vdCBmb2N1cyBmZWF0dXJlIGJlY2F1c2UgaXQgaGFzIG5vIGJvdW5kcyBvciBsYXQvbG5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5mb2N1c0ZlYXR1cmUoKSAtIENhbm5vdCBmb2N1cyBmZWF0dXJlIGJlY2F1c2UgaXQgaGFzIG5vIGxheWVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZlYXR1cmVJZCA6IHN0cmluZ1xuICAgICAqL1xuICAgIHJlbW92ZUZlYXR1cmUgKGZlYXR1cmVJZCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldEZlYXR1cmVMYXllcihmZWF0dXJlSWQpO1xuICAgICAgICBpZihsYXllciAmJiB0aGlzLl9mZWF0dXJlTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllci5yZW1vdmVMYXllcihsYXllcik7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdmZWF0dXJlczpjaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUZlYXR1cmVzICgpIHtcbiAgICAgICAgaWYodGhpcy5fZmVhdHVyZUxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goXCJmZWF0dXJlczpjaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRGZWF0dXJlTGF5ZXIgKCBmZWF0dXJlSWQgPzogc3RyaW5nICkgOiBGZWF0dXJlR3JvdXAge1xuICAgICAgICAvL2lmIG5vIGZlYXR1cmUgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHJvb3QgZmVhdHVyZSBsYXllclxuICAgICAgICBpZighZmVhdHVyZUlkKSByZXR1cm4gdGhpcy5fZmVhdHVyZUxheWVyO1xuXG4gICAgICAgIC8vb3RoZXJ3aXNlLCBmaW5kIGZlYXR1cmUuLi5cbiAgICAgICAgaWYoIXRoaXMuX2ZlYXR1cmVMYXllcikgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5fZmVhdHVyZUxheWVyLmdldExheWVycygpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxmZWF0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYoIChmZWF0dXJlc1tpXSBhcyBhbnkpLmZlYXR1cmUgJiZcbiAgICAgICAgICAgICAgICAoZmVhdHVyZXNbaV0gYXMgYW55KS5mZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IGZlYXR1cmVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmVhdHVyZXNbaV0gYXMgYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0b2dnbGVGZWF0dXJlc0xheWVyICgpIHtcbiAgICAgICAgaWYoIXRoaXMuX2ZlYXR1cmVMYXllcikgcmV0dXJuIGZhbHNlOyAgICAvL2lnbm9yZSBpZiBub3QgcmVuZGVyZWQgeWV0XG5cbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSA9ICF0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlO1xuICAgICAgICB0aGlzLnNldEZlYXR1cmVMYXllclZpc2liaWxpdHkodGhpcy5fZmVhdHVyZUxheWVyLCB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICBmZWF0dXJlIC0gTGVhZmxldCBmZWF0dXJlIGluc3RhbmNlXG4gICAgICogQHBhcmFtICB2aXNpYmlsaXR5IC0gZmxhZ1xuICAgICAqL1xuICAgIHNldEZlYXR1cmVWaXNpYmlsaXR5IChmZWF0dXJlLCB2aXNpYmlsaXR5IDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnNldEZlYXR1cmVMYXllclZpc2liaWxpdHkoZmVhdHVyZSwgdmlzaWJpbGl0eSk7XG4gICAgfVxuXG4gICAgZ2V0RmVhdHVyZXNMYXllclZpc2liaWxpdHkgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZTtcbiAgICB9XG5cblxuICAgIC8qXG4gICAgICogbWV0aG9kIGZvciBhZGRpbmcgZmVhdHVyZSBsYXllcnMgdG8gdGhlIG1hcFxuICAgICAqIHdoZW4gdGhlc2UgbGF5ZXJzIG1heSBiZSBsYXllciBncm91cHMuXG4gICAgICogZmluZHMgbGVhZiBub2RlIGxheWVycyBhbmQgYWRkcyB0aGVtIHRvIHRoZVxuICAgICAqIG1hcCdzIGZlYXR1cmUgZ3JvdXBcbiAgICAgKi9cbiAgICBhZGRGZWF0dXJlTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgdGhpcy5fYWRkRmVhdHVyZUxheWVyKGxheWVyKTtcbiAgICAgICAgdGhpcy50b3VjaChcImZlYXR1cmVzOmNoYW5nZWRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kLCB1c2UgJ2FkZEZlYXR1cmVMYXllcicgaW5zdGVhZFxuICAgICAqIEBwYXJhbSBsYXllclxuICAgICAqL1xuICAgIF9hZGRGZWF0dXJlTGF5ZXIobGF5ZXIgOiBMYXllcikge1xuICAgICAgICBpZighKGxheWVyIGFzIGFueSkuZmVhdHVyZSAmJiBsYXllciBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgICAgICAgIGxheWVyLmVhY2hMYXllciggKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRmVhdHVyZUxheWVyKGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLmFkZExheWVyKGxheWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy90b2dnbGUgdmlzaWJpbGl0eSBvZiBwYXJlbnQgZmVhdHVyZSBsYXllclxuICAgIHNldEZlYXR1cmVMYXllclZpc2liaWxpdHkobGF5ZXIsIHZpc2liaWxpdHkpIHtcbiAgICAgICAgaWYoIWxheWVyKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSB2aXNpYmlsaXR5O1xuXG4gICAgICAgIGlmKGxheWVyLmdldExheWVycykge1xuICAgICAgICAgICAgbGF5ZXIuZ2V0TGF5ZXJzKCkuZm9yRWFjaCggKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KGNoaWxkLCB2aXNpYmlsaXR5KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciB8fCBsYXllci5fcGF0aDtcbiAgICAgICAgICAgIGlmKGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9IHZpc2liaWxpdHkgPyAnJyA6ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgTWFwIGxpZmVjeWNsZSBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAgICogQHJldHVybiByZXNvbHZpbmcgcGVyc2lzdGVkIG1hcFxuICAgICAqL1xuICAgIHNhdmUgKG1ldGFkYXRhIDogYW55KSA6IFByb21pc2U8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVNYXAobWV0YWRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZCBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciBtYXBcbiAgICAgKi9cbiAgICBzYXZlTWFwIChtZCA6IGFueSkgOiBQcm9taXNlPGFueT4ge1xuXG4gICAgICAgIGxldCBtZXRhZGF0YSA9IG1kIHx8IHt9O1xuXG4gICAgICAgIC8vYWRkIEdlb1BsYXRmb3JtTWFwIHJlc291cmNlIHR5cGUgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICBjb25zdCBncE1hcFR5cGUgPSAnaHR0cDovL3d3dy5nZW9wbGF0Zm9ybS5nb3Yvb250L29wZW5tYXAvR2VvcGxhdGZvcm1NYXAnO1xuICAgICAgICBtZXRhZGF0YS5yZXNvdXJjZVR5cGVzID0gbWV0YWRhdGEucmVzb3VyY2VUeXBlcyB8fCBbXTtcbiAgICAgICAgaWYobWV0YWRhdGEucmVzb3VyY2VUeXBlcy5pbmRleE9mKGdwTWFwVHlwZSkgPCAwKVxuICAgICAgICAgICAgbWV0YWRhdGEucmVzb3VyY2VUeXBlcy5wdXNoKGdwTWFwVHlwZSk7XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldE1hcFJlc291cmNlQ29udGVudChtZXRhZGF0YSk7XG5cbiAgICAgICAgLy9lbnN1cmUgdGhlIHR3byBuYW1lIHByb3BlcnRpZXMgbGluZSB1cFxuICAgICAgICBpZihjb250ZW50LnRpdGxlICYmIGNvbnRlbnQudGl0bGUgIT09IGNvbnRlbnQubGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnQubGFiZWwgPSBjb250ZW50LnRpdGxlO1xuICAgICAgICB9IGVsc2UgaWYoY29udGVudC5sYWJlbCAmJiAhY29udGVudC50aXRsZSkge1xuICAgICAgICAgICAgY29udGVudC50aXRsZSA9IGNvbnRlbnQubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVwZGF0aW5nOiBcIiArIEpTT04uc3RyaW5naWZ5KG1hcCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5NQVApXG4gICAgICAgIC5zYXZlKGNvbnRlbnQpXG4gICAgICAgIC50aGVuKCByZXN1bHQgPT4ge1xuXG4gICAgICAgICAgICAvL3RyYWNrIG5ldyBtYXAncyBpbmZvIHNvIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCBuZXh0IHNhdmVcbiAgICAgICAgICAgIGlmKCF0aGlzLl9tYXBJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJZCA9IHJlc3VsdC5pZDtcblxuICAgICAgICAgICAgdGhpcy5fbWFwRGVmID0gcmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEV4dGVudCA9IHJlc3VsdC5leHRlbnQ7XG4gICAgICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyPT57XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcENvcmUgTWFwSW5zdGFuY2Uuc2F2ZU1hcCgpIC0gXCIgK1xuICAgICAgICAgICAgICAgIFwiVGhlIHJlcXVlc3RlZCBtYXAgY291bGQgbm90IGJlIHNhdmVkIGJlY2F1c2U6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJUaGUgcmVxdWVzdGVkIG1hcCBjb3VsZCBub3QgYmUgc2F2ZWQgYmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGVycm9yKHMpOiBcIiArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFEucmVqZWN0KGUpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWFwJ3MgZGVzY3JpcHRvciBmcm9tIHRoZSByZWdpc3RyeVxuICAgICAqIEBwYXJhbSBtYXBJZCBpZGVudGlmaWVyIG9mIG1hcFxuICAgICAqIEByZXR1cm4gcmVzb2x2aW5nIHRoZSBtYXAgb2JqZWN0XG4gICAgICovXG4gICAgZmV0Y2hNYXAgKG1hcElkIDogc3RyaW5nKSA6IFByb21pc2U8YW55PiB7XG4gICAgICAgIC8vSGF2aW5nIHRvIHNlbmQgY2FjaGUgYnVzdGluZyBwYXJhbWV0ZXIgdG8gYXZvaWQgQ09SUyBoZWFkZXIgY2FjaGVcbiAgICAgICAgLy8gbm90IHNlbmRpbmcgY29ycmVjdCBPcmlnaW4gdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTUFQKS5nZXQobWFwSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWFwJ3MgZGVzY3JpcHRvciBhbmQgbG9hZCBpdCBhcyB0aGVcbiAgICAgKiBjdXJyZW50IG1hcCBtYW5hZ2VkIGJ5IHRoaXMgc2VydmljZVxuICAgICAqIEBwYXJhbSBtYXBJZCBpZGVudGlmaWVyIG9mIG1hcFxuICAgICAqIEByZXR1cm4gcmVzb2x2aW5nIHRoZSBtYXAgb2JqZWN0XG4gICAgICovXG4gICAgbG9hZE1hcCAobWFwSWQgOiBzdHJpbmcpIDogUHJvbWlzZTxhbnk+IHtcblxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE1hcChtYXBJZCkudGhlbihtYXAgPT4ge1xuXG4gICAgICAgICAgICBpZighbWFwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArIG1hcElkICtcbiAgICAgICAgICAgICAgICAgICAgXCInKSBjYW1lIGJhY2sgbnVsbFwiKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihtYXApID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgbWFwICgnXCIgKyBtYXBJZCArXG4gICAgICAgICAgICAgICAgICAgIFwiJykgY2FtZSBiYWNrIGFzIGEgc3RyaW5nXCIpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYobWFwLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3IgbG9hZGluZyB0aGUgcmVxdWVzdGVkIG1hcCAoJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgbWFwSWQgKyBcIicpOiBcIiArIG1hcC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvL2xvYWRpbmcgYSBtYXAgYnkgaXRzIElELCBzbyB3ZSBuZWVkIHRvIGluY3JlbWVudCBpdCdzIHZpZXcgY291bnRcbiAgICAgICAgICAgIGlmKCdkZXZlbG9wbWVudCcgIT09IENvbmZpZy5lbnYpIHtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIChtYXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgdmlldyBjb3VudFxuICAgICAgICAgICAgICAgICAgICBsZXQgdmlld3MgPSBtYXAuc3RhdGlzdGljcyA/IChtYXAuc3RhdGlzdGljcy5udW1WaWV3c3x8MCkgOiAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0Y2ggPSBbIHsgb3A6ICdyZXBsYWNlJywgcGF0aDogJy9zdGF0aXN0aWNzL251bVZpZXdzJywgdmFsdWU6IHZpZXdzKzEgfSBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLk1BUCkucGF0Y2gobWFwLmlkLCBwYXRjaClcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5tYXBTZXJ2aWNlLnBhdGNoKG1hcC5pZCwgcGF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCB1cGRhdGVkID0+IHsgbWFwLnN0YXRpc3RpY3MgPSB1cGRhdGVkLnN0YXRpc3RpY3M7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCggZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLnNhdmVNYXAoKSAtIEVycm9yIHVwZGF0aW5nIHZpZXcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY291bnQgZm9yIG1hcCAoJ1wiICsgbWFwSWQgKyBcIicpOiBcIiArIGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAxMDAwLCBtYXApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbG9hZCB0aGUgbWFwIGludG8gdGhlIHZpZXdlclxuICAgICAgICAgICAgdGhpcy5sb2FkTWFwRnJvbU9iaihtYXApO1xuXG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goIGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmxvYWRNYXAoKSAtIFwiICtcbiAgICAgICAgICAgICAgICBcIlRoZSByZXF1ZXN0ZWQgbWFwIGNvdWxkIG5vdCBiZSBsb2FkZWQgYmVjYXVzZSBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArIG1hcElkICtcbiAgICAgICAgICAgICAgICBcIicpIGNvdWxkIG5vdCBiZSBsb2FkZWQgYmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGVycm9yKHMpOiBcIiArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFEucmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgbWFwIGZyb20gaXRzIGRlc2NyaXB0b3IgYXMgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXAgbWFuYWdlZCBieSB0aGlzIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0gbWFwIG9iamVjdFxuICAgICAqL1xuICAgIGxvYWRNYXBGcm9tT2JqIChtYXAgOiBhbnkpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkxvYWRpbmcgTWFwIE9iamVjdFwiKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2cobWFwKTtcblxuICAgICAgICB0aGlzLl9tYXBJZCA9IG1hcC5pZDtcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gbWFwO1xuXG4gICAgICAgIG1hcC5leHRlbnQgPSBtYXAuZXh0ZW50IHx8IHt9O1xuICAgICAgICBsZXQgd2VzdCA9ICBpc05hTihtYXAuZXh0ZW50Lm1pbngpID8gLTE3OS4wIDogbWFwLmV4dGVudC5taW54KjEuMDtcbiAgICAgICAgbGV0IGVhc3QgPSAgaXNOYU4obWFwLmV4dGVudC5tYXh4KSA/ICAxNzkuMCA6IG1hcC5leHRlbnQubWF4eCoxLjA7XG4gICAgICAgIGxldCBzb3V0aCA9IGlzTmFOKG1hcC5leHRlbnQubWlueSkgPyAgLTg5LjAgOiBtYXAuZXh0ZW50Lm1pbnkqMS4wO1xuICAgICAgICBsZXQgbm9ydGggPSBpc05hTihtYXAuZXh0ZW50Lm1heHkpID8gICA4OS4wIDogbWFwLmV4dGVudC5tYXh5KjEuMDtcblxuICAgICAgICAvL2Vuc3VyZSB4LHkgaXMgb3JkZXJlZCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGlmKHdlc3QgPiBlYXN0KSB7XG4gICAgICAgICAgICB0ID0gTWF0aC5taW4od2VzdCwgZWFzdCk7XG4gICAgICAgICAgICBlYXN0ID0gbWFwLmV4dGVudC5tYXh4ID0gTWF0aC5tYXgod2VzdCwgZWFzdCk7XG4gICAgICAgICAgICB3ZXN0ID0gbWFwLmV4dGVudC5taW54ID0gdDtcbiAgICAgICAgfVxuICAgICAgICBpZihzb3V0aCA+IG5vcnRoKSB7XG4gICAgICAgICAgICB0ID0gTWF0aC5taW4oc291dGgsIG5vcnRoKTtcbiAgICAgICAgICAgIG5vcnRoID0gbWFwLmV4dGVudC5tYXh5ID0gTWF0aC5tYXgoc291dGgsIG5vcnRoKTtcbiAgICAgICAgICAgIHNvdXRoID0gbWFwLmV4dGVudC5taW55ID0gdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcHJldmVudCBvdXQtb2YtYm91bmRzIGV4dGVudHNcbiAgICAgICAgaWYod2VzdCA8IC0xODAuMCkgd2VzdCA9IC0xNzkuMDtcbiAgICAgICAgaWYoZWFzdCA+IDE4MC4wKSAgZWFzdCA9ICAxNzkuMDtcbiAgICAgICAgaWYoc291dGggPCAtOTAuMCkgc291dGggPSAtODkuMDtcbiAgICAgICAgaWYobm9ydGggPiA5MC4wKSAgbm9ydGggPSAgODkuMDtcblxuICAgICAgICAvL3NldCBleHRlbnQgZnJvbSBsb2FkZWQgbWFwXG4gICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSBtYXAuZXh0ZW50O1xuICAgICAgICB2YXIgZXh0ZW50ID0gbWFwLmV4dGVudDtcblxuICAgICAgICAvL3JlbW92ZSBleGlzdGluZyBsYXllcnNcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZWFjaExheWVyKChsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBbXTtcblxuICAgICAgICAvL3NldCBuZXcgYmFzZSBsYXllclxuICAgICAgICB0aGlzLnNldEJhc2VMYXllcihtYXAuYmFzZUxheWVyKTtcblxuICAgICAgICAvL2FkZCBsYXllcnMgZnJvbSBsb2FkZWQgbWFwXG4gICAgICAgIHRoaXMuYWRkTGF5ZXJzKG1hcC5sYXllcnMpO1xuXG4gICAgICAgIC8vYWRkIGZlYXR1cmVzXG4gICAgICAgIGlmKG1hcC5hbm5vdGF0aW9ucyAmJiBtYXAuYW5ub3RhdGlvbnMuZ2VvSlNPTikge1xuICAgICAgICAgICAgbGV0IGZjID0gbWFwLmFubm90YXRpb25zLmdlb0pTT047XG4gICAgICAgICAgICBpZihmYy5mZWF0dXJlcylcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVzKGZjLmZlYXR1cmVzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVzKFtmY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKFtcbiAgICAgICAgICAgIFtleHRlbnQubWlueSwgZXh0ZW50Lm1pbnhdLFxuICAgICAgICAgICAgW2V4dGVudC5tYXh5LCBleHRlbnQubWF4eF1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbWFwOmxvYWRlZCcsIG1hcCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveU1hcCAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRGVzdHJveWluZyBNYXBcIik7XG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdGFrZSBhbiBleGlzdGluZyBtYXAgdGhhdCBpcyBhbHJlYWR5IHBlcnNpc3RlZCBvbiB0aGVcbiAgICAgKiBzZXJ2ZXIgYW5kIHVubGluayBpdCBoZXJlIGluIHRoZSBjbGllbnQgc28gdGhhdCBpdCB3aWxsIGJlIHNhdmVkXG4gICAgICogYXMgYSBjb21wbGV0ZWx5IG5ldyBtYXAgd2hlbiBtYXBTZXJ2aWNlLnNhdmVNYXAoLi4uKSBpcyBuZXh0IGNhbGxlZFxuICAgICAqL1xuICAgIHNldEFzTmV3TWFwIChtYXBUb1VzZSkge1xuICAgICAgICB0aGlzLl9tYXBJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcERlZiA9IG1hcFRvVXNlIHx8IHRoaXMuaW5pdGlhbGl6ZU1hcERlZmluaXRpb24oKTtcbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgVG9vbCBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgcmVnaXN0ZXJUb29sIChpZCwgdG9vbCkge1xuICAgICAgICB0aGlzLl90b29sc1tpZF0gPSB0b29sO1xuICAgIH1cblxuICAgIHVucmVnaXN0ZXJUb29sIChpZCkge1xuICAgICAgICB0aGlzLl90b29sc1tpZF0gPSBudWxsO1xuICAgIH1cblxuICAgIGVuYWJsZVRvb2wgKGlkLCBmaW5pc2gpIHtcbiAgICAgICAgaWYoIXRoaXMuX3Rvb2xzW2lkXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90b29sc1tpZF0uYWN0aXZhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSgndG9vbDpkaXNhYmxlZCcsIGlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCd0b29sOmVuYWJsZWQnLCBpZCk7XG4gICAgfVxuXG5cbiAgICAvKiAtLS0tLS0tLS0tLSBNSVNDIC0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLy9odHRwczovL2dpdGh1Yi5jb20vZ3NrbGVlL25nU3RvcmFnZVxuICAgIGNhY2hlTWFwICgpIHtcblxuICAgICAgICBpZih0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcFJlc291cmNlQ29udGVudCgpO1xuICAgICAgICAgICAgLy91c2UgZXhwbG9kZWQgbGF5ZXIgaW5mb1xuICAgICAgICAgICAgbWFwLmxheWVycyA9IHRoaXMuX2xheWVyU3RhdGVzLnNsaWNlKDApO1xuICAgICAgICAgICAgLy8gJHNlc3Npb25TdG9yYWdlLm1hcCA9IG1hcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3RvcmVNYXAgKCkge1xuICAgICAgICAvLyBpZigkc2Vzc2lvblN0b3JhZ2UubWFwKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIlJlc3RvcmluZyBjYWNoZWQgbWFwXCIpO1xuICAgICAgICAvLyAgICAgbGV0IG1hcCA9ICRzZXNzaW9uU3RvcmFnZS5tYXA7XG4gICAgICAgIC8vICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShtYXApKTtcbiAgICAgICAgLy8gICAgICRzZXNzaW9uU3RvcmFnZS5tYXAgPSBudWxsO1xuICAgICAgICAvLyAgICAgdGhpcy5sb2FkTWFwRnJvbU9iaihtYXApO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbn1cbiJdfQ==