/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import * as jquery from "jquery";
/** @type {?} */
var jQuery = jquery;
import { circleMarker, geoJSON, featureGroup, LayerGroup } from 'leaflet';
import { Config, ItemTypes, ServiceFactory, XHRHttpClient } from '@geoplatform/client';
import LayerFactory from '../layer/factory';
import DefaultBaseLayer from '../layer/baselayer-default';
var Listener = /** @class */ (function () {
    function Listener() {
        //listeners to be unregistered upon destroy
        this._listeners = {};
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    Listener.prototype.on = /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    function (type, listener) {
        if (!this._listeners[type])
            this._listeners[type] = [];
        this._listeners[type].push(listener);
    };
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    Listener.prototype.off = /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    function (type, listener) {
        if (!type)
            this._listeners = {};
        if (!this._listeners[type])
            return;
        if (!listener)
            this._listeners[type] = [];
        else {
            /** @type {?} */
            var idx = this._listeners[type].indexOf(listener);
            if (idx >= 0)
                this._listeners[type].splice(idx, 1);
        }
    };
    /**
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    Listener.prototype.notify = /**
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    function (type) {
        var options = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            options[_i - 1] = arguments[_i];
        }
        if (!this._listeners[type])
            return;
        /** @type {?} */
        var args = Array.prototype.slice.call(arguments, 1);
        this._listeners[type].forEach(function (l) { l.apply(null, args); });
    };
    return Listener;
}());
if (false) {
    /** @type {?} */
    Listener.prototype._listeners;
}
var MapInstance = /** @class */ (function (_super) {
    tslib_1.__extends(MapInstance, _super);
    function MapInstance(key) {
        var _this = _super.call(this) || this;
        _this.setHttpClient(new XHRHttpClient());
        _this.setServiceFactory(ServiceFactory);
        //generate random key (see factory below)
        //generate random key (see factory below)
        _this._key = key || Math.ceil(Math.random() * 9999);
        //registry id of current map if available
        //registry id of current map if available
        _this._mapId = null,
            //definition of map (ie, from server)
            //definition of map (ie, from server)
            _this._mapDef = _this.initializeMapDefinition(),
            //primary map instance (ie, leaflet)
            //primary map instance (ie, leaflet)
            _this._mapInstance = null,
            //default map extent (if map doesn't have one for being saved)
            //default map extent (if map doesn't have one for being saved)
            _this._defaultExtent = null,
            //current base layer object and leaflet instance
            //current base layer object and leaflet instance
            _this._baseLayerDef = null,
            _this._baseLayer = null,
            //set definitions of layer states (including layer info) on map
            //set definitions of layer states (including layer info) on map
            _this._layerStates = [],
            //map layer def ids with leaflet instances
            //map layer def ids with leaflet instances
            _this._layerCache = {},
            //errors generated by layers loading
            //errors generated by layers loading
            _this._layerErrors = [],
            _this._layerErrorHandler = function (e) {
                console.log("MapInstance.defaultLayerErrorHandler() - " + e.id + " : " + e.message);
            },
            //layer used to store features on map
            //layer used to store features on map
            _this._featureLayer = null,
            _this._featureLayerVisible = true,
            //set of registered map tools
            //set of registered map tools
            _this._tools = [],
            //state management
            //state management
            _this.state = { dirty: false }; // jshint ignore:line
        _this._geoJsonLayerOpts = {
            style: function (feature) {
                if (feature.properties.style)
                    return feature.properties.style;
            },
            onEachFeature: function (feature, layer) {
                /** @type {?} */
                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };
                if (~feature.geometry.type.indexOf('Point')) {
                    style.fillOpacity = 0.9;
                }
                /** @type {?} */
                var props = feature.properties = feature.properties || {};
                if (feature.properties.id === undefined || feature.properties.id === null)
                    feature.properties.id = Math.floor(Math.random() * 999999);
                feature.properties.label = props.label || props.title || props.name || "Untitled " + feature.geometry.type + " Feature";
                feature.properties.description = props.description || props.desc || "This feature needs a description!";
                feature.properties.style = props.style || style;
                layer.bindTooltip(props.label);
                /*
                                toggle: setLabelNoHide(bool)
                                it may only exist on markers!
                                */
            },
            pointToLayer: function (feature, latlng) {
                /** @type {?} */
                var style = feature.properties.style || {};
                style.radius = style.radius || 4;
                style.weight = style.weight || 2;
                style.color = style.color || '#03f';
                style.opacity = style.opacity || 0.9;
                style.fillOpacity = style.opacity;
                style.fillColor = style.color;
                return circleMarker(latlng, style);
            }
        };
        return _this;
    }
    /**
     * @return {?}
     */
    MapInstance.prototype.dispose = /**
     * @return {?}
     */
    function () {
        this.destroyMap();
        this.svcCache = null;
        this.serviceFactory = null;
        this.httpClient = null;
        this._key = null;
        this._mapId = null;
        this._mapDef = null;
        this._mapInstance = null;
        this._defaultExtent = null;
        this._baseLayerDef = null;
        this._baseLayer = null;
        this._layerStates = null;
        this._layerCache = null;
        this._layerErrors = null;
        this._featureLayer = null;
        this._featureLayerVisible = true;
        this._tools = null;
        this.state = null;
        this._geoJsonLayerOpts = null;
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.getKey = /**
     * @return {?}
     */
    function () {
        return this._key;
    };
    /**
     * Override default (JQuery-based) map service used by this instance
     * @param mapService - service to use to CRUD map objects
     * @deprecated use setServiceFactory instead
     */
    /**
     * Override default (JQuery-based) map service used by this instance
     * @deprecated use setServiceFactory instead
     * @param {?} mapService - service to use to CRUD map objects
     * @return {?}
     */
    MapInstance.prototype.setService = /**
     * Override default (JQuery-based) map service used by this instance
     * @deprecated use setServiceFactory instead
     * @param {?} mapService - service to use to CRUD map objects
     * @return {?}
     */
    function (mapService) {
        // this.mapService = mapService;
    };
    /**
     * @param factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     */
    /**
     * @param {?} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     * @return {?}
     */
    MapInstance.prototype.setServiceFactory = /**
     * @param {?} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     * @return {?}
     */
    function (factory) {
        this.svcCache = {}; //wipe out cached services
        this.serviceFactory = factory;
    };
    /**
     * @param httpClient - HttpClient impl to use with the new factory
     */
    /**
     * @param {?} httpClient - HttpClient impl to use with the new factory
     * @return {?}
     */
    MapInstance.prototype.setHttpClient = /**
     * @param {?} httpClient - HttpClient impl to use with the new factory
     * @return {?}
     */
    function (httpClient) {
        this.svcCache = {}; //wipe out cached services
        this.httpClient = httpClient;
    };
    /**
     * @param type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return item service implementation for the requested type
     */
    /**
     * @param {?} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {?} item service implementation for the requested type
     */
    MapInstance.prototype.getService = /**
     * @param {?} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {?} item service implementation for the requested type
     */
    function (type) {
        if (!this.svcCache[type])
            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);
        return this.svcCache[type];
    };
    /**
     * @param fn - callback when an error is encountered
     */
    /**
     * @param {?} fn - callback when an error is encountered
     * @return {?}
     */
    MapInstance.prototype.setErrorHandler = /**
     * @param {?} fn - callback when an error is encountered
     * @return {?}
     */
    function (fn) {
        this._layerErrorHandler = fn;
    };
    //-----------------
    /**
     * @param {?} layerId
     * @return {?}
     */
    MapInstance.prototype.getLayerStateIndex = /**
     * @param {?} layerId
     * @return {?}
     */
    function (layerId) {
        if (!layerId)
            return -1;
        for (var i = 0; i < this._layerStates.length; ++i) {
            if (this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {
                return i;
            }
        }
        return -1;
        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );
    };
    /**
     * @param {?} layerId
     * @return {?}
     */
    MapInstance.prototype.getLayerState = /**
     * @param {?} layerId
     * @return {?}
     */
    function (layerId) {
        /** @type {?} */
        var index = this.getLayerStateIndex(layerId);
        return index >= 0 ? this._layerStates[index] : null;
    };
    //-----------------
    /**
     * @return {?}
     */
    MapInstance.prototype.initializeMapDefinition = /**
     * @return {?}
     */
    function () {
        return {
            type: ItemTypes.MAP,
            title: "My New Map",
            label: "My New Map",
            description: "This map needs a description",
            createdBy: null,
            baseLayer: this._baseLayerDef,
            layers: [],
            keywords: [],
            themes: [],
            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']
        };
    };
    /**
     * @param metadata object
     * @return object definition of the current map suitable for sending to WMVR
     */
    /**
     * @param {?=} metadata object
     * @return {?} object definition of the current map suitable for sending to WMVR
     */
    MapInstance.prototype.getMapResourceContent = /**
     * @param {?=} metadata object
     * @return {?} object definition of the current map suitable for sending to WMVR
     */
    function (metadata) {
        metadata = metadata || {};
        //map layers
        metadata.layers = this._layerStates.map(function (state) {
            /** @type {?} */
            var result = {
                visibility: state.visibility || true,
                opacity: isNaN(state.opacity) ? 1.0 : state.opacity * 1,
                layer: {
                    id: state.layer.id,
                    uri: state.layer.uri,
                    label: state.layer.label
                }
            };
            return result;
        });
        // ... UAL should support accepting just an id here, so we'll do just that
        metadata.baseLayer = {
            id: this._baseLayerDef.id,
            uri: this._baseLayerDef.uri,
            label: this._baseLayerDef.label
        };
        metadata.annotations = this._featureLayer ?
            { title: "Map Features", geoJSON: this._featureLayer.toGeoJSON() } : null;
        /** @type {?} */
        var extent = this._mapInstance.getBounds();
        metadata.extent = {
            minx: extent.getWest(),
            miny: extent.getSouth(),
            maxx: extent.getEast(),
            maxy: extent.getNorth()
        };
        return metadata;
    };
    /**
     * @return Leaflet toolbar
     */
    /**
     * @return {?} Leaflet toolbar
     */
    MapInstance.prototype.getDrawControlToolbar = /**
     * @return {?} Leaflet toolbar
     */
    function () {
        if (!(/** @type {?} */ (this._mapInstance)).drawControl)
            return null;
        /** @type {?} */
        var toolbars = (/** @type {?} */ (this._mapInstance)).drawControl._toolbars;
        /** @type {?} */
        var toolbar = null;
        for (var key in toolbars) {
            if (toolbars.hasOwnProperty(key)) {
                if (toolbars[key]._modes) {
                    toolbar = toolbars[key];
                    break;
                }
            }
        }
        return toolbar;
    };
    /**
     * @param error Leaflet tile load error (.target is layer, .tile is image)
     */
    /**
     * @param {?} error Leaflet tile load error (.target is layer, .tile is image)
     * @return {?}
     */
    MapInstance.prototype.handleLayerError = /**
     * @param {?} error Leaflet tile load error (.target is layer, .tile is image)
     * @return {?}
     */
    function (error) {
        // console.log("MapInstance.handleLayerError() - " +
        //     "Layer's tile failed to load: " + error.tile.src);
        if (!this._layerCache) {
            console.log("Unable to find layer in layer cache. Layer error is " + error);
            return;
        }
        /** @type {?} */
        var layer = error.target;
        for (var id in this._layerCache) {
            if (this._layerCache[id] === layer) {
                this.processLayerError(error, id);
                break;
            }
        }
    };
    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     */
    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     * @param {?} error
     * @param {?} id
     * @return {?}
     */
    MapInstance.prototype.processLayerError = /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     * @param {?} error
     * @param {?} id
     * @return {?}
     */
    function (error, id) {
        var _this = this;
        /** @type {?} */
        var finder = function (l) { return l.id === id || (l.layer && l.layer.id === id); };
        if (!this._layerErrors.find(finder)) {
            /** @type {?} */
            var obj_1 = this.logLayerError(id, "Layer ('" + id + "') failed to completely load. " +
                "It may be inaccessible or misconfigured.");
            /** @type {?} */
            var url = (/** @type {?} */ (error)).tile.src;
            /** @type {?} */
            var params = { id: id };
            url.substring(url.indexOf("?") + 1, url.length).split('&').forEach(function (param) {
                /** @type {?} */
                var p = param.split('=');
                params[p[0]] = p[1];
            });
            /** @type {?} */
            var layerService = /** @type {?} */ (this.getService(ItemTypes.LAYER));
            if (layerService) {
                layerService.validate(id, params)
                    .catch(function (e) {
                    /** @type {?} */
                    var def = _this._layerStates.find(finder);
                    if (def) {
                        obj_1.message = "Layer '" + def.layer.label + "' failed to completely load. " +
                            "Reported cause: " + e.message;
                    }
                    _this.notify('layer:error', obj_1);
                });
            }
        }
    };
    /**
     * @param layerId - identifier of layer generating the error
     * @param errorMsg - message of the error
     */
    /**
     * @param {?} layerId - identifier of layer generating the error
     * @param {?} errorMsg - message of the error
     * @return {?}
     */
    MapInstance.prototype.logLayerError = /**
     * @param {?} layerId - identifier of layer generating the error
     * @param {?} errorMsg - message of the error
     * @return {?}
     */
    function (layerId, errorMsg) {
        /** @type {?} */
        var err = { id: layerId, message: errorMsg };
        this._layerErrors.push(err);
        if (this._layerErrorHandler) {
            this._layerErrorHandler(err);
        }
        return err;
    };
    /* -- State Management of internal model -- */
    /**
     * @param {?=} event
     * @param {...?} options
     * @return {?}
     */
    MapInstance.prototype.touch = /**
     * @param {?=} event
     * @param {...?} options
     * @return {?}
     */
    function (event) {
        var options = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            options[_i - 1] = arguments[_i];
        }
        this.state.dirty = true;
        if (event) {
            if (arguments.length > 1) {
                this.notify.apply(this, Array.prototype.slice.call(arguments));
            }
            else
                this.notify(event);
            // console.log("Dirtying map for " + event);
        }
        // else console.log("Dirtying map");
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.clean = /**
     * @return {?}
     */
    function () {
        // console.log("Cleaning map");
        this.state.dirty = false;
    };
    /* --------------------------------------- */
    /* ==============================================
        Map manipulation operations
       ============================================== */
    /**
     * @param {?} map
     * @return {?}
     */
    MapInstance.prototype.setMap = /**
     * @param {?} map
     * @return {?}
     */
    function (map) { this._mapInstance = map; };
    /**
     * @return  map instance
     */
    /**
     * @return {?} map instance
     */
    MapInstance.prototype.getMap = /**
     * @return {?} map instance
     */
    function () { return this._mapInstance; };
    /** @return definition of map */
    /**
     * @return {?} definition of map
     */
    MapInstance.prototype.getMapDefinition = /**
     * @return {?} definition of map
     */
    function () { return this._mapDef; };
    /** @return identifier of map */
    /**
     * @return {?} identifier of map
     */
    MapInstance.prototype.getMapId = /**
     * @return {?} identifier of map
     */
    function () { return this._mapId; };
    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param lat number
     * @param lng number
     * @param zoom number (optional)
     */
    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param {?} lat number
     * @param {?} lng number
     * @param {?=} zoom number (optional)
     * @return {?}
     */
    MapInstance.prototype.setView = /**
     * Focuses the map on the specified lat/lng coordinate
     * @param {?} lat number
     * @param {?} lng number
     * @param {?=} zoom number (optional)
     * @return {?}
     */
    function (lat, lng, zoom) {
        /** @type {?} */
        var z = zoom;
        if (typeof (z) === 'undefined')
            z = this._mapInstance.getZoom();
        this._mapInstance.setView([lat, lng], z);
        this.touch('map:view:changed');
    };
    /**
     * Retrieve the current center of the map
     * @return [lat,lng]
     */
    /**
     * Retrieve the current center of the map
     * @return {?} [lat,lng]
     */
    MapInstance.prototype.getView = /**
     * Retrieve the current center of the map
     * @return {?} [lat,lng]
     */
    function () {
        /** @type {?} */
        var latLng = this._mapInstance.getCenter();
        return [latLng.lat, latLng.lng];
    };
    /**
     * @return integer current zoom level of the map
     */
    /**
     * @return {?} integer current zoom level of the map
     */
    MapInstance.prototype.getZoom = /**
     * @return {?} integer current zoom level of the map
     */
    function () {
        return this._mapInstance.getZoom();
    };
    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     */
    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     * @return {?}
     */
    MapInstance.prototype.zoomToDefault = /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     * @return {?}
     */
    function () {
        if (!this._mapInstance)
            return;
        if (this._defaultExtent) {
            this._mapInstance.fitBounds([
                [this._defaultExtent.miny, this._defaultExtent.minx],
                [this._defaultExtent.maxy, this._defaultExtent.maxx]
            ]);
        }
        else {
            console.log("MapInstance.zoomToDefault() - No default extent specified");
            this._mapInstance.setView([38, -96], 5);
        }
        try {
            this.touch('map:view:changed');
        }
        catch (e) { }
    };
    /**
     * @param extent - either a GP extent object or Leaflet LatLngBounds object
     */
    /**
     * @param {?} extent - either a GP extent object or Leaflet LatLngBounds object
     * @return {?}
     */
    MapInstance.prototype.setExtent = /**
     * @param {?} extent - either a GP extent object or Leaflet LatLngBounds object
     * @return {?}
     */
    function (extent) {
        if (!extent)
            return;
        if (typeof (extent.minx) !== 'undefined' &&
            typeof (extent.miny) !== 'undefined' &&
            typeof (extent.maxx) !== 'undefined' &&
            typeof (extent.maxy) !== 'undefined') {
            //GP model extent
            this._mapInstance.fitBounds([
                [extent.miny, extent.minx],
                [extent.maxy, extent.maxx]
            ]);
        }
        else if (typeof (extent.getWest) !== 'undefined') {
            //L.LatLngBounds
            this._mapInstance.fitBounds(extent);
        }
        else {
        }
    };
    /* ==============================================
        Layer operations
       ============================================== */
    /**
     * @param layer Leaflet Layer instance or object definition
     */
    /**
     * @param {?} layer Leaflet Layer instance or object definition
     * @return {?}
     */
    MapInstance.prototype.setBaseLayer = /**
     * @param {?} layer Leaflet Layer instance or object definition
     * @return {?}
     */
    function (layer) {
        var _this = this;
        /** @type {?} */
        var promise = null;
        if (!layer) {
            /** @type {?} */
            var svc = /** @type {?} */ (this.getService(ItemTypes.LAYER));
            promise = DefaultBaseLayer.get(svc);
        }
        else
            promise = Promise.resolve(layer);
        promise.then(function (layer) {
            /** @type {?} */
            var leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                console.log("Warning: MapInstance could not create base " +
                    "layer for '" + layer.id + "'");
                return;
            }
            _this._mapInstance.addLayer(leafletLayer);
            (/** @type {?} */ (leafletLayer)).setZIndex(0);
            /** @type {?} */
            var oldBaseLayer = _this._baseLayer;
            if (oldBaseLayer) {
                _this._mapInstance.removeLayer(oldBaseLayer);
            }
            //remember new base layer
            //remember new base layer
            _this._baseLayer = leafletLayer;
            _this._baseLayerDef = layer;
            //will notify listeners
            //will notify listeners
            _this.touch('baselayer:changed', layer, leafletLayer);
            // this.notify('baselayer:changed', layer, leafletLayer);
        })
            .catch(function (e) {
            console.log("MapInstance.setBaseLayer() - Error getting base layer for map : " + e.message);
            _this.logLayerError(layer.id, "Error setting baselayer on map " +
                "because of the following error(s): " + e.message);
        });
    };
    /**
     * @return array of base layers definitions that can be used
     */
    // getBaseLayerOptions () {
    //     return this._baseLayerOptions;
    // },
    /**
     * @return {?} array of base layers definitions that can be used
     */
    MapInstance.prototype.getBaseLayer = /**
     * @return {?} array of base layers definitions that can be used
     */
    function () { return this._baseLayerDef; };
    /**
     * @return list of layer states containing layer information
     */
    /**
     * @return {?} list of layer states containing layer information
     */
    MapInstance.prototype.getLayers = /**
     * @return {?} list of layer states containing layer information
     */
    function () { return this._layerStates; };
    /**
     * @return {?}
     */
    MapInstance.prototype.getLayerErrors = /**
     * @return {?}
     */
    function () { return this._layerErrors; };
    /**
     * @return {?}
     */
    MapInstance.prototype.clearLayerErrors = /**
     * @return {?}
     */
    function () {
        this._layerErrors = [];
        this.notify('layer:error');
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.clearOverlays = /**
     * @return {?}
     */
    function () {
        if (!this._layerCache)
            return;
        for (var i = this._layerStates.length - 1; i >= 0; --i) {
            /** @type {?} */
            var state = this._layerStates[i];
            /** @type {?} */
            var layerInstance = this._layerCache[state.layer.id];
            if (layerInstance) {
                layerInstance.off("layer:error");
                this._layerCache[state.layer.id] = null;
                this._mapInstance.removeLayer(layerInstance);
            }
        }
        this._layerStates = [];
        this.touch('layers:changed');
        //TODO stop listening for layer events
    };
    /**
     * @param layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     */
    /**
     * @param {?} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     * @return {?}
     */
    MapInstance.prototype.addLayers = /**
     * @param {?} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     * @return {?}
     */
    function (layers) {
        var _this = this;
        if (!this._layerCache) {
            console.log("WARN: attempting to add layers to an empty cache");
            return;
        }
        if (!this._layerCache) {
            console.log("WARN: Attempting to add layers to a map with no layer cache");
            return;
        }
        if (!layers)
            return;
        if (typeof (layers.push) === 'undefined') {
            layers = [layers];
        }
        layers.forEach(function (obj, index) {
            /** @type {?} */
            var layer = null;
            /** @type {?} */
            var state = null;
            if (obj.type && obj.type === ItemTypes.LAYER) { //is a layer
                //is a layer
                layer = obj;
            }
            else if (obj.layer) { //is layer state
                //is layer state
                layer = obj.layer; // containing a layer
                state = obj;
            }
            if (!layer) {
                console.log("MapInstance.addLayers() - layer (" + index +
                    ") is not a Layer or a Layer state. Ignoring...");
                return; //layer info is missing, skip it
            }
            //DT-442 prevent adding layer that already exists on map
            if (_this._layerCache[layer.id])
                return;
            if (!state) {
                try {
                    /** @type {?} */
                    var layerCopy = JSON.parse(JSON.stringify(layer));
                    state = {
                        opacity: 1,
                        visibility: true,
                        layer: layerCopy
                    };
                }
                catch (e) {
                    throw new Error("Unable to add layer to map because of " + e.message);
                }
            }
            /** @type {?} */
            var z = layers.length - index;
            state.zIndex = z;
            _this.addLayerWithState(layer, state);
        });
        this.touch('layers:changed');
    };
    /**
     * @param layer - GeoPlatform Layer instance
     * @param state - GeoPlatform Layer State
     */
    /**
     * @param {?} layer - GeoPlatform Layer instance
     * @param {?} state - GeoPlatform Layer State
     * @return {?}
     */
    MapInstance.prototype.addLayerWithState = /**
     * @param {?} layer - GeoPlatform Layer instance
     * @param {?} state - GeoPlatform Layer State
     * @return {?}
     */
    function (layer, state) {
        var _this = this;
        /** @type {?} */
        var leafletLayer = null;
        try {
            if (!layer || !state)
                throw new Error("Invalid argument, missing layer and or state");
            leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                /** @type {?} */
                var msg = "Could not create leaflet instance for GP Layer '" + layer.id + "'.";
                if (!layer.services || !layer.services.length) {
                    msg += '  The layer instance has no services included, ' +
                        'which will prevent most layers from being displayed.';
                }
                throw new Error(msg);
            }
        }
        catch (e) {
            this.logLayerError(layer.id, "Layer '" + layer.label + "' could not be added to the " +
                "map instance; " + e.message);
        }
        if (!leafletLayer)
            return;
        //cache leaflet object first
        if (this._layerCache)
            this._layerCache[layer.id] = leafletLayer;
        //listen for layer errors so we can inform the user
        // that a layer hasn't been loaded in a useful way
        leafletLayer.on('tileerror', function (e) { _this.handleLayerError(e); });
        this._mapInstance.addLayer(leafletLayer);
        if (!isNaN(state.zIndex) && leafletLayer.setZIndex)
            leafletLayer.setZIndex(state.zIndex);
        this._layerStates.push(state);
        this.notify('layer:added', layer, leafletLayer);
        // if layer is initially "off" or...
        // if layer is initially not 100% opaque
        if (!state.visibility || state.opacity < 1) {
            // initialize layer visibility and opacity async, or else
            // some of the layers won't get properly initialized
            setTimeout(function (layer, state) {
                _this.setLayerVisibility(layer, state.visibility);
                _this.setLayerOpacity(layer, state.opacity);
                //TODO notify of change
                //DT-2102 timeout needs to be large enough or else
                // feature layers won't get opacity updated on map load
            }, 2000, leafletLayer, state);
        }
    };
    /**
     * @param from - position of layer being moved
     * @param to - desired position to move layer to
     */
    /**
     * @param {?} from - position of layer being moved
     * @param {?} to - desired position to move layer to
     * @return {?}
     */
    MapInstance.prototype.moveLayer = /**
     * @param {?} from - position of layer being moved
     * @param {?} to - desired position to move layer to
     * @return {?}
     */
    function (from, to) {
        if (!this._layerCache)
            return;
        if (!this._layerCache)
            return;
        if (isNaN(from))
            return;
        //end of list
        if (isNaN(to))
            to = this._layerStates.length - 1;
        /** @type {?} */
        var copy = this._layerStates.splice(from, 1)[0]; //grab layer being moved
        this._layerStates.splice(to, 0, copy);
        for (var z = 1, i = this._layerStates.length - 1; i >= 0; --i, ++z) {
            /** @type {?} */
            var layerState = this._layerStates[i];
            /** @type {?} */
            var layerInstance = this._layerCache[layerState.layer.id];
            if (layerInstance) {
                layerInstance.setZIndex(z);
                layerState.zIndex = z;
            }
        }
        this.touch('layers:changed', this.getLayers());
    };
    /**
     *
     */
    /**
     *
     * @param {?} id
     * @return {?}
     */
    MapInstance.prototype.removeLayer = /**
     *
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            var index = this.getLayerStateIndex(id);
            // console.log("MapInstance.removeLayer(" + id + ")");
            if (index >= 0 && index < this._layerStates.length)
                this._layerStates.splice(index, 1);
            //stop listening for errors
            layerInstance.off("layer:error");
            //remove layer from map
            this._mapInstance.removeLayer(layerInstance);
            //remove layer from cache
            this._layerCache[id] = null;
        }
        this.touch('layers:changed');
    };
    /**
     *
     */
    /**
     *
     * @param {?} id
     * @return {?}
     */
    MapInstance.prototype.toggleLayerVisibility = /**
     *
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            var state = this.getLayerState(id);
            state.visibility = !state.visibility;
            if (layerInstance._currentImage) {
                //ESRI Image Service layers have an IMG element
                // that gets modified and replaced every map event (zoom/pan)
                // so we can't just toggle classes like on other layers.
                //Instead, we need to use the ESRI setOpacity method to toggle
                // but need to update layer state as well.
                layerInstance.setOpacity(state.visibility ? 1 : 0);
                state.opacity = layerInstance.getOpacity();
                return;
            }
            this.setLayerVisibility(layerInstance, state.visibility);
        }
    };
    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param layerInstance - leaflet layer instance
     * @param visible - flag indicating visibility of layer
     */
    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} visible - flag indicating visibility of layer
     * @return {?}
     */
    MapInstance.prototype.setLayerVisibility = /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} visible - flag indicating visibility of layer
     * @return {?}
     */
    function (layerInstance, visible) {
        if ((/** @type {?} */ (layerInstance)).setVisibility) {
            //using custom method provided in src/layer/module.js
            (/** @type {?} */ (layerInstance)).setVisibility(visible);
        }
        else if ((/** @type {?} */ (layerInstance))._container) {
            /** @type {?} */
            var el = jQuery((/** @type {?} */ (layerInstance))._container);
            // if(visible) el.removeClass("invisible");
            // else el.addClass('invisible');
            el.css({ 'display': visible ? '' : 'none' });
        }
        this.touch('map:layer:changed');
    };
    /**
     *
     */
    /**
     *
     * @param {?} id
     * @param {?} opacity
     * @return {?}
     */
    MapInstance.prototype.updateLayerOpacity = /**
     *
     * @param {?} id
     * @param {?} opacity
     * @return {?}
     */
    function (id, opacity) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        //if layer id is for base layer...
        if (!layerInstance && this._baseLayerDef.id === id) {
            layerInstance = this._baseLayer;
        }
        //adjust rendered leaflet layer
        opacity = this.setLayerOpacity(layerInstance, opacity);
        /** @type {?} */
        var state = this.getLayerState(id);
        if (state)
            state.opacity = opacity;
    };
    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param layerInstance - leaflet layer instance
     * @param opacity - value between 0 and 1.0 or 0 and 100
     * @return normalized opacity value between 0 and 1.0
     */
    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} opacity - value between 0 and 1.0 or 0 and 100
     * @return {?} normalized opacity value between 0 and 1.0
     */
    MapInstance.prototype.setLayerOpacity = /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} opacity - value between 0 and 1.0 or 0 and 100
     * @return {?} normalized opacity value between 0 and 1.0
     */
    function (layerInstance, opacity) {
        if (layerInstance && (/** @type {?} */ (layerInstance)).setOpacity) {
            if (opacity > 1.0)
                opacity = opacity / 100.0;
            (/** @type {?} */ (layerInstance)).setOpacity(opacity);
            this.touch('map:layer:changed');
        }
        return opacity;
    };
    /**
     * @param GeoPlatform Layer instance
     * @return Leaflet layer instance representing that layer or null
     */
    /**
     * @param {?} gpLayer
     * @return {?} Leaflet layer instance representing that layer or null
     */
    MapInstance.prototype.getLeafletLayerFor = /**
     * @param {?} gpLayer
     * @return {?} Leaflet layer instance representing that layer or null
     */
    function (gpLayer) {
        if (!gpLayer || !this._layerCache)
            return null;
        /** @type {?} */
        var leafletLayer = this._layerCache[gpLayer.id];
        return leafletLayer || null;
    };
    /**
     *
     */
    /**
     *
     * @param {?} layerId
     * @return {?}
     */
    MapInstance.prototype.toggleGetFeatureInfo = /**
     *
     * @param {?} layerId
     * @return {?}
     */
    function (layerId) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[layerId];
        if (layerInstance) {
            if (typeof (layerInstance.enableGetFeatureInfo) !== 'undefined') {
                if (layerInstance.isGetFeatureInfoEnabled()) {
                    layerInstance.disableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).removeClass('selectable-cursor');
                }
                else {
                    layerInstance.enableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).addClass('selectable-cursor');
                }
            }
        }
    };
    /* ==============================================
       Feature operations
       ============================================== */
    /**
     * @return array of features on the map
     */
    /**
     * @return {?} array of features on the map
     */
    MapInstance.prototype.getFeatures = /**
     * @return {?} array of features on the map
     */
    function () {
        if (this._featureLayer) {
            /** @type {?} */
            var geojson_1 = this._featureLayer.toGeoJSON();
            return (/** @type {?} */ (geojson_1)).features;
        }
        return [];
    };
    /**
     * @param json geojson object or array of geojson objects
     */
    /**
     * @param {?} json geojson object or array of geojson objects
     * @return {?}
     */
    MapInstance.prototype.addFeatures = /**
     * @param {?} json geojson object or array of geojson objects
     * @return {?}
     */
    function (json) {
        if (!json)
            return;
        if (typeof (json.push) !== 'undefined') {
            //array of features
            for (var i = 0; i < json.length; ++i)
                this.addFeature(json[i], false);
            this.touch('features:changed');
        }
        else if (json.features) {
            this.addFeatures(json.features);
        }
        else { //single feature
            //single feature
            this.addFeature(json, true);
        }
    };
    /**
     * @param json geojson object
     */
    /**
     * @param {?} json geojson object
     * @param {?=} fireEvent
     * @return {?}
     */
    MapInstance.prototype.addFeature = /**
     * @param {?} json geojson object
     * @param {?=} fireEvent
     * @return {?}
     */
    function (json, fireEvent) {
        var _this = this;
        // var type = json.type;
        // var coordinates = json.coordinates;
        if (!this._featureLayer) {
            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);
            this._featureLayer = featureGroup().addTo(this._mapInstance);
        }
        /** @type {?} */
        var opts = jQuery.extend({}, this._geoJsonLayerOpts);
        geoJSON(json, opts).eachLayer(function (l) { return _this.addFeatureLayer(l); });
        if (typeof (fireEvent) === 'undefined' || fireEvent === true)
            this.touch('features:changed');
        else
            this.touch();
        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));
    };
    /**
     * @param featureJson object defining a GeoJSON feature
     */
    /**
     * @param {?} featureJson object defining a GeoJSON feature
     * @return {?}
     */
    MapInstance.prototype.updateFeature = /**
     * @param {?} featureJson object defining a GeoJSON feature
     * @return {?}
     */
    function (featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            (/** @type {?} */ (layer)).feature = featureJson;
            //update style
            layer.setStyle(featureJson.properties.style);
            /** @type {?} */
            var label = featureJson.properties.label ||
                "Untitled " + featureJson.geometry.type + " Feature";
            layer.bindTooltip(label);
            // layer.redraw();
            this.touch("map:feature:changed");
        }
    };
    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param featureJson object defining GeoJSON feature
     */
    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param {?} featureJson object defining GeoJSON feature
     * @return {?}
     */
    MapInstance.prototype.replaceFeature = /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param {?} featureJson object defining GeoJSON feature
     * @return {?}
     */
    function (featureJson) {
        var _this = this;
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            //remove existing
            this._featureLayer.removeLayer(layer);
            //add replacement
            geoJSON(featureJson, this._geoJsonLayerOpts)
                .eachLayer(function (l) { return _this.addFeatureLayer(l); });
            this.touch("map:feature:changed");
        }
    };
    /**
     * @param featureId identifier of feature to focus the map on
     */
    /**
     * @param {?} featureId identifier of feature to focus the map on
     * @return {?}
     */
    MapInstance.prototype.focusFeature = /**
     * @param {?} featureId identifier of feature to focus the map on
     * @return {?}
     */
    function (featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer) {
            if (typeof (layer.getBounds) !== 'undefined') {
                /** @type {?} */
                var extent = layer.getBounds();
                this._mapInstance.fitBounds(extent);
            }
            else if (typeof ((/** @type {?} */ (layer)).getLatLng) !== 'undefined') {
                /** @type {?} */
                var latLng = (/** @type {?} */ (layer)).getLatLng();
                this._mapInstance.panTo(latLng);
            }
            else {
                console.log("MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng");
            }
        }
        else {
            console.log("MapInstance.focusFeature() - Cannot focus feature because it has no layer");
        }
    };
    /**
     * @param featureId : string
     */
    /**
     * @param {?} featureId : string
     * @return {?}
     */
    MapInstance.prototype.removeFeature = /**
     * @param {?} featureId : string
     * @return {?}
     */
    function (featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer && this._featureLayer) {
            this._featureLayer.removeLayer(layer);
            this.touch('features:changed');
        }
    };
    /**
     *
     */
    /**
     *
     * @return {?}
     */
    MapInstance.prototype.removeFeatures = /**
     *
     * @return {?}
     */
    function () {
        if (this._featureLayer) {
            this._featureLayer.clearLayers();
            this.touch("features:changed");
        }
    };
    /**
     *
     */
    /**
     *
     * @param {?=} featureId
     * @return {?}
     */
    MapInstance.prototype.getFeatureLayer = /**
     *
     * @param {?=} featureId
     * @return {?}
     */
    function (featureId) {
        //if no feature was specified, return root feature layer
        if (!featureId)
            return this._featureLayer;
        //otherwise, find feature...
        if (!this._featureLayer)
            return null;
        /** @type {?} */
        var features = this._featureLayer.getLayers();
        for (var i = 0; i < features.length; ++i) {
            if ((/** @type {?} */ (features[i])).feature &&
                (/** @type {?} */ (features[i])).feature.properties.id === featureId) {
                return (/** @type {?} */ (features[i]));
            }
        }
        return null;
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.toggleFeaturesLayer = /**
     * @return {?}
     */
    function () {
        if (!this._featureLayer)
            return false; //ignore if not rendered yet
        this._featureLayerVisible = !this._featureLayerVisible;
        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);
        return this._featureLayerVisible;
    };
    /**
     * @param  feature - Leaflet feature instance
     * @param  visibility - flag
     */
    /**
     * @param {?} feature - Leaflet feature instance
     * @param {?} visibility - flag
     * @return {?}
     */
    MapInstance.prototype.setFeatureVisibility = /**
     * @param {?} feature - Leaflet feature instance
     * @param {?} visibility - flag
     * @return {?}
     */
    function (feature, visibility) {
        this.setFeatureLayerVisibility(feature, visibility);
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.getFeaturesLayerVisibility = /**
     * @return {?}
     */
    function () {
        return this._featureLayerVisible;
    };
    /*
     * method for adding feature layers to the map
     * when these layers may be layer groups.
     * finds leaf node layers and adds them to the
     * map's feature group
     */
    /**
     * @param {?} layer
     * @return {?}
     */
    MapInstance.prototype.addFeatureLayer = /**
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        this._addFeatureLayer(layer);
        this.touch("features:changed");
    };
    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param layer
     */
    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {?} layer
     * @return {?}
     */
    MapInstance.prototype._addFeatureLayer = /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {?} layer
     * @return {?}
     */
    function (layer) {
        var _this = this;
        if (!(/** @type {?} */ (layer)).feature && layer instanceof LayerGroup) {
            layer.eachLayer(function (child) {
                _this._addFeatureLayer(child);
            });
        }
        else {
            this._featureLayer.addLayer(layer);
        }
    };
    //toggle visibility of parent feature layer
    /**
     * @param {?} layer
     * @param {?} visibility
     * @return {?}
     */
    MapInstance.prototype.setFeatureLayerVisibility = /**
     * @param {?} layer
     * @param {?} visibility
     * @return {?}
     */
    function (layer, visibility) {
        var _this = this;
        if (!layer)
            return;
        this._featureLayerVisible = visibility;
        if (layer.getLayers) {
            layer.getLayers().forEach(function (child) {
                _this.setFeatureLayerVisibility(child, visibility);
            });
        }
        else {
            /** @type {?} */
            var container = layer._container || layer._path;
            if (container)
                container.style.display = visibility ? '' : 'none';
        }
    };
    /* ==============================================
       Map lifecycle operations
       ============================================== */
    /**
     * @param metadata
     * @return resolving persisted map
     */
    /**
     * @param {?} metadata
     * @return {?} resolving persisted map
     */
    MapInstance.prototype.save = /**
     * @param {?} metadata
     * @return {?} resolving persisted map
     */
    function (metadata) {
        return this.saveMap(metadata);
    };
    /**
     * @param md object containing metadata properties for map
     */
    /**
     * @param {?} md object containing metadata properties for map
     * @return {?}
     */
    MapInstance.prototype.saveMap = /**
     * @param {?} md object containing metadata properties for map
     * @return {?}
     */
    function (md) {
        var _this = this;
        /** @type {?} */
        var metadata = md || {};
        /** @type {?} */
        var gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';
        metadata.resourceTypes = metadata.resourceTypes || [];
        if (metadata.resourceTypes.indexOf(gpMapType) < 0)
            metadata.resourceTypes.push(gpMapType);
        /** @type {?} */
        var content = this.getMapResourceContent(metadata);
        //ensure the two name properties line up
        if (content.title && content.title !== content.label) {
            content.label = content.title;
        }
        else if (content.label && !content.title) {
            content.title = content.label;
        }
        // console.log("Updating: " + JSON.stringify(map));
        return new Promise(function (resolve, reject) {
            _this.getService(ItemTypes.MAP).save(content)
                .then(function (result) {
                //track new map's info so we can update it with next save
                if (!_this._mapId)
                    _this._mapId = result.id;
                _this._mapDef = result;
                _this._defaultExtent = result.extent;
                _this.clean();
                resolve(result);
            })
                .catch(function (err) {
                console.log("MapCore MapInstance.saveMap() - " +
                    "The requested map could not be saved because: " + err.message);
                /** @type {?} */
                var e = new Error("The requested map could not be saved because of the following error(s): " +
                    err.message);
                reject(e);
            });
        });
    };
    /**
     * Retrieve a map's descriptor from the registry
     * @param mapId identifier of map
     * @return resolving the map object
     */
    /**
     * Retrieve a map's descriptor from the registry
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    MapInstance.prototype.fetchMap = /**
     * Retrieve a map's descriptor from the registry
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    function (mapId) {
        //Having to send cache busting parameter to avoid CORS header cache
        // not sending correct Origin value
        return this.getService(ItemTypes.MAP).get(mapId);
    };
    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param mapId identifier of map
     * @return resolving the map object
     */
    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    MapInstance.prototype.loadMap = /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    function (mapId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.fetchMap(mapId).then(function (map) {
                if (!map) {
                    throw new Error("The requested map ('" + mapId +
                        "') came back null");
                }
                else if (typeof (map) === 'string') {
                    throw new Error("The requested map ('" + mapId +
                        "') came back as a string");
                }
                else if ((/** @type {?} */ (map)).message) {
                    throw new Error("There was an error loading the requested map ('" +
                        mapId + "'): " + (/** @type {?} */ (map)).message);
                }
                //loading a map by its ID, so we need to increment it's view count
                if ('development' !== Config.env) {
                    setTimeout(function (map) {
                        /** @type {?} */
                        var views = map.statistics ? (map.statistics.numViews || 0) : 0;
                        /** @type {?} */
                        var patch = [{ op: 'replace', path: '/statistics/numViews', value: views + 1 }];
                        _this.getService(ItemTypes.MAP).patch(map.id, patch)
                            // this.mapService.patch(map.id, patch)
                            .then(function (updated) { map.statistics = updated.statistics; })
                            .catch(function (e) {
                            console.log("MapInstance.saveMap() - Error updating view " +
                                "count for map ('" + mapId + "'): " + e);
                        });
                    }, 1000, map);
                }
                //load the map into the viewer
                //load the map into the viewer
                _this.loadMapFromObj(map);
                resolve(map);
            })
                .catch(function (err) {
                console.log("MapInstance.loadMap() - " +
                    "The requested map could not be loaded because " + err.message);
                /** @type {?} */
                var e = new Error("The requested map ('" + mapId +
                    "') could not be loaded because of the following error(s): " +
                    err.message);
                reject(e);
            });
        });
    };
    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param map object
     */
    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param {?} map object
     * @return {?}
     */
    MapInstance.prototype.loadMapFromObj = /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param {?} map object
     * @return {?}
     */
    function (map) {
        var _this = this;
        // console.log("Loading Map Object");
        // console.log(map);
        this._mapId = map.id;
        this._mapDef = map;
        map.extent = this.ensureExtent(map.extent);
        //set extent from loaded map
        this._defaultExtent = map.extent;
        /** @type {?} */
        var extent = map.extent;
        //remove existing layers
        this._mapInstance.eachLayer(function (l) {
            _this._mapInstance.removeLayer(l);
        });
        this._layerCache = {};
        this._layerStates = [];
        //set new base layer
        this.setBaseLayer(map.baseLayer);
        //add layers from loaded map
        this.addLayers(map.layers);
        //add features
        if (map.annotations && map.annotations.geoJSON) {
            /** @type {?} */
            var fc = map.annotations.geoJSON;
            if (fc.features)
                this.addFeatures(fc.features);
            else
                this.addFeatures([fc]);
        }
        this._mapInstance.fitBounds([
            [extent.miny, extent.minx],
            [extent.maxy, extent.maxx]
        ]);
        this.clean();
        this.notify('map:loaded', map);
    };
    /**
     * @param extent
     * @return corrected or default extent
     */
    /**
     * @param {?} extent
     * @return {?} corrected or default extent
     */
    MapInstance.prototype.ensureExtent = /**
     * @param {?} extent
     * @return {?} corrected or default extent
     */
    function (extent) {
        /** @type {?} */
        var west = !extent || isNaN(extent.minx) ? -179.0 : extent.minx * 1.0;
        /** @type {?} */
        var east = !extent || isNaN(extent.maxx) ? 179.0 : extent.maxx * 1.0;
        /** @type {?} */
        var south = !extent || isNaN(extent.miny) ? -89.0 : extent.miny * 1.0;
        /** @type {?} */
        var north = !extent || isNaN(extent.maxy) ? 89.0 : extent.maxy * 1.0;
        /** @type {?} */
        var t;
        if (west > east) {
            t = Math.min(west, east);
            east = Math.max(west, east);
            west = t;
        }
        if (south > north) {
            t = Math.min(south, north);
            north = Math.max(south, north);
            south = t;
        }
        //prevent out-of-bounds extents
        if (west < -180.0)
            west = -179.0;
        if (east > 180.0)
            east = 179.0;
        if (south < -90.0)
            south = -89.0;
        if (north > 90.0)
            north = 89.0;
        return { minx: west, miny: south, maxx: east, maxy: north };
    };
    /**
     *
     */
    /**
     *
     * @return {?}
     */
    MapInstance.prototype.destroyMap = /**
     *
     * @return {?}
     */
    function () {
        // console.log("Destroying Map");
        this._mapInstance = null;
        this._layerCache = null;
        this._layerStates = null;
        this._featureLayer = null;
    };
    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     */
    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     * @param {?} mapToUse
     * @return {?}
     */
    MapInstance.prototype.setAsNewMap = /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     * @param {?} mapToUse
     * @return {?}
     */
    function (mapToUse) {
        this._mapId = null;
        this._mapDef = mapToUse || this.initializeMapDefinition();
    };
    /* ==============================================
        Tool operations
       ============================================== */
    /**
     * @param {?} id
     * @param {?} tool
     * @return {?}
     */
    MapInstance.prototype.registerTool = /**
     * @param {?} id
     * @param {?} tool
     * @return {?}
     */
    function (id, tool) {
        this._tools[id] = tool;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    MapInstance.prototype.unregisterTool = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        this._tools[id] = null;
    };
    /**
     * @param {?} id
     * @param {?} finish
     * @return {?}
     */
    MapInstance.prototype.enableTool = /**
     * @param {?} id
     * @param {?} finish
     * @return {?}
     */
    function (id, finish) {
        if (!this._tools[id])
            return false;
        this._tools[id].activate(function () {
            this.notify('tool:disabled', id);
        });
        this.notify('tool:enabled', id);
    };
    /* ----------- MISC ------------ */
    //https://github.com/gsklee/ngStorage
    /**
     * @return {?}
     */
    MapInstance.prototype.cacheMap = /**
     * @return {?}
     */
    function () {
        if (this.state && this.state.dirty) {
            /** @type {?} */
            var map = this.getMapResourceContent();
            //use exploded layer info
            map.layers = this._layerStates.slice(0);
            // $sessionStorage.map = map;
        }
    };
    /**
     * @return {?}
     */
    MapInstance.prototype.restoreMap = /**
     * @return {?}
     */
    function () {
        // if($sessionStorage.map) {
        //     console.log("Restoring cached map");
        //     let map = $sessionStorage.map;
        //     // console.log(JSON.stringify(map));
        //     $sessionStorage.map = null;
        //     this.loadMapFromObj(map);
        // }
    };
    return MapInstance;
}(Listener));
export default MapInstance;
if (false) {
    /** @type {?} */
    MapInstance.prototype.svcCache;
    /** @type {?} */
    MapInstance.prototype.serviceFactory;
    /** @type {?} */
    MapInstance.prototype.httpClient;
    /** @type {?} */
    MapInstance.prototype._key;
    /** @type {?} */
    MapInstance.prototype._mapId;
    /** @type {?} */
    MapInstance.prototype._mapDef;
    /** @type {?} */
    MapInstance.prototype._mapInstance;
    /** @type {?} */
    MapInstance.prototype._defaultExtent;
    /** @type {?} */
    MapInstance.prototype._baseLayerDef;
    /** @type {?} */
    MapInstance.prototype._baseLayer;
    /** @type {?} */
    MapInstance.prototype._layerStates;
    /** @type {?} */
    MapInstance.prototype._layerCache;
    /** @type {?} */
    MapInstance.prototype._layerErrors;
    /** @type {?} */
    MapInstance.prototype._layerErrorHandler;
    /** @type {?} */
    MapInstance.prototype._featureLayer;
    /** @type {?} */
    MapInstance.prototype._featureLayerVisible;
    /** @type {?} */
    MapInstance.prototype._tools;
    /** @type {?} */
    MapInstance.prototype.state;
    /** @type {?} */
    MapInstance.prototype._geoJsonLayerOpts;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdGFuY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ2VvcGxhdGZvcm0vbWFwY29yZS8iLCJzb3VyY2VzIjpbIm1hcC9pbnN0YW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUVBLE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDOztBQUNqQyxJQUFNLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFJdEIsT0FBTyxFQUVILFlBQVksRUFBRSxPQUFPLEVBQ3JCLFlBQVksRUFBZ0IsVUFBVSxFQUN6QyxNQUFNLFNBQVMsQ0FBQztBQUVqQixPQUFPLEVBQ0gsTUFBTSxFQUFFLFNBQVMsRUFDakIsY0FBYyxFQUNkLGFBQWEsRUFDaEIsTUFBTSxxQkFBcUIsQ0FBQztBQUU3QixPQUFPLFlBQVksTUFBTSxrQkFBa0IsQ0FBQztBQUU1QyxPQUFPLGdCQUFnQixNQUFNLDRCQUE0QixDQUFDO0FBRzFELElBQUE7SUFJSTs7UUFFSSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztLQUN4Qjs7Ozs7O0lBRUQscUJBQUU7Ozs7O0lBQUYsVUFBSSxJQUFJLEVBQUUsUUFBUTtRQUNkLElBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztZQUNyQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUN4Qzs7Ozs7O0lBRUQsc0JBQUc7Ozs7O0lBQUgsVUFBSyxJQUFJLEVBQUUsUUFBUTtRQUNmLElBQUcsQ0FBQyxJQUFJO1lBQUUsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7UUFDL0IsSUFBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTztRQUNsQyxJQUFHLENBQUMsUUFBUTtZQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFD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LEtBQUssQ0FBQyxLQUFLLEVBQUU7O1lBQy9CLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDOztZQUV2QyxHQUFHLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDOztTQUUzQztLQUNKOzs7O0lBRUQsZ0NBQVU7OztJQUFWOzs7Ozs7OztLQVFDO3NCQXA1Q0w7RUE0RHlDLFFBQVEsRUEwMUNoRCxDQUFBO0FBMTFDRCwyQkEwMUNDIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbmltcG9ydCAqIGFzIGpxdWVyeSBmcm9tIFwianF1ZXJ5XCI7XG5jb25zdCBqUXVlcnkgPSBqcXVlcnk7XG5cbmltcG9ydCAqIGFzIFEgZnJvbSBcInFcIjtcbmltcG9ydCAqIGFzIGdlb2pzb24gZnJvbSAnZ2VvanNvbic7XG5pbXBvcnQge1xuICAgIE1hcCwgTGF5ZXIsIExhdExuZywgTGF0TG5nQm91bmRzLFxuICAgIGNpcmNsZU1hcmtlciwgZ2VvSlNPTixcbiAgICBmZWF0dXJlR3JvdXAsIEZlYXR1cmVHcm91cCwgTGF5ZXJHcm91cFxufSBmcm9tICdsZWFmbGV0JztcblxuaW1wb3J0IHtcbiAgICBDb25maWcsIEl0ZW1UeXBlcyxcbiAgICBTZXJ2aWNlRmFjdG9yeSwgSXRlbVNlcnZpY2UsIE1hcFNlcnZpY2UsIExheWVyU2VydmljZSxcbiAgICBYSFJIdHRwQ2xpZW50XG59IGZyb20gJ0BnZW9wbGF0Zm9ybS9jbGllbnQnO1xuXG5pbXBvcnQgTGF5ZXJGYWN0b3J5IGZyb20gJy4uL2xheWVyL2ZhY3RvcnknO1xuaW1wb3J0IE9TTSBmcm9tIFwiLi4vbGF5ZXIvb3NtXCI7XG5pbXBvcnQgRGVmYXVsdEJhc2VMYXllciBmcm9tICcuLi9sYXllci9iYXNlbGF5ZXItZGVmYXVsdCc7XG5cblxuY2xhc3MgTGlzdGVuZXIge1xuXG4gICAgX2xpc3RlbmVycyA6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvL2xpc3RlbmVycyB0byBiZSB1bnJlZ2lzdGVyZWQgdXBvbiBkZXN0cm95XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIH1cblxuICAgIG9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZighdGhpcy5fbGlzdGVuZXJzW3R5cGVdKVxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBvZmYgKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmKCF0eXBlKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYoIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSkgcmV0dXJuO1xuICAgICAgICBpZighbGlzdGVuZXIpIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZihpZHggPj0gMClcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub3RpZnkodHlwZSwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZighdGhpcy5fbGlzdGVuZXJzW3R5cGVdKSByZXR1cm47XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLmZvckVhY2goZnVuY3Rpb24obCkgeyBsLmFwcGx5KG51bGwsIGFyZ3MpOyB9KTtcbiAgICB9XG5cbn1cblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcEluc3RhbmNlIGV4dGVuZHMgTGlzdGVuZXIge1xuXG4gICAgcHJpdmF0ZSBzdmNDYWNoZSAgICAgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBzZXJ2aWNlRmFjdG9yeSAgOiBhbnk7XG4gICAgcHJpdmF0ZSBodHRwQ2xpZW50ICAgICAgOiBhbnk7XG4gICAgcHVibGljIF9rZXkgICAgICAgICAgICA6IHN0cmluZztcbiAgICBwcml2YXRlIF9tYXBJZCAgICAgICAgICA6IHN0cmluZztcbiAgICBwcml2YXRlIF9tYXBEZWYgICAgICAgICA6IGFueTtcbiAgICBwcml2YXRlIF9tYXBJbnN0YW5jZSAgICA6IE1hcDtcbiAgICBwcml2YXRlIF9kZWZhdWx0RXh0ZW50ICA6IGFueTtcbiAgICBwcml2YXRlIF9iYXNlTGF5ZXJEZWYgICA6IGFueTtcbiAgICBwcml2YXRlIF9iYXNlTGF5ZXIgICAgICA6IExheWVyO1xuICAgIHByaXZhdGUgX2xheWVyU3RhdGVzICAgIDogYW55O1xuICAgIHByaXZhdGUgX2xheWVyQ2FjaGUgICAgIDogYW55O1xuICAgIHByaXZhdGUgX2xheWVyRXJyb3JzICAgIDogYW55W107XG4gICAgcHJpdmF0ZSBfbGF5ZXJFcnJvckhhbmRsZXIgOiBGdW5jdGlvbjtcbiAgICBwcml2YXRlIF9mZWF0dXJlTGF5ZXIgICA6IEZlYXR1cmVHcm91cDtcbiAgICBwcml2YXRlIF9mZWF0dXJlTGF5ZXJWaXNpYmxlICA6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBfdG9vbHMgICAgICAgICAgOiBhbnlbXTtcbiAgICBwcml2YXRlIHN0YXRlICAgICAgICAgICA6IGFueTtcbiAgICBwcml2YXRlIF9nZW9Kc29uTGF5ZXJPcHRzIDogYW55O1xuXG5cblxuXG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5zZXRIdHRwQ2xpZW50KG5ldyBYSFJIdHRwQ2xpZW50KCkpO1xuICAgICAgICB0aGlzLnNldFNlcnZpY2VGYWN0b3J5KFNlcnZpY2VGYWN0b3J5KTtcblxuICAgICAgICAvL2dlbmVyYXRlIHJhbmRvbSBrZXkgKHNlZSBmYWN0b3J5IGJlbG93KVxuICAgICAgICB0aGlzLl9rZXkgPSBrZXkgfHwgTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkqOTk5OSk7XG5cbiAgICAgICAgLy9yZWdpc3RyeSBpZCBvZiBjdXJyZW50IG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgdGhpcy5fbWFwSWQgPSBudWxsLFxuXG4gICAgICAgIC8vZGVmaW5pdGlvbiBvZiBtYXAgKGllLCBmcm9tIHNlcnZlcilcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gdGhpcy5pbml0aWFsaXplTWFwRGVmaW5pdGlvbigpLFxuXG4gICAgICAgIC8vcHJpbWFyeSBtYXAgaW5zdGFuY2UgKGllLCBsZWFmbGV0KVxuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGwsXG5cbiAgICAgICAgLy9kZWZhdWx0IG1hcCBleHRlbnQgKGlmIG1hcCBkb2Vzbid0IGhhdmUgb25lIGZvciBiZWluZyBzYXZlZClcbiAgICAgICAgdGhpcy5fZGVmYXVsdEV4dGVudCA9IG51bGwsXG5cbiAgICAgICAgLy9jdXJyZW50IGJhc2UgbGF5ZXIgb2JqZWN0IGFuZCBsZWFmbGV0IGluc3RhbmNlXG4gICAgICAgIHRoaXMuX2Jhc2VMYXllckRlZiA9IG51bGwsXG4gICAgICAgIHRoaXMuX2Jhc2VMYXllciA9IG51bGwsXG5cbiAgICAgICAgLy9zZXQgZGVmaW5pdGlvbnMgb2YgbGF5ZXIgc3RhdGVzIChpbmNsdWRpbmcgbGF5ZXIgaW5mbykgb24gbWFwXG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gW10sXG5cbiAgICAgICAgLy9tYXAgbGF5ZXIgZGVmIGlkcyB3aXRoIGxlYWZsZXQgaW5zdGFuY2VzXG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSB7fSxcblxuICAgICAgICAvL2Vycm9ycyBnZW5lcmF0ZWQgYnkgbGF5ZXJzIGxvYWRpbmdcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvcnM9IFtdLFxuICAgICAgICB0aGlzLl9sYXllckVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNYXBJbnN0YW5jZS5kZWZhdWx0TGF5ZXJFcnJvckhhbmRsZXIoKSAtICR7ZS5pZH0gOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvL2xheWVyIHVzZWQgdG8gc3RvcmUgZmVhdHVyZXMgb24gbWFwXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllciA9IG51bGwsXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSB0cnVlLFxuXG4gICAgICAgIC8vc2V0IG9mIHJlZ2lzdGVyZWQgbWFwIHRvb2xzXG4gICAgICAgIHRoaXMuX3Rvb2xzID0gW10sXG5cbiAgICAgICAgLy9zdGF0ZSBtYW5hZ2VtZW50XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IGRpcnR5OiBmYWxzZSB9OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgICB0aGlzLl9nZW9Kc29uTGF5ZXJPcHRzICA9IHtcbiAgICAgICAgICAgIHN0eWxlOiBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgaWYoZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRWFjaEZlYXR1cmU6IGZ1bmN0aW9uKGZlYXR1cmUsIGxheWVyKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB7IHdlaWdodDogMiwgY29sb3I6ICcjMDNmJywgb3BhY2l0eTogMC45LCByYWRpdXM6IDQsIGZpbGxDb2xvcjogJyMwM2YnLCBmaWxsT3BhY2l0eTogMC41IH07XG4gICAgICAgICAgICAgICAgaWYofmZlYXR1cmUuZ2VvbWV0cnkudHlwZS5pbmRleE9mKCdQb2ludCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gMC45O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZlYXR1cmUucHJvcGVydGllcyA9IGZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZihmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IHVuZGVmaW5lZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo5OTk5OTkpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5sYWJlbCA9IHByb3BzLmxhYmVsIHx8IHByb3BzLnRpdGxlIHx8IHByb3BzLm5hbWUgfHwgXCJVbnRpdGxlZCBcIiArIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSArIFwiIEZlYXR1cmVcIjtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuZGVzY3JpcHRpb24gPSBwcm9wcy5kZXNjcmlwdGlvbiB8fCBwcm9wcy5kZXNjIHx8IFwiVGhpcyBmZWF0dXJlIG5lZWRzIGEgZGVzY3JpcHRpb24hXCI7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlID0gcHJvcHMuc3R5bGUgfHwgc3R5bGU7XG5cbiAgICAgICAgICAgICAgICBsYXllci5iaW5kVG9vbHRpcChwcm9wcy5sYWJlbCk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICB0b2dnbGU6IHNldExhYmVsTm9IaWRlKGJvb2wpXG4gICAgICAgICAgICAgICAgaXQgbWF5IG9ubHkgZXhpc3Qgb24gbWFya2VycyFcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvaW50VG9MYXllcjogZnVuY3Rpb24gKGZlYXR1cmUgOiBhbnksIGxhdGxuZyA6IExhdExuZyApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGUgfHwge307XG4gICAgICAgICAgICAgICAgc3R5bGUucmFkaXVzID0gc3R5bGUucmFkaXVzIHx8IDQ7XG4gICAgICAgICAgICAgICAgc3R5bGUud2VpZ2h0ID0gc3R5bGUud2VpZ2h0IHx8IDI7XG4gICAgICAgICAgICAgICAgc3R5bGUuY29sb3IgPSBzdHlsZS5jb2xvciB8fCAnIzAzZic7XG4gICAgICAgICAgICAgICAgc3R5bGUub3BhY2l0eSA9IHN0eWxlLm9wYWNpdHkgfHwgMC45O1xuICAgICAgICAgICAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgICAgICBzdHlsZS5maWxsQ29sb3IgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lyY2xlTWFya2VyKGxhdGxuZywgc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGRpc3Bvc2UgKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lNYXAoKTtcbiAgICAgICAgdGhpcy5zdmNDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmljZUZhY3RvcnkgPSBudWxsO1xuICAgICAgICB0aGlzLmh0dHBDbGllbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9rZXkgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXBJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcERlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEV4dGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Jhc2VMYXllckRlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Jhc2VMYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JzPSBudWxsO1xuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdG9vbHMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZ2VvSnNvbkxheWVyT3B0cyA9IG51bGw7XG4gICAgfVxuXG5cbiAgICBnZXRLZXkgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGRlZmF1bHQgKEpRdWVyeS1iYXNlZCkgbWFwIHNlcnZpY2UgdXNlZCBieSB0aGlzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG1hcFNlcnZpY2UgLSBzZXJ2aWNlIHRvIHVzZSB0byBDUlVEIG1hcCBvYmplY3RzXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIHNldFNlcnZpY2VGYWN0b3J5IGluc3RlYWRcbiAgICAgKi9cbiAgICBzZXRTZXJ2aWNlKG1hcFNlcnZpY2UgOiBNYXBTZXJ2aWNlKSB7XG4gICAgICAgIC8vIHRoaXMubWFwU2VydmljZSA9IG1hcFNlcnZpY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZhY3RvcnkgLSBHZW9QbGF0Zm9ybSBTZXJ2aWNlRmFjdG9yeSB0byBpbnN0YW50aWF0ZSBzZXJ2aWNlcyBmb3IgbWFwcyBhbmQgbGF5ZXJzXG4gICAgICovXG4gICAgc2V0U2VydmljZUZhY3RvcnkoZmFjdG9yeSA6IGFueSkge1xuICAgICAgICB0aGlzLnN2Y0NhY2hlID0ge307IC8vd2lwZSBvdXQgY2FjaGVkIHNlcnZpY2VzXG4gICAgICAgIHRoaXMuc2VydmljZUZhY3RvcnkgPSBmYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBodHRwQ2xpZW50IC0gSHR0cENsaWVudCBpbXBsIHRvIHVzZSB3aXRoIHRoZSBuZXcgZmFjdG9yeVxuICAgICAqL1xuICAgIHNldEh0dHBDbGllbnQoaHR0cENsaWVudCA6IGFueSkge1xuICAgICAgICB0aGlzLnN2Y0NhY2hlID0ge307IC8vd2lwZSBvdXQgY2FjaGVkIHNlcnZpY2VzXG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IGh0dHBDbGllbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHR5cGUgLSBHZW9QbGF0Zm9ybSBPYmplY3QgbW9kZWwgdHlwZSB0byBzdXBwb3J0IChcIk1hcFwiLCBcIkxheWVyXCIsIGV0YylcbiAgICAgKiBAcmV0dXJuIGl0ZW0gc2VydmljZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCB0eXBlXG4gICAgICovXG4gICAgZ2V0U2VydmljZSh0eXBlIDogc3RyaW5nKSA6IEl0ZW1TZXJ2aWNlIHtcbiAgICAgICAgaWYoIXRoaXMuc3ZjQ2FjaGVbdHlwZV0pXG4gICAgICAgICAgICB0aGlzLnN2Y0NhY2hlW3R5cGVdID0gdGhpcy5zZXJ2aWNlRmFjdG9yeSh0eXBlLCBDb25maWcudWFsVXJsLCB0aGlzLmh0dHBDbGllbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdmNDYWNoZVt0eXBlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZm4gLSBjYWxsYmFjayB3aGVuIGFuIGVycm9yIGlzIGVuY291bnRlcmVkXG4gICAgICovXG4gICAgc2V0RXJyb3JIYW5kbGVyKGZuKSB7XG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JIYW5kbGVyID0gZm47XG4gICAgfVxuXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0TGF5ZXJTdGF0ZUluZGV4IChsYXllcklkKSB7XG4gICAgICAgIGlmKCFsYXllcklkKSByZXR1cm4gLTE7XG4gICAgICAgIGZvcihsZXQgaT0wOyBpPHRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZih0aGlzLl9sYXllclN0YXRlc1tpXS5sYXllciAmJiBsYXllcklkID09PSB0aGlzLl9sYXllclN0YXRlc1tpXS5sYXllci5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMuX2xheWVyU3RhdGVzLmluZGV4T2ZPYmoobGF5ZXJJZCwgKGlkLCBzdGF0ZSkgPT4gc3RhdGUubGF5ZXIuaWQgPT09IGlkICk7XG4gICAgfVxuXG4gICAgZ2V0TGF5ZXJTdGF0ZSAobGF5ZXJJZCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldExheWVyU3RhdGVJbmRleChsYXllcklkKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyB0aGlzLl9sYXllclN0YXRlc1tpbmRleF0gOiBudWxsO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgIGluaXRpYWxpemVNYXBEZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogSXRlbVR5cGVzLk1BUCxcbiAgICAgICAgICAgIHRpdGxlOiBcIk15IE5ldyBNYXBcIixcbiAgICAgICAgICAgIGxhYmVsOiBcIk15IE5ldyBNYXBcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgbWFwIG5lZWRzIGEgZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGNyZWF0ZWRCeTogbnVsbCxcbiAgICAgICAgICAgIGJhc2VMYXllcjogdGhpcy5fYmFzZUxheWVyRGVmLFxuICAgICAgICAgICAgbGF5ZXJzOiBbXSxcbiAgICAgICAgICAgIGtleXdvcmRzOiBbXSxcbiAgICAgICAgICAgIHRoZW1lczogW10sXG4gICAgICAgICAgICByZXNvdXJjZVR5cGVzOiBbJ2h0dHA6Ly93d3cuZ2VvcGxhdGZvcm0uZ292L29udC9vcGVubWFwL0dlb3BsYXRmb3JtTWFwJ11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHJldHVybiBvYmplY3QgZGVmaW5pdGlvbiBvZiB0aGUgY3VycmVudCBtYXAgc3VpdGFibGUgZm9yIHNlbmRpbmcgdG8gV01WUlxuICAgICAqL1xuICAgIGdldE1hcFJlc291cmNlQ29udGVudChtZXRhZGF0YSA/OiBhbnkpIHtcblxuICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhIHx8IHt9O1xuXG4gICAgICAgIC8vbWFwIGxheWVyc1xuICAgICAgICBtZXRhZGF0YS5sYXllcnMgPSB0aGlzLl9sYXllclN0YXRlcy5tYXAoc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5IDogc3RhdGUudmlzaWJpbGl0eSB8fCB0cnVlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHkgOiBpc05hTihzdGF0ZS5vcGFjaXR5KSA/IDEuMCA6IHN0YXRlLm9wYWNpdHkqMSxcbiAgICAgICAgICAgICAgICBsYXllcjoge1xuICAgICAgICAgICAgICAgICAgICBpZDogc3RhdGUubGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIHVyaTogc3RhdGUubGF5ZXIudXJpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogc3RhdGUubGF5ZXIubGFiZWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC4uLiBVQUwgc2hvdWxkIHN1cHBvcnQgYWNjZXB0aW5nIGp1c3QgYW4gaWQgaGVyZSwgc28gd2UnbGwgZG8ganVzdCB0aGF0XG4gICAgICAgIG1ldGFkYXRhLmJhc2VMYXllciA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9iYXNlTGF5ZXJEZWYuaWQsXG4gICAgICAgICAgICB1cmk6IHRoaXMuX2Jhc2VMYXllckRlZi51cmksXG4gICAgICAgICAgICBsYWJlbDogdGhpcy5fYmFzZUxheWVyRGVmLmxhYmVsXG4gICAgICAgIH07XG5cbiAgICAgICAgbWV0YWRhdGEuYW5ub3RhdGlvbnMgPSB0aGlzLl9mZWF0dXJlTGF5ZXIgP1xuICAgICAgICAgICAgeyB0aXRsZTogXCJNYXAgRmVhdHVyZXNcIiwgZ2VvSlNPTjogdGhpcy5fZmVhdHVyZUxheWVyLnRvR2VvSlNPTigpIH0gOiBudWxsO1xuXG4gICAgICAgIC8vZ2VvZ3JhcGhpYyBleHRlbnRcbiAgICAgICAgbGV0IGV4dGVudCA9IHRoaXMuX21hcEluc3RhbmNlLmdldEJvdW5kcygpO1xuICAgICAgICBtZXRhZGF0YS5leHRlbnQgPSB7XG4gICAgICAgICAgICBtaW54OiBleHRlbnQuZ2V0V2VzdCgpLFxuICAgICAgICAgICAgbWlueTogZXh0ZW50LmdldFNvdXRoKCksXG4gICAgICAgICAgICBtYXh4OiBleHRlbnQuZ2V0RWFzdCgpLFxuICAgICAgICAgICAgbWF4eTogZXh0ZW50LmdldE5vcnRoKClcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBMZWFmbGV0IHRvb2xiYXJcbiAgICAgKi9cbiAgICBnZXREcmF3Q29udHJvbFRvb2xiYXIoKSB7XG4gICAgICAgIGlmKCEodGhpcy5fbWFwSW5zdGFuY2UgYXMgYW55KS5kcmF3Q29udHJvbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciB0b29sYmFycyA9ICh0aGlzLl9tYXBJbnN0YW5jZSBhcyBhbnkpLmRyYXdDb250cm9sLl90b29sYmFycztcbiAgICAgICAgdmFyIHRvb2xiYXIgPSBudWxsO1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0b29sYmFycykge1xuICAgICAgICAgICAgaWYodG9vbGJhcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmKHRvb2xiYXJzW2tleV0uX21vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXIgPSB0b29sYmFyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvb2xiYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGVycm9yIExlYWZsZXQgdGlsZSBsb2FkIGVycm9yICgudGFyZ2V0IGlzIGxheWVyLCAudGlsZSBpcyBpbWFnZSlcbiAgICAgKi9cbiAgICBoYW5kbGVMYXllckVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UuaGFuZGxlTGF5ZXJFcnJvcigpIC0gXCIgK1xuICAgICAgICAvLyAgICAgXCJMYXllcidzIHRpbGUgZmFpbGVkIHRvIGxvYWQ6IFwiICsgZXJyb3IudGlsZS5zcmMpO1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmFibGUgdG8gZmluZCBsYXllciBpbiBsYXllciBjYWNoZS4gTGF5ZXIgZXJyb3IgaXMgXCIgKyBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheWVyID0gZXJyb3IudGFyZ2V0O1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuX2xheWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuX2xheWVyQ2FjaGVbaWRdID09PSBsYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xheWVyRXJyb3IoZXJyb3IsIGlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgTGVhZmxldCB0aWxlIGxvYWQgZXJyb3IgYW5kIHRoZSByZXNwb25zaWJsZSBsYXllciBpZCxcbiAgICAgKiBUcnkgdG8gaXNvbGF0ZSB0aGUgY2F1c2Ugb2YgdGhlIGVycm9yIHVzaW5nIHRoZSBwcm94eVxuICAgICAqIGFuZCBub3RpZnkgbGlzdGVuZXJzIHRoYXQgYW4gZXJyb3IgaGFzIG9jY3VycmVkXG4gICAgICovXG4gICAgcHJvY2Vzc0xheWVyRXJyb3IoZXJyb3IgOiBFcnJvciwgaWQgOiBzdHJpbmcpIHtcblxuICAgICAgICB2YXIgZmluZGVyID0gKGwpID0+IHsgcmV0dXJuIGwuaWQgPT09IGlkIHx8IChsLmxheWVyICYmIGwubGF5ZXIuaWQgPT09IGlkKTsgfTtcblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJFcnJvcnMuZmluZChmaW5kZXIpKSB7XG5cbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLmxvZ0xheWVyRXJyb3IoaWQsIFwiTGF5ZXIgKCdcIiArIGlkICsgXCInKSBmYWlsZWQgdG8gY29tcGxldGVseSBsb2FkLiBcIiArXG4gICAgICAgICAgICAgICAgXCJJdCBtYXkgYmUgaW5hY2Nlc3NpYmxlIG9yIG1pc2NvbmZpZ3VyZWQuXCIpO1xuXG4gICAgICAgICAgICB2YXIgdXJsID0gKGVycm9yIGFzIGFueSkudGlsZS5zcmM7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge2lkOmlkfTtcbiAgICAgICAgICAgIHVybC5zdWJzdHJpbmcodXJsLmluZGV4T2YoXCI/XCIpKzEsIHVybC5sZW5ndGgpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcGFyYW0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICBwYXJhbXNbcFswXV0gPSBwWzFdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxldCBsYXllclNlcnZpY2UgPSB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLkxBWUVSKSBhcyBMYXllclNlcnZpY2U7XG4gICAgICAgICAgICBpZihsYXllclNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICBsYXllclNlcnZpY2UudmFsaWRhdGUoaWQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSB0aGlzLl9sYXllclN0YXRlcy5maW5kKGZpbmRlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm1lc3NhZ2UgPSBcIkxheWVyICdcIiArIGRlZi5sYXllci5sYWJlbCArIFwiJyBmYWlsZWQgdG8gY29tcGxldGVseSBsb2FkLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVwb3J0ZWQgY2F1c2U6IFwiICsgZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KCdsYXllcjplcnJvcicsIG9iaik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXJJZCAtIGlkZW50aWZpZXIgb2YgbGF5ZXIgZ2VuZXJhdGluZyB0aGUgZXJyb3JcbiAgICAgKiBAcGFyYW0gZXJyb3JNc2cgLSBtZXNzYWdlIG9mIHRoZSBlcnJvclxuICAgICAqL1xuICAgIGxvZ0xheWVyRXJyb3IobGF5ZXJJZCwgZXJyb3JNc2cpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5sb2dMYXllckVycm9yKCkgLSBsYXllciBcIiAgKyBpZCArXG4gICAgICAgIC8vICAgICBcIiBnZW5lcmF0ZWQgZXJyb3IgJ1wiICsgZXJyb3JNc2cgKyBcIidcIik7XG4gICAgICAgIGxldCBlcnIgPSB7IGlkOiBsYXllcklkLCBtZXNzYWdlOiBlcnJvck1zZyB9O1xuICAgICAgICB0aGlzLl9sYXllckVycm9ycy5wdXNoKGVycik7XG4gICAgICAgIGlmKHRoaXMuX2xheWVyRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllckVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgLyogLS0gU3RhdGUgTWFuYWdlbWVudCBvZiBpbnRlcm5hbCBtb2RlbCAtLSAqL1xuXG4gICAgdG91Y2ggKGV2ZW50ID86IGFueSwgLi4ub3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0YXRlLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShldmVudCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkRpcnR5aW5nIG1hcCBmb3IgXCIgKyBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBjb25zb2xlLmxvZyhcIkRpcnR5aW5nIG1hcFwiKTtcbiAgICB9XG4gICAgY2xlYW4oKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQ2xlYW5pbmcgbWFwXCIpO1xuICAgICAgICB0aGlzLnN0YXRlLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBNYXAgbWFuaXB1bGF0aW9uIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICBzZXRNYXAgKG1hcCA6IE1hcCkgeyB0aGlzLl9tYXBJbnN0YW5jZSA9IG1hcDsgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiAgbWFwIGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0TWFwICgpIDogTWFwIHsgcmV0dXJuIHRoaXMuX21hcEluc3RhbmNlOyB9XG5cbiAgICAvKiogQHJldHVybiBkZWZpbml0aW9uIG9mIG1hcCAqL1xuICAgIGdldE1hcERlZmluaXRpb24gKCkgOiBhbnkgeyByZXR1cm4gdGhpcy5fbWFwRGVmOyB9XG5cbiAgICAvKiogQHJldHVybiBpZGVudGlmaWVyIG9mIG1hcCAqL1xuICAgIGdldE1hcElkICgpIDogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX21hcElkOyB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBtYXAgb24gdGhlIHNwZWNpZmllZCBsYXQvbG5nIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0gbGF0IG51bWJlclxuICAgICAqIEBwYXJhbSBsbmcgbnVtYmVyXG4gICAgICogQHBhcmFtIHpvb20gbnVtYmVyIChvcHRpb25hbClcbiAgICAgKi9cbiAgICBzZXRWaWV3IChsYXQgOiBudW1iZXIsIGxuZyA6IG51bWJlciwgem9vbSA/OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHogPSB6b29tO1xuICAgICAgICBpZih0eXBlb2YoeikgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgeiA9IHRoaXMuX21hcEluc3RhbmNlLmdldFpvb20oKTtcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2Uuc2V0VmlldyhbbGF0LGxuZ10sIHopO1xuICAgICAgICB0aGlzLnRvdWNoKCdtYXA6dmlldzpjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHRoZSBtYXBcbiAgICAgKiBAcmV0dXJuIFtsYXQsbG5nXVxuICAgICAqL1xuICAgIGdldFZpZXcgKCkgOiBudW1iZXJbXSB7XG4gICAgICAgIHZhciBsYXRMbmcgPSB0aGlzLl9tYXBJbnN0YW5jZS5nZXRDZW50ZXIoKTtcbiAgICAgICAgcmV0dXJuIFtsYXRMbmcubGF0LCBsYXRMbmcubG5nXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGludGVnZXIgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXBcbiAgICAgKi9cbiAgICBnZXRab29tICgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcEluc3RhbmNlLmdldFpvb20oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBab29tIHRvIHRoZSBtYXAncyBkZWZhdWx0IGV4dGVudFxuICAgICAqIElmIHRoZSBtYXAgaXMgc2F2ZWQsIHRoaXMgd2lsbCBiZSB0aGUgc2F2ZWQgdmlld3BvcnRcbiAgICAgKiBvdGhlcndpc2UsIGl0IHdpbGwgYmUgQ09OVVNcbiAgICAgKi9cbiAgICB6b29tVG9EZWZhdWx0ICgpIHtcbiAgICAgICAgaWYoIXRoaXMuX21hcEluc3RhbmNlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuX2RlZmF1bHRFeHRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhbXG4gICAgICAgICAgICAgICAgW3RoaXMuX2RlZmF1bHRFeHRlbnQubWlueSwgdGhpcy5fZGVmYXVsdEV4dGVudC5taW54XSxcbiAgICAgICAgICAgICAgICBbdGhpcy5fZGVmYXVsdEV4dGVudC5tYXh5LCB0aGlzLl9kZWZhdWx0RXh0ZW50Lm1heHhdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2Uuem9vbVRvRGVmYXVsdCgpIC0gTm8gZGVmYXVsdCBleHRlbnQgc3BlY2lmaWVkXCIpO1xuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2Uuc2V0VmlldyhbMzgsIC05Nl0sIDUpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdtYXA6dmlldzpjaGFuZ2VkJyk7XG4gICAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV4dGVudCAtIGVpdGhlciBhIEdQIGV4dGVudCBvYmplY3Qgb3IgTGVhZmxldCBMYXRMbmdCb3VuZHMgb2JqZWN0XG4gICAgICovXG4gICAgc2V0RXh0ZW50KGV4dGVudCA6IExhdExuZ0JvdW5kc3xhbnkpIHtcbiAgICAgICAgaWYoIWV4dGVudCkgcmV0dXJuO1xuICAgICAgICBpZiggdHlwZW9mKGV4dGVudC5taW54KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZihleHRlbnQubWlueSkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YoZXh0ZW50Lm1heHgpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mKGV4dGVudC5tYXh5KSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICAvL0dQIG1vZGVsIGV4dGVudFxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKFtcbiAgICAgICAgICAgICAgICBbZXh0ZW50Lm1pbnksIGV4dGVudC5taW54XSxcbiAgICAgICAgICAgICAgICBbZXh0ZW50Lm1heHksIGV4dGVudC5tYXh4XVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YoZXh0ZW50LmdldFdlc3QpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy9MLkxhdExuZ0JvdW5kc1xuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKGV4dGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBMYXllciBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXIgTGVhZmxldCBMYXllciBpbnN0YW5jZSBvciBvYmplY3QgZGVmaW5pdGlvblxuICAgICAqL1xuICAgIHNldEJhc2VMYXllciAobGF5ZXIgOiBhbnkpIHtcblxuICAgICAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGlmKCFsYXllcikge1xuICAgICAgICAgICAgbGV0IHN2YyA9IHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTEFZRVIpIGFzIExheWVyU2VydmljZTtcbiAgICAgICAgICAgIHByb21pc2UgPSBEZWZhdWx0QmFzZUxheWVyLmdldChzdmMpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobGF5ZXIpO1xuXG4gICAgICAgIHByb21pc2UudGhlbiggbGF5ZXIgPT4ge1xuXG4gICAgICAgICAgICBsZXQgbGVhZmxldExheWVyID0gTGF5ZXJGYWN0b3J5LmNyZWF0ZShsYXllcik7XG4gICAgICAgICAgICBpZighbGVhZmxldExheWVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiBNYXBJbnN0YW5jZSBjb3VsZCBub3QgY3JlYXRlIGJhc2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImxheWVyIGZvciAnXCIgKyBsYXllci5pZCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmFkZExheWVyKGxlYWZsZXRMYXllcik7XG5cbiAgICAgICAgICAgIChsZWFmbGV0TGF5ZXIgYXMgYW55KS5zZXRaSW5kZXgoMCk7ICAvL3NldCBhdCBib3R0b21cblxuICAgICAgICAgICAgbGV0IG9sZEJhc2VMYXllciA9IHRoaXMuX2Jhc2VMYXllcjtcbiAgICAgICAgICAgIGlmKG9sZEJhc2VMYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnJlbW92ZUxheWVyKG9sZEJhc2VMYXllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vcmVtZW1iZXIgbmV3IGJhc2UgbGF5ZXJcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VMYXllciA9IGxlYWZsZXRMYXllcjtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VMYXllckRlZiA9IGxheWVyO1xuXG4gICAgICAgICAgICAvL3dpbGwgbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnYmFzZWxheWVyOmNoYW5nZWQnLCBsYXllciwgbGVhZmxldExheWVyKTtcbiAgICAgICAgICAgIC8vIHRoaXMubm90aWZ5KCdiYXNlbGF5ZXI6Y2hhbmdlZCcsIGxheWVyLCBsZWFmbGV0TGF5ZXIpO1xuXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNYXBJbnN0YW5jZS5zZXRCYXNlTGF5ZXIoKSAtIEVycm9yIGdldHRpbmcgYmFzZSBsYXllciBmb3IgbWFwIDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB0aGlzLmxvZ0xheWVyRXJyb3IoIGxheWVyLmlkLCBcIkVycm9yIHNldHRpbmcgYmFzZWxheWVyIG9uIG1hcCBcIiArXG4gICAgICAgICAgICAgICAgXCJiZWNhdXNlIG9mIHRoZSBmb2xsb3dpbmcgZXJyb3Iocyk6IFwiICsgZS5tZXNzYWdlICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gYXJyYXkgb2YgYmFzZSBsYXllcnMgZGVmaW5pdGlvbnMgdGhhdCBjYW4gYmUgdXNlZFxuICAgICAqL1xuICAgIC8vIGdldEJhc2VMYXllck9wdGlvbnMgKCkge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5fYmFzZUxheWVyT3B0aW9ucztcbiAgICAvLyB9LFxuXG4gICAgZ2V0QmFzZUxheWVyICgpIDogYW55IHsgcmV0dXJuIHRoaXMuX2Jhc2VMYXllckRlZjsgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBsaXN0IG9mIGxheWVyIHN0YXRlcyBjb250YWluaW5nIGxheWVyIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgZ2V0TGF5ZXJzICgpIDogYW55W10geyByZXR1cm4gdGhpcy5fbGF5ZXJTdGF0ZXM7IH1cblxuICAgIGdldExheWVyRXJyb3JzICgpIDogYW55W10geyByZXR1cm4gdGhpcy5fbGF5ZXJFcnJvcnM7IH1cblxuICAgIGNsZWFyTGF5ZXJFcnJvcnMgKCkge1xuICAgICAgICB0aGlzLl9sYXllckVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGF5ZXI6ZXJyb3InKTtcbiAgICB9XG5cbiAgICBjbGVhck92ZXJsYXlzICgpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgZm9yKHZhciBpPXRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aC0xOyBpPj0wOyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2xheWVyU3RhdGVzW2ldO1xuICAgICAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW3N0YXRlLmxheWVyLmlkXTtcbiAgICAgICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLm9mZihcImxheWVyOmVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyQ2FjaGVbc3RhdGUubGF5ZXIuaWRdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihsYXllckluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnRvdWNoKCdsYXllcnM6Y2hhbmdlZCcpO1xuXG4gICAgICAgIC8vVE9ETyBzdG9wIGxpc3RlbmluZyBmb3IgbGF5ZXIgZXZlbnRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxheWVycyAtIGxpc3Qgb2YgbGF5ZXJzIChOT1RFOiBub3Qgd3JhcHBlZCBieSBsYXllciBzdGF0ZXMsIHRoaXMgbWV0aG9kIGFwcGxpZXMgdGhhdClcbiAgICAgKi9cbiAgICBhZGRMYXllcnMgKGxheWVycyA6IGFueXxhbnlbXSApIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTjogYXR0ZW1wdGluZyB0byBhZGQgbGF5ZXJzIHRvIGFuIGVtcHR5IGNhY2hlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTjogQXR0ZW1wdGluZyB0byBhZGQgbGF5ZXJzIHRvIGEgbWFwIHdpdGggbm8gbGF5ZXIgY2FjaGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZighbGF5ZXJzKSByZXR1cm47XG4gICAgICAgIGlmKHR5cGVvZihsYXllcnMucHVzaCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsYXllcnMgPSBbbGF5ZXJzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheWVycy5mb3JFYWNoKCAob2JqLGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBsYXllciA9IG51bGwsIHN0YXRlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYob2JqLnR5cGUgJiYgb2JqLnR5cGU9PT1JdGVtVHlwZXMuTEFZRVIpIHsgLy9pcyBhIGxheWVyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBvYmo7XG4gICAgICAgICAgICB9IGVsc2UgaWYob2JqLmxheWVyKSB7ICAvL2lzIGxheWVyIHN0YXRlXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBvYmoubGF5ZXI7ICAvLyBjb250YWluaW5nIGEgbGF5ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IG9iajtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWxheWVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5hZGRMYXllcnMoKSAtIGxheWVyIChcIiArIGluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIGlzIG5vdCBhIExheWVyIG9yIGEgTGF5ZXIgc3RhdGUuIElnbm9yaW5nLi4uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgIC8vbGF5ZXIgaW5mbyBpcyBtaXNzaW5nLCBza2lwIGl0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vRFQtNDQyIHByZXZlbnQgYWRkaW5nIGxheWVyIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gbWFwXG4gICAgICAgICAgICBpZih0aGlzLl9sYXllckNhY2hlW2xheWVyLmlkXSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZighc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvL3dyYXBwZWQgaW4gdHJ5e31jYXRjaCBiZWNhdXNlIGxheWVyIG1heSBjb250YWluIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3aWxsIGNhdXNlIGVycm9yIHdoZW4gdXNlZCBieSBKU09OIG1ldGhvZHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheWVyQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobGF5ZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllckNvcHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGFkZCBsYXllciB0byBtYXAgYmVjYXVzZSBvZiBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeiA9IGxheWVycy5sZW5ndGggLSBpbmRleDtcbiAgICAgICAgICAgIHN0YXRlLnpJbmRleCA9IHo7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkTGF5ZXJXaXRoU3RhdGUobGF5ZXIsIHN0YXRlKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRvdWNoKCdsYXllcnM6Y2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsYXllciAtIEdlb1BsYXRmb3JtIExheWVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHN0YXRlIC0gR2VvUGxhdGZvcm0gTGF5ZXIgU3RhdGVcbiAgICAgKi9cbiAgICBhZGRMYXllcldpdGhTdGF0ZShsYXllciwgc3RhdGUpIHtcblxuICAgICAgICB2YXIgbGVhZmxldExheWVyID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmKCFsYXllciB8fCAhc3RhdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCwgbWlzc2luZyBsYXllciBhbmQgb3Igc3RhdGVcIik7XG5cbiAgICAgICAgICAgIGxlYWZsZXRMYXllciA9IExheWVyRmFjdG9yeS5jcmVhdGUobGF5ZXIpO1xuICAgICAgICAgICAgaWYoIWxlYWZsZXRMYXllcikge1xuICAgICAgICAgICAgICAgIGxldCBtc2cgPSBcIkNvdWxkIG5vdCBjcmVhdGUgbGVhZmxldCBpbnN0YW5jZSBmb3IgR1AgTGF5ZXIgJ1wiICsgbGF5ZXIuaWQgKyBcIicuXCI7XG4gICAgICAgICAgICAgICAgaWYoIWxheWVyLnNlcnZpY2VzIHx8ICFsYXllci5zZXJ2aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9ICcgIFRoZSBsYXllciBpbnN0YW5jZSBoYXMgbm8gc2VydmljZXMgaW5jbHVkZWQsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3doaWNoIHdpbGwgcHJldmVudCBtb3N0IGxheWVycyBmcm9tIGJlaW5nIGRpc3BsYXllZC4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nTGF5ZXJFcnJvciggbGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgXCJMYXllciAnXCIgKyBsYXllci5sYWJlbCArIFwiJyBjb3VsZCBub3QgYmUgYWRkZWQgdG8gdGhlIFwiICtcbiAgICAgICAgICAgICAgICBcIm1hcCBpbnN0YW5jZTsgXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWxlYWZsZXRMYXllcikgcmV0dXJuO1xuXG4gICAgICAgIC8vY2FjaGUgbGVhZmxldCBvYmplY3QgZmlyc3RcbiAgICAgICAgaWYodGhpcy5fbGF5ZXJDYWNoZSkgdGhpcy5fbGF5ZXJDYWNoZVtsYXllci5pZF0gPSBsZWFmbGV0TGF5ZXI7XG5cbiAgICAgICAgLy9saXN0ZW4gZm9yIGxheWVyIGVycm9ycyBzbyB3ZSBjYW4gaW5mb3JtIHRoZSB1c2VyXG4gICAgICAgIC8vIHRoYXQgYSBsYXllciBoYXNuJ3QgYmVlbiBsb2FkZWQgaW4gYSB1c2VmdWwgd2F5XG4gICAgICAgIGxlYWZsZXRMYXllci5vbigndGlsZWVycm9yJywgKGUpID0+IHsgdGhpcy5oYW5kbGVMYXllckVycm9yKGUpOyB9KTtcblxuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5hZGRMYXllcihsZWFmbGV0TGF5ZXIpO1xuXG4gICAgICAgIGlmKCAhaXNOYU4oc3RhdGUuekluZGV4KSAmJiBsZWFmbGV0TGF5ZXIuc2V0WkluZGV4IClcbiAgICAgICAgICAgIGxlYWZsZXRMYXllci5zZXRaSW5kZXgoc3RhdGUuekluZGV4KTtcblxuICAgICAgICB0aGlzLl9sYXllclN0YXRlcy5wdXNoKHN0YXRlKTtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnbGF5ZXI6YWRkZWQnLCBsYXllciwgbGVhZmxldExheWVyKTtcblxuXG4gICAgICAgIC8vIGlmIGxheWVyIGlzIGluaXRpYWxseSBcIm9mZlwiIG9yLi4uXG4gICAgICAgIC8vIGlmIGxheWVyIGlzIGluaXRpYWxseSBub3QgMTAwJSBvcGFxdWVcbiAgICAgICAgaWYoIXN0YXRlLnZpc2liaWxpdHkgfHwgc3RhdGUub3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgbGF5ZXIgdmlzaWJpbGl0eSBhbmQgb3BhY2l0eSBhc3luYywgb3IgZWxzZVxuICAgICAgICAgICAgLy8gc29tZSBvZiB0aGUgbGF5ZXJzIHdvbid0IGdldCBwcm9wZXJseSBpbml0aWFsaXplZFxuICAgICAgICAgICAgc2V0VGltZW91dCggKGxheWVyLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF5ZXJWaXNpYmlsaXR5KGxheWVyLCBzdGF0ZS52aXNpYmlsaXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExheWVyT3BhY2l0eShsYXllciwgc3RhdGUub3BhY2l0eSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPIG5vdGlmeSBvZiBjaGFuZ2VcblxuICAgICAgICAgICAgICAgIC8vRFQtMjEwMiB0aW1lb3V0IG5lZWRzIHRvIGJlIGxhcmdlIGVub3VnaCBvciBlbHNlXG4gICAgICAgICAgICAgICAgLy8gZmVhdHVyZSBsYXllcnMgd29uJ3QgZ2V0IG9wYWNpdHkgdXBkYXRlZCBvbiBtYXAgbG9hZFxuICAgICAgICAgICAgfSwgMjAwMCwgbGVhZmxldExheWVyLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZnJvbSAtIHBvc2l0aW9uIG9mIGxheWVyIGJlaW5nIG1vdmVkXG4gICAgICogQHBhcmFtIHRvIC0gZGVzaXJlZCBwb3NpdGlvbiB0byBtb3ZlIGxheWVyIHRvXG4gICAgICovXG4gICAgbW92ZUxheWVyIChmcm9tIDogbnVtYmVyLCB0byA6IG51bWJlcikge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG5cbiAgICAgICAgaWYoaXNOYU4oZnJvbSkpIHJldHVybjtcblxuICAgICAgICAvL2VuZCBvZiBsaXN0XG4gICAgICAgIGlmKGlzTmFOKHRvKSkgdG8gPSB0aGlzLl9sYXllclN0YXRlcy5sZW5ndGgtMTtcblxuICAgICAgICBsZXQgY29weSA9IHRoaXMuX2xheWVyU3RhdGVzLnNwbGljZShmcm9tLCAxKVswXTsgICAgLy9ncmFiIGxheWVyIGJlaW5nIG1vdmVkXG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzLnNwbGljZSh0bywgMCwgY29weSk7XG5cbiAgICAgICAgZm9yKGxldCB6PTEsIGk9dGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoLTE7IGk+PTA7IC0taSwrK3opIHtcbiAgICAgICAgICAgIGxldCBsYXllclN0YXRlID0gdGhpcy5fbGF5ZXJTdGF0ZXNbaV07XG4gICAgICAgICAgICBsZXQgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbIGxheWVyU3RhdGUubGF5ZXIuaWQgXTtcbiAgICAgICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLnNldFpJbmRleCh6KTtcbiAgICAgICAgICAgICAgICBsYXllclN0YXRlLnpJbmRleCA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoKCdsYXllcnM6Y2hhbmdlZCcsIHRoaXMuZ2V0TGF5ZXJzKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlTGF5ZXIgKGlkKSB7XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW2lkXTtcbiAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBsYXllciBmcm9tIHRyYWNrZWQgZGVmcyBhcnJheVxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRMYXllclN0YXRlSW5kZXgoaWQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5yZW1vdmVMYXllcihcIiArIGlkICsgXCIpXCIpO1xuICAgICAgICAgICAgaWYoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclN0YXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAvL3N0b3AgbGlzdGVuaW5nIGZvciBlcnJvcnNcbiAgICAgICAgICAgIGxheWVySW5zdGFuY2Uub2ZmKFwibGF5ZXI6ZXJyb3JcIik7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGxheWVyIGZyb20gbWFwXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihsYXllckluc3RhbmNlKTtcblxuICAgICAgICAgICAgLy9yZW1vdmUgbGF5ZXIgZnJvbSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZVtpZF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2goJ2xheWVyczpjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVMYXllclZpc2liaWxpdHkgKGlkKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtpZF07XG4gICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZShpZCk7XG4gICAgICAgICAgICBzdGF0ZS52aXNpYmlsaXR5ID0gIXN0YXRlLnZpc2liaWxpdHk7XG5cbiAgICAgICAgICAgIGlmKGxheWVySW5zdGFuY2UuX2N1cnJlbnRJbWFnZSkge1xuICAgICAgICAgICAgICAgIC8vRVNSSSBJbWFnZSBTZXJ2aWNlIGxheWVycyBoYXZlIGFuIElNRyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBnZXRzIG1vZGlmaWVkIGFuZCByZXBsYWNlZCBldmVyeSBtYXAgZXZlbnQgKHpvb20vcGFuKVxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbid0IGp1c3QgdG9nZ2xlIGNsYXNzZXMgbGlrZSBvbiBvdGhlciBsYXllcnMuXG4gICAgICAgICAgICAgICAgLy9JbnN0ZWFkLCB3ZSBuZWVkIHRvIHVzZSB0aGUgRVNSSSBzZXRPcGFjaXR5IG1ldGhvZCB0byB0b2dnbGVcbiAgICAgICAgICAgICAgICAvLyBidXQgbmVlZCB0byB1cGRhdGUgbGF5ZXIgc3RhdGUgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLnNldE9wYWNpdHkoc3RhdGUudmlzaWJpbGl0eSA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGFjaXR5ID0gbGF5ZXJJbnN0YW5jZS5nZXRPcGFjaXR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldExheWVyVmlzaWJpbGl0eShsYXllckluc3RhbmNlLCBzdGF0ZS52aXNpYmlsaXR5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGU6IHRoaXMgZG9lcyBub3QgdXBkYXRlIGxheWVyIGRlZmluaXRpb24gc3RhdGUuIFVzZVxuICAgICAqIE1hcEluc3RhbmNlLnRvZ2dsZUxheWVyVmlzaWJpbGl0eSB0byBkbyB0aGF0IGFuZCBhZGp1c3RcbiAgICAgKiByZW5kZXJlZCBsYXllcidzIHZpc2liaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXJJbnN0YW5jZSAtIGxlYWZsZXQgbGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIGZsYWcgaW5kaWNhdGluZyB2aXNpYmlsaXR5IG9mIGxheWVyXG4gICAgICovXG4gICAgc2V0TGF5ZXJWaXNpYmlsaXR5IChsYXllckluc3RhbmNlIDogTGF5ZXIsIHZpc2libGUgOiBib29sZWFuKSB7XG5cbiAgICAgICAgaWYoKGxheWVySW5zdGFuY2UgYXMgYW55KS5zZXRWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgICAvL3VzaW5nIGN1c3RvbSBtZXRob2QgcHJvdmlkZWQgaW4gc3JjL2xheWVyL21vZHVsZS5qc1xuICAgICAgICAgICAgKGxheWVySW5zdGFuY2UgYXMgYW55KS5zZXRWaXNpYmlsaXR5KHZpc2libGUpO1xuXG4gICAgICAgIH0gZWxzZSBpZigobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCB1c2luZyBqcXVlcnkgb24gZG9tIGRpcmVjdGx5XG4gICAgICAgICAgICBsZXQgZWwgPSBqUXVlcnkoKGxheWVySW5zdGFuY2UgYXMgYW55KS5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIGlmKHZpc2libGUpIGVsLnJlbW92ZUNsYXNzKFwiaW52aXNpYmxlXCIpO1xuICAgICAgICAgICAgLy8gZWxzZSBlbC5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgICAgICAgICBlbC5jc3MoeydkaXNwbGF5JzogdmlzaWJsZSA/ICcnIDogJ25vbmUnfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoKCdtYXA6bGF5ZXI6Y2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTGF5ZXJPcGFjaXR5IChpZCA6IHN0cmluZywgb3BhY2l0eSA6IG51bWJlcikge1xuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtpZF07XG5cbiAgICAgICAgLy9pZiBsYXllciBpZCBpcyBmb3IgYmFzZSBsYXllci4uLlxuICAgICAgICBpZighbGF5ZXJJbnN0YW5jZSAmJiB0aGlzLl9iYXNlTGF5ZXJEZWYuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICBsYXllckluc3RhbmNlID0gdGhpcy5fYmFzZUxheWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hZGp1c3QgcmVuZGVyZWQgbGVhZmxldCBsYXllclxuICAgICAgICBvcGFjaXR5ID0gdGhpcy5zZXRMYXllck9wYWNpdHkobGF5ZXJJbnN0YW5jZSwgb3BhY2l0eSk7XG5cbiAgICAgICAgLy8gaWYgb3ZlcmxheSBsYXllciwgdXBkYXRlIHN0YXRlIHZhbHVlXG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZShpZCk7XG4gICAgICAgIGlmKHN0YXRlKSBzdGF0ZS5vcGFjaXR5ID0gb3BhY2l0eTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGRvZXMgbm90IHVwZGF0ZSB0aGUgYXNzb2NpYXRlZCBMYXllciBEZWZpbml0aW9uXG4gICAgICogc3RhdGUgdmFsdWUgZm9yIG9wYWNpdHkuIFVzZSBNYXBJbnN0YW5jZS51cGRhdGVMYXllck9wYWNpdHkoKSB0b1xuICAgICAqIGJvdGggdXBkYXRlIHN0YXRlIGFuZCBhZGp1c3QgcmVuZGVyZWQgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXJJbnN0YW5jZSAtIGxlYWZsZXQgbGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gb3BhY2l0eSAtIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4wIG9yIDAgYW5kIDEwMFxuICAgICAqIEByZXR1cm4gbm9ybWFsaXplZCBvcGFjaXR5IHZhbHVlIGJldHdlZW4gMCBhbmQgMS4wXG4gICAgICovXG4gICAgc2V0TGF5ZXJPcGFjaXR5IChsYXllckluc3RhbmNlIDogTGF5ZXIsIG9wYWNpdHkgOiBudW1iZXIpIDogbnVtYmVyIHtcbiAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSAmJiAobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLnNldE9wYWNpdHkpIHtcbiAgICAgICAgICAgIGlmKG9wYWNpdHkgPiAxLjApIG9wYWNpdHkgPSBvcGFjaXR5IC8gMTAwLjA7XG4gICAgICAgICAgICAobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLnNldE9wYWNpdHkob3BhY2l0eSk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdtYXA6bGF5ZXI6Y2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGFjaXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBHZW9QbGF0Zm9ybSBMYXllciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4gTGVhZmxldCBsYXllciBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhhdCBsYXllciBvciBudWxsXG4gICAgICovXG4gICAgZ2V0TGVhZmxldExheWVyRm9yIChncExheWVyIDogYW55KSA6IExheWVyIHtcbiAgICAgICAgaWYoIWdwTGF5ZXIgfHwgIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGVhZmxldExheWVyID0gdGhpcy5fbGF5ZXJDYWNoZVtncExheWVyLmlkXTtcbiAgICAgICAgcmV0dXJuIGxlYWZsZXRMYXllciB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlR2V0RmVhdHVyZUluZm8gKGxheWVySWQgOiBzdHJpbmcpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW2xheWVySWRdO1xuICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZih0eXBlb2YobGF5ZXJJbnN0YW5jZS5lbmFibGVHZXRGZWF0dXJlSW5mbykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYobGF5ZXJJbnN0YW5jZS5pc0dldEZlYXR1cmVJbmZvRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2UuZGlzYWJsZUdldEZlYXR1cmVJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSgodGhpcy5fbWFwSW5zdGFuY2UgYXMgYW55KS5fY29udGFpbmVyKS5yZW1vdmVDbGFzcygnc2VsZWN0YWJsZS1jdXJzb3InKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLmVuYWJsZUdldEZlYXR1cmVJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSgodGhpcy5fbWFwSW5zdGFuY2UgYXMgYW55KS5fY29udGFpbmVyKS5hZGRDbGFzcygnc2VsZWN0YWJsZS1jdXJzb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgIEZlYXR1cmUgb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBhcnJheSBvZiBmZWF0dXJlcyBvbiB0aGUgbWFwXG4gICAgICovXG4gICAgZ2V0RmVhdHVyZXMgKCkgOiBhbnlbXSB7XG4gICAgICAgIGlmKHRoaXMuX2ZlYXR1cmVMYXllcikge1xuICAgICAgICAgICAgbGV0IGdlb2pzb24gPSB0aGlzLl9mZWF0dXJlTGF5ZXIudG9HZW9KU09OKCk7XG4gICAgICAgICAgICByZXR1cm4gKGdlb2pzb24gYXMgYW55KS5mZWF0dXJlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGpzb24gZ2VvanNvbiBvYmplY3Qgb3IgYXJyYXkgb2YgZ2VvanNvbiBvYmplY3RzXG4gICAgICovXG4gICAgYWRkRmVhdHVyZXMgKGpzb24gOiBhbnkpIHtcblxuICAgICAgICBpZighanNvbikgcmV0dXJuO1xuXG4gICAgICAgIGlmKHR5cGVvZihqc29uLnB1c2gpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy9hcnJheSBvZiBmZWF0dXJlc1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8anNvbi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoanNvbltpXSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnZmVhdHVyZXM6Y2hhbmdlZCcpO1xuXG4gICAgICAgIH0gZWxzZSBpZihqc29uLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVzKGpzb24uZmVhdHVyZXMpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vc2luZ2xlIGZlYXR1cmVcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZShqc29uLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGpzb24gZ2VvanNvbiBvYmplY3RcbiAgICAgKi9cbiAgICBhZGRGZWF0dXJlIChqc29uIDogYW55LCBmaXJlRXZlbnQgPzogYm9vbGVhbikge1xuICAgICAgICAvLyB2YXIgdHlwZSA9IGpzb24udHlwZTtcbiAgICAgICAgLy8gdmFyIGNvb3JkaW5hdGVzID0ganNvbi5jb29yZGluYXRlcztcblxuICAgICAgICBpZighdGhpcy5fZmVhdHVyZUxheWVyKSB7XG5cbiAgICAgICAgICAgIC8vIF9mZWF0dXJlTGF5ZXIgPSBnZW9KU09OKFtdLCBfZ2VvSnNvbkxheWVyT3B0cykuYWRkVG8oX21hcEluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllciA9IGZlYXR1cmVHcm91cCgpLmFkZFRvKHRoaXMuX21hcEluc3RhbmNlKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gX2ZlYXR1cmVMYXllci5hZGREYXRhKGpzb24pO1xuICAgICAgICB2YXIgb3B0cyA9IGpRdWVyeS5leHRlbmQoe30sIHRoaXMuX2dlb0pzb25MYXllck9wdHMpO1xuICAgICAgICBnZW9KU09OKGpzb24sIG9wdHMpLmVhY2hMYXllcigobCk9PnRoaXMuYWRkRmVhdHVyZUxheWVyKGwpKTtcblxuICAgICAgICBpZih0eXBlb2YoZmlyZUV2ZW50KSA9PT0gJ3VuZGVmaW5lZCcgfHwgZmlyZUV2ZW50ID09PSB0cnVlKVxuICAgICAgICAgICAgdGhpcy50b3VjaCgnZmVhdHVyZXM6Y2hhbmdlZCcpO1xuICAgICAgICBlbHNlIHRoaXMudG91Y2goKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShfZmVhdHVyZUxheWVyLnRvR2VvSlNPTigpKSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUpzb24gb2JqZWN0IGRlZmluaW5nIGEgR2VvSlNPTiBmZWF0dXJlXG4gICAgICovXG4gICAgdXBkYXRlRmVhdHVyZSAoZmVhdHVyZUpzb24gOiBhbnkpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRGZWF0dXJlTGF5ZXIoZmVhdHVyZUpzb24ucHJvcGVydGllcy5pZCk7XG4gICAgICAgIGlmKGxheWVyKSB7XG5cbiAgICAgICAgICAgIChsYXllciBhcyBhbnkpLmZlYXR1cmUgPSBmZWF0dXJlSnNvbjtcblxuICAgICAgICAgICAgLy91cGRhdGUgc3R5bGVcbiAgICAgICAgICAgIGxheWVyLnNldFN0eWxlKGZlYXR1cmVKc29uLnByb3BlcnRpZXMuc3R5bGUpO1xuXG4gICAgICAgICAgICAvL3JlYmluZCBsYWJlbCBpbiBjYXNlIHRoYXQgY2hhbmdlZFxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZmVhdHVyZUpzb24ucHJvcGVydGllcy5sYWJlbCB8fFxuICAgICAgICAgICAgICAgIFwiVW50aXRsZWQgXCIgKyBmZWF0dXJlSnNvbi5nZW9tZXRyeS50eXBlICsgXCIgRmVhdHVyZVwiO1xuICAgICAgICAgICAgbGF5ZXIuYmluZFRvb2x0aXAobGFiZWwpO1xuXG4gICAgICAgICAgICAvLyBsYXllci5yZWRyYXcoKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goXCJtYXA6ZmVhdHVyZTpjaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhbiBleGlzdGluZyBMLlBhdGgtYmFzZWQgbGF5ZXIgd2l0aCBvbmUgdXNpbmdcbiAgICAgKiB0aGUgc3VwcGxpZWQgRmVhdHVyZSBHZW9KU09OIG9iamVjdC4gIFJlbW92ZXMgdGhlIGV4aXN0aW5nXG4gICAgICogbGF5ZXIgYW5kIGFkZHMgYSBuZXcgb25lIGNyZWF0ZWQgZnJvbSB0aGUgR2VvSlNPTi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmZWF0dXJlSnNvbiBvYmplY3QgZGVmaW5pbmcgR2VvSlNPTiBmZWF0dXJlXG4gICAgICovXG4gICAgcmVwbGFjZUZlYXR1cmUgKGZlYXR1cmVKc29uIDogYW55KSB7XG5cbiAgICAgICAgLy9maW5kIGV4aXN0aW5nIGxheWVyIGZvciB0aGlzIGZlYXR1cmVcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRGZWF0dXJlTGF5ZXIoZmVhdHVyZUpzb24ucHJvcGVydGllcy5pZCk7XG4gICAgICAgIGlmKGxheWVyKSB7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXG4gICAgICAgICAgICAvL2FkZCByZXBsYWNlbWVudFxuICAgICAgICAgICAgZ2VvSlNPTihmZWF0dXJlSnNvbiwgdGhpcy5fZ2VvSnNvbkxheWVyT3B0cylcbiAgICAgICAgICAgICAgICAuZWFjaExheWVyKChsKT0+dGhpcy5hZGRGZWF0dXJlTGF5ZXIobCkpO1xuXG4gICAgICAgICAgICB0aGlzLnRvdWNoKFwibWFwOmZlYXR1cmU6Y2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmZWF0dXJlSWQgaWRlbnRpZmllciBvZiBmZWF0dXJlIHRvIGZvY3VzIHRoZSBtYXAgb25cbiAgICAgKi9cbiAgICBmb2N1c0ZlYXR1cmUgKGZlYXR1cmVJZCA6IHN0cmluZykge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldEZlYXR1cmVMYXllcihmZWF0dXJlSWQpO1xuICAgICAgICBpZihsYXllcikge1xuICAgICAgICAgICAgaWYoIHR5cGVvZihsYXllci5nZXRCb3VuZHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnQgPSBsYXllci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoZXh0ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YoIChsYXllciBhcyBhbnkpLmdldExhdExuZykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhdExuZyA9IChsYXllciBhcyBhbnkpLmdldExhdExuZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnBhblRvKGxhdExuZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UuZm9jdXNGZWF0dXJlKCkgLSBDYW5ub3QgZm9jdXMgZmVhdHVyZSBiZWNhdXNlIGl0IGhhcyBubyBib3VuZHMgb3IgbGF0L2xuZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UuZm9jdXNGZWF0dXJlKCkgLSBDYW5ub3QgZm9jdXMgZmVhdHVyZSBiZWNhdXNlIGl0IGhhcyBubyBsYXllclwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmZWF0dXJlSWQgOiBzdHJpbmdcbiAgICAgKi9cbiAgICByZW1vdmVGZWF0dXJlIChmZWF0dXJlSWQpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRGZWF0dXJlTGF5ZXIoZmVhdHVyZUlkKTtcbiAgICAgICAgaWYobGF5ZXIgJiYgdGhpcy5fZmVhdHVyZUxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnZmVhdHVyZXM6Y2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVGZWF0dXJlcyAoKSB7XG4gICAgICAgIGlmKHRoaXMuX2ZlYXR1cmVMYXllcikge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKFwiZmVhdHVyZXM6Y2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0RmVhdHVyZUxheWVyICggZmVhdHVyZUlkID86IHN0cmluZyApIDogRmVhdHVyZUdyb3VwIHtcbiAgICAgICAgLy9pZiBubyBmZWF0dXJlIHdhcyBzcGVjaWZpZWQsIHJldHVybiByb290IGZlYXR1cmUgbGF5ZXJcbiAgICAgICAgaWYoIWZlYXR1cmVJZCkgcmV0dXJuIHRoaXMuX2ZlYXR1cmVMYXllcjtcblxuICAgICAgICAvL290aGVyd2lzZSwgZmluZCBmZWF0dXJlLi4uXG4gICAgICAgIGlmKCF0aGlzLl9mZWF0dXJlTGF5ZXIpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuX2ZlYXR1cmVMYXllci5nZXRMYXllcnMoKTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8ZmVhdHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmKCAoZmVhdHVyZXNbaV0gYXMgYW55KS5mZWF0dXJlICYmXG4gICAgICAgICAgICAgICAgKGZlYXR1cmVzW2ldIGFzIGFueSkuZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID09PSBmZWF0dXJlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZlYXR1cmVzW2ldIGFzIGFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdG9nZ2xlRmVhdHVyZXNMYXllciAoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9mZWF0dXJlTGF5ZXIpIHJldHVybiBmYWxzZTsgICAgLy9pZ25vcmUgaWYgbm90IHJlbmRlcmVkIHlldFxuXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSAhdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZTtcbiAgICAgICAgdGhpcy5zZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KHRoaXMuX2ZlYXR1cmVMYXllciwgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgZmVhdHVyZSAtIExlYWZsZXQgZmVhdHVyZSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSAgdmlzaWJpbGl0eSAtIGZsYWdcbiAgICAgKi9cbiAgICBzZXRGZWF0dXJlVmlzaWJpbGl0eSAoZmVhdHVyZSwgdmlzaWJpbGl0eSA6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5zZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KGZlYXR1cmUsIHZpc2liaWxpdHkpO1xuICAgIH1cblxuICAgIGdldEZlYXR1cmVzTGF5ZXJWaXNpYmlsaXR5ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGU7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqIG1ldGhvZCBmb3IgYWRkaW5nIGZlYXR1cmUgbGF5ZXJzIHRvIHRoZSBtYXBcbiAgICAgKiB3aGVuIHRoZXNlIGxheWVycyBtYXkgYmUgbGF5ZXIgZ3JvdXBzLlxuICAgICAqIGZpbmRzIGxlYWYgbm9kZSBsYXllcnMgYW5kIGFkZHMgdGhlbSB0byB0aGVcbiAgICAgKiBtYXAncyBmZWF0dXJlIGdyb3VwXG4gICAgICovXG4gICAgYWRkRmVhdHVyZUxheWVyKGxheWVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEZlYXR1cmVMYXllcihsYXllcik7XG4gICAgICAgIHRoaXMudG91Y2goXCJmZWF0dXJlczpjaGFuZ2VkXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCwgdXNlICdhZGRGZWF0dXJlTGF5ZXInIGluc3RlYWRcbiAgICAgKiBAcGFyYW0gbGF5ZXJcbiAgICAgKi9cbiAgICBfYWRkRmVhdHVyZUxheWVyKGxheWVyIDogTGF5ZXIpIHtcbiAgICAgICAgaWYoIShsYXllciBhcyBhbnkpLmZlYXR1cmUgJiYgbGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgICAgICBsYXllci5lYWNoTGF5ZXIoIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEZlYXR1cmVMYXllcihjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllci5hZGRMYXllcihsYXllcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vdG9nZ2xlIHZpc2liaWxpdHkgb2YgcGFyZW50IGZlYXR1cmUgbGF5ZXJcbiAgICBzZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KGxheWVyLCB2aXNpYmlsaXR5KSB7XG4gICAgICAgIGlmKCFsYXllcikgcmV0dXJuO1xuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlID0gdmlzaWJpbGl0eTtcblxuICAgICAgICBpZihsYXllci5nZXRMYXllcnMpIHtcbiAgICAgICAgICAgIGxheWVyLmdldExheWVycygpLmZvckVhY2goIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmVhdHVyZUxheWVyVmlzaWJpbGl0eShjaGlsZCwgdmlzaWJpbGl0eSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgfHwgbGF5ZXIuX3BhdGg7XG4gICAgICAgICAgICBpZihjb250YWluZXIpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmlsaXR5ID8gJycgOiAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgIE1hcCBsaWZlY3ljbGUgb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gcmVzb2x2aW5nIHBlcnNpc3RlZCBtYXBcbiAgICAgKi9cbiAgICBzYXZlIChtZXRhZGF0YSA6IGFueSkgOiBQcm9taXNlPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWFwKG1ldGFkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWQgb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgbWFwXG4gICAgICovXG4gICAgc2F2ZU1hcCAobWQgOiBhbnkpIDogUHJvbWlzZTxhbnk+IHtcblxuICAgICAgICBsZXQgbWV0YWRhdGEgPSBtZCB8fCB7fTtcblxuICAgICAgICAvL2FkZCBHZW9QbGF0Zm9ybU1hcCByZXNvdXJjZSB0eXBlIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgY29uc3QgZ3BNYXBUeXBlID0gJ2h0dHA6Ly93d3cuZ2VvcGxhdGZvcm0uZ292L29udC9vcGVubWFwL0dlb3BsYXRmb3JtTWFwJztcbiAgICAgICAgbWV0YWRhdGEucmVzb3VyY2VUeXBlcyA9IG1ldGFkYXRhLnJlc291cmNlVHlwZXMgfHwgW107XG4gICAgICAgIGlmKG1ldGFkYXRhLnJlc291cmNlVHlwZXMuaW5kZXhPZihncE1hcFR5cGUpIDwgMClcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlc291cmNlVHlwZXMucHVzaChncE1hcFR5cGUpO1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRNYXBSZXNvdXJjZUNvbnRlbnQobWV0YWRhdGEpO1xuXG4gICAgICAgIC8vZW5zdXJlIHRoZSB0d28gbmFtZSBwcm9wZXJ0aWVzIGxpbmUgdXBcbiAgICAgICAgaWYoY29udGVudC50aXRsZSAmJiBjb250ZW50LnRpdGxlICE9PSBjb250ZW50LmxhYmVsKSB7XG4gICAgICAgICAgICBjb250ZW50LmxhYmVsID0gY29udGVudC50aXRsZTtcbiAgICAgICAgfSBlbHNlIGlmKGNvbnRlbnQubGFiZWwgJiYgIWNvbnRlbnQudGl0bGUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQudGl0bGUgPSBjb250ZW50LmxhYmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJVcGRhdGluZzogXCIgKyBKU09OLnN0cmluZ2lmeShtYXApKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPGFueT4oIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTUFQKS5zYXZlKGNvbnRlbnQpXG4gICAgICAgICAgICAudGhlbiggcmVzdWx0ID0+IHtcblxuICAgICAgICAgICAgICAgIC8vdHJhY2sgbmV3IG1hcCdzIGluZm8gc28gd2UgY2FuIHVwZGF0ZSBpdCB3aXRoIG5leHQgc2F2ZVxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLl9tYXBJZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwSWQgPSByZXN1bHQuaWQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBEZWYgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEV4dGVudCA9IHJlc3VsdC5leHRlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyPT57XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBDb3JlIE1hcEluc3RhbmNlLnNhdmVNYXAoKSAtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJUaGUgcmVxdWVzdGVkIG1hcCBjb3VsZCBub3QgYmUgc2F2ZWQgYmVjYXVzZTogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJUaGUgcmVxdWVzdGVkIG1hcCBjb3VsZCBub3QgYmUgc2F2ZWQgYmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGVycm9yKHMpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIG1hcCdzIGRlc2NyaXB0b3IgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gbWFwSWQgaWRlbnRpZmllciBvZiBtYXBcbiAgICAgKiBAcmV0dXJuIHJlc29sdmluZyB0aGUgbWFwIG9iamVjdFxuICAgICAqL1xuICAgIGZldGNoTWFwIChtYXBJZCA6IHN0cmluZykgOiBhbnkge1xuICAgICAgICAvL0hhdmluZyB0byBzZW5kIGNhY2hlIGJ1c3RpbmcgcGFyYW1ldGVyIHRvIGF2b2lkIENPUlMgaGVhZGVyIGNhY2hlXG4gICAgICAgIC8vIG5vdCBzZW5kaW5nIGNvcnJlY3QgT3JpZ2luIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLk1BUCkuZ2V0KG1hcElkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIG1hcCdzIGRlc2NyaXB0b3IgYW5kIGxvYWQgaXQgYXMgdGhlXG4gICAgICogY3VycmVudCBtYXAgbWFuYWdlZCBieSB0aGlzIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0gbWFwSWQgaWRlbnRpZmllciBvZiBtYXBcbiAgICAgKiBAcmV0dXJuIHJlc29sdmluZyB0aGUgbWFwIG9iamVjdFxuICAgICAqL1xuICAgIGxvYWRNYXAgKG1hcElkIDogc3RyaW5nKSA6IGFueSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPGFueT4oIChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5mZXRjaE1hcChtYXBJZCkudGhlbihtYXAgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYoIW1hcCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVxdWVzdGVkIG1hcCAoJ1wiICsgbWFwSWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInKSBjYW1lIGJhY2sgbnVsbFwiKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YobWFwKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArIG1hcElkICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJykgY2FtZSBiYWNrIGFzIGEgc3RyaW5nXCIpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKChtYXAgYXMgYW55KS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhbiBlcnJvciBsb2FkaW5nIHRoZSByZXF1ZXN0ZWQgbWFwICgnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwSWQgKyBcIicpOiBcIiArIChtYXAgYXMgYW55KS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8vbG9hZGluZyBhIG1hcCBieSBpdHMgSUQsIHNvIHdlIG5lZWQgdG8gaW5jcmVtZW50IGl0J3MgdmlldyBjb3VudFxuICAgICAgICAgICAgICAgIGlmKCdkZXZlbG9wbWVudCcgIT09IENvbmZpZy5lbnYpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCAobWFwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZSB2aWV3IGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmlld3MgPSBtYXAuc3RhdGlzdGljcyA/IChtYXAuc3RhdGlzdGljcy5udW1WaWV3c3x8MCkgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGNoID0gWyB7IG9wOiAncmVwbGFjZScsIHBhdGg6ICcvc3RhdGlzdGljcy9udW1WaWV3cycsIHZhbHVlOiB2aWV3cysxIH0gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTUFQKS5wYXRjaChtYXAuaWQsIHBhdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5tYXBTZXJ2aWNlLnBhdGNoKG1hcC5pZCwgcGF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbiggdXBkYXRlZCA9PiB7IG1hcC5zdGF0aXN0aWNzID0gdXBkYXRlZC5zdGF0aXN0aWNzOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLnNhdmVNYXAoKSAtIEVycm9yIHVwZGF0aW5nIHZpZXcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvdW50IGZvciBtYXAgKCdcIiArIG1hcElkICsgXCInKTogXCIgKyBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDAwLCBtYXApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9sb2FkIHRoZSBtYXAgaW50byB0aGUgdmlld2VyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkTWFwRnJvbU9iaihtYXApO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtYXApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCggZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmxvYWRNYXAoKSAtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJUaGUgcmVxdWVzdGVkIG1hcCBjb3VsZCBub3QgYmUgbG9hZGVkIGJlY2F1c2UgXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJUaGUgcmVxdWVzdGVkIG1hcCAoJ1wiICsgbWFwSWQgK1xuICAgICAgICAgICAgICAgICAgICBcIicpIGNvdWxkIG5vdCBiZSBsb2FkZWQgYmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGVycm9yKHMpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIG1hcCBmcm9tIGl0cyBkZXNjcmlwdG9yIGFzIHRoZSBjdXJyZW50XG4gICAgICogbWFwIG1hbmFnZWQgYnkgdGhpcyBzZXJ2aWNlXG4gICAgICogQHBhcmFtIG1hcCBvYmplY3RcbiAgICAgKi9cbiAgICBsb2FkTWFwRnJvbU9iaiAobWFwIDogYW55KSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJMb2FkaW5nIE1hcCBPYmplY3RcIik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG1hcCk7XG5cbiAgICAgICAgdGhpcy5fbWFwSWQgPSBtYXAuaWQ7XG4gICAgICAgIHRoaXMuX21hcERlZiA9IG1hcDtcblxuICAgICAgICBtYXAuZXh0ZW50ID0gdGhpcy5lbnN1cmVFeHRlbnQobWFwLmV4dGVudCk7XG5cbiAgICAgICAgLy9zZXQgZXh0ZW50IGZyb20gbG9hZGVkIG1hcFxuICAgICAgICB0aGlzLl9kZWZhdWx0RXh0ZW50ID0gbWFwLmV4dGVudDtcbiAgICAgICAgdmFyIGV4dGVudCA9IG1hcC5leHRlbnQ7XG5cbiAgICAgICAgLy9yZW1vdmUgZXhpc3RpbmcgbGF5ZXJzXG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmVhY2hMYXllcigobCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIobCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9sYXllckNhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gW107XG5cbiAgICAgICAgLy9zZXQgbmV3IGJhc2UgbGF5ZXJcbiAgICAgICAgdGhpcy5zZXRCYXNlTGF5ZXIobWFwLmJhc2VMYXllcik7XG5cbiAgICAgICAgLy9hZGQgbGF5ZXJzIGZyb20gbG9hZGVkIG1hcFxuICAgICAgICB0aGlzLmFkZExheWVycyhtYXAubGF5ZXJzKTtcblxuICAgICAgICAvL2FkZCBmZWF0dXJlc1xuICAgICAgICBpZihtYXAuYW5ub3RhdGlvbnMgJiYgbWFwLmFubm90YXRpb25zLmdlb0pTT04pIHtcbiAgICAgICAgICAgIGxldCBmYyA9IG1hcC5hbm5vdGF0aW9ucy5nZW9KU09OO1xuICAgICAgICAgICAgaWYoZmMuZmVhdHVyZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlcyhmYy5mZWF0dXJlcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlcyhbZmNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhbXG4gICAgICAgICAgICBbZXh0ZW50Lm1pbnksIGV4dGVudC5taW54XSxcbiAgICAgICAgICAgIFtleHRlbnQubWF4eSwgZXh0ZW50Lm1heHhdXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ21hcDpsb2FkZWQnLCBtYXApO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXh0ZW50XG4gICAgICogQHJldHVybiBjb3JyZWN0ZWQgb3IgZGVmYXVsdCBleHRlbnRcbiAgICAgKi9cbiAgICBlbnN1cmVFeHRlbnQoIGV4dGVudCA6IGFueSApIDogYW55IHtcblxuICAgICAgICBsZXQgd2VzdCAgPSAhZXh0ZW50IHx8IGlzTmFOKGV4dGVudC5taW54KSA/IC0xNzkuMCA6IGV4dGVudC5taW54KjEuMDtcbiAgICAgICAgbGV0IGVhc3QgID0gIWV4dGVudCB8fCBpc05hTihleHRlbnQubWF4eCkgPyAgMTc5LjAgOiBleHRlbnQubWF4eCoxLjA7XG4gICAgICAgIGxldCBzb3V0aCA9ICFleHRlbnQgfHwgaXNOYU4oZXh0ZW50Lm1pbnkpID8gIC04OS4wIDogZXh0ZW50Lm1pbnkqMS4wO1xuICAgICAgICBsZXQgbm9ydGggPSAhZXh0ZW50IHx8IGlzTmFOKGV4dGVudC5tYXh5KSA/ICAgODkuMCA6IGV4dGVudC5tYXh5KjEuMDtcblxuICAgICAgICAvL2Vuc3VyZSB4LHkgaXMgb3JkZXJlZCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGlmKHdlc3QgPiBlYXN0KSB7XG4gICAgICAgICAgICB0ID0gTWF0aC5taW4od2VzdCwgZWFzdCk7XG4gICAgICAgICAgICBlYXN0ID0gTWF0aC5tYXgod2VzdCwgZWFzdCk7XG4gICAgICAgICAgICB3ZXN0ID0gdDtcbiAgICAgICAgfVxuICAgICAgICBpZihzb3V0aCA+IG5vcnRoKSB7XG4gICAgICAgICAgICB0ID0gTWF0aC5taW4oc291dGgsIG5vcnRoKTtcbiAgICAgICAgICAgIG5vcnRoID0gTWF0aC5tYXgoc291dGgsIG5vcnRoKTtcbiAgICAgICAgICAgIHNvdXRoID0gdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcHJldmVudCBvdXQtb2YtYm91bmRzIGV4dGVudHNcbiAgICAgICAgaWYod2VzdCA8IC0xODAuMCkgd2VzdCA9IC0xNzkuMDtcbiAgICAgICAgaWYoZWFzdCA+IDE4MC4wKSAgZWFzdCA9ICAxNzkuMDtcbiAgICAgICAgaWYoc291dGggPCAtOTAuMCkgc291dGggPSAtODkuMDtcbiAgICAgICAgaWYobm9ydGggPiA5MC4wKSAgbm9ydGggPSAgODkuMDtcblxuICAgICAgICByZXR1cm4geyBtaW54IDogd2VzdCwgbWlueSA6IHNvdXRoLCBtYXh4IDogZWFzdCwgbWF4eSA6IG5vcnRoIH07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3lNYXAgKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkRlc3Ryb3lpbmcgTWFwXCIpO1xuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllciA9IG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHRha2UgYW4gZXhpc3RpbmcgbWFwIHRoYXQgaXMgYWxyZWFkeSBwZXJzaXN0ZWQgb24gdGhlXG4gICAgICogc2VydmVyIGFuZCB1bmxpbmsgaXQgaGVyZSBpbiB0aGUgY2xpZW50IHNvIHRoYXQgaXQgd2lsbCBiZSBzYXZlZFxuICAgICAqIGFzIGEgY29tcGxldGVseSBuZXcgbWFwIHdoZW4gbWFwU2VydmljZS5zYXZlTWFwKC4uLikgaXMgbmV4dCBjYWxsZWRcbiAgICAgKi9cbiAgICBzZXRBc05ld01hcCAobWFwVG9Vc2UpIHtcbiAgICAgICAgdGhpcy5fbWFwSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXBEZWYgPSBtYXBUb1VzZSB8fCB0aGlzLmluaXRpYWxpemVNYXBEZWZpbml0aW9uKCk7XG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIFRvb2wgb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIHJlZ2lzdGVyVG9vbCAoaWQsIHRvb2wpIHtcbiAgICAgICAgdGhpcy5fdG9vbHNbaWRdID0gdG9vbDtcbiAgICB9XG5cbiAgICB1bnJlZ2lzdGVyVG9vbCAoaWQpIHtcbiAgICAgICAgdGhpcy5fdG9vbHNbaWRdID0gbnVsbDtcbiAgICB9XG5cbiAgICBlbmFibGVUb29sIChpZCwgZmluaXNoKSB7XG4gICAgICAgIGlmKCF0aGlzLl90b29sc1tpZF0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdG9vbHNbaWRdLmFjdGl2YXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ3Rvb2w6ZGlzYWJsZWQnLCBpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vdGlmeSgndG9vbDplbmFibGVkJywgaWQpO1xuICAgIH1cblxuXG4gICAgLyogLS0tLS0tLS0tLS0gTUlTQyAtLS0tLS0tLS0tLS0gKi9cblxuICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2dza2xlZS9uZ1N0b3JhZ2VcbiAgICBjYWNoZU1hcCAoKSB7XG5cbiAgICAgICAgaWYodGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLmRpcnR5KSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXBSZXNvdXJjZUNvbnRlbnQoKTtcbiAgICAgICAgICAgIC8vdXNlIGV4cGxvZGVkIGxheWVyIGluZm9cbiAgICAgICAgICAgIG1hcC5sYXllcnMgPSB0aGlzLl9sYXllclN0YXRlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIC8vICRzZXNzaW9uU3RvcmFnZS5tYXAgPSBtYXA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXN0b3JlTWFwICgpIHtcbiAgICAgICAgLy8gaWYoJHNlc3Npb25TdG9yYWdlLm1hcCkge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJSZXN0b3JpbmcgY2FjaGVkIG1hcFwiKTtcbiAgICAgICAgLy8gICAgIGxldCBtYXAgPSAkc2Vzc2lvblN0b3JhZ2UubWFwO1xuICAgICAgICAvLyAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkobWFwKSk7XG4gICAgICAgIC8vICAgICAkc2Vzc2lvblN0b3JhZ2UubWFwID0gbnVsbDtcbiAgICAgICAgLy8gICAgIHRoaXMubG9hZE1hcEZyb21PYmoobWFwKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG59XG4iXX0=