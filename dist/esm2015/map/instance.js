/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as jquery from "jquery";
/** @type {?} */
const jQuery = jquery;
import { circleMarker, geoJSON, featureGroup, LayerGroup } from 'leaflet';
import { Config, ItemTypes, ServiceFactory, XHRHttpClient } from '@geoplatform/client';
import LayerFactory from '../layer/factory';
import DefaultBaseLayer from '../layer/baselayer-default';
class Listener {
    constructor() {
        //listeners to be unregistered upon destroy
        this._listeners = {};
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    on(type, listener) {
        if (!this._listeners[type])
            this._listeners[type] = [];
        this._listeners[type].push(listener);
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    off(type, listener) {
        if (!type)
            this._listeners = {};
        if (!this._listeners[type])
            return;
        if (!listener)
            this._listeners[type] = [];
        else {
            /** @type {?} */
            var idx = this._listeners[type].indexOf(listener);
            if (idx >= 0)
                this._listeners[type].splice(idx, 1);
        }
    }
    /**
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    notify(type, ...options) {
        if (!this._listeners[type])
            return;
        /** @type {?} */
        var args = Array.prototype.slice.call(arguments, 1);
        this._listeners[type].forEach((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { l.apply(null, args); }));
    }
}
if (false) {
    /** @type {?} */
    Listener.prototype._listeners;
}
export default class MapInstance extends Listener {
    /**
     * @param {?} key
     */
    constructor(key) {
        super();
        this.setHttpClient(new XHRHttpClient());
        this.setServiceFactory(ServiceFactory);
        //generate random key (see factory below)
        this._key = key || Math.ceil(Math.random() * 9999);
        //registry id of current map if available
        this._mapId = null,
            //definition of map (ie, from server)
            this._mapDef = this.initializeMapDefinition(),
            //primary map instance (ie, leaflet)
            this._mapInstance = null,
            //default map extent (if map doesn't have one for being saved)
            this._defaultExtent = null,
            //current base layer object and leaflet instance
            this._baseLayerDef = null,
            this._baseLayer = null,
            //set definitions of layer states (including layer info) on map
            this._layerStates = [],
            //map layer def ids with leaflet instances
            this._layerCache = {},
            //errors generated by layers loading
            this._layerErrors = [],
            this._layerErrorHandler = (/**
             * @param {?} e
             * @return {?}
             */
            function (e) {
                console.log(`MapInstance.defaultLayerErrorHandler() - ${e.id} : ${e.message}`);
            }),
            //layer used to store features on map
            this._featureLayer = null,
            this._featureLayerVisible = true,
            //set of registered map tools
            this._tools = [],
            //state management
            this.state = { dirty: false }; // jshint ignore:line
        this._geoJsonLayerOpts = {
            style: (/**
             * @param {?} feature
             * @return {?}
             */
            function (feature) {
                if (feature.properties.style)
                    return feature.properties.style;
            }),
            onEachFeature: (/**
             * @param {?} feature
             * @param {?} layer
             * @return {?}
             */
            function (feature, layer) {
                /** @type {?} */
                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };
                if (~feature.geometry.type.indexOf('Point')) {
                    style.fillOpacity = 0.9;
                }
                /** @type {?} */
                var props = feature.properties = feature.properties || {};
                if (feature.properties.id === undefined || feature.properties.id === null)
                    feature.properties.id = Math.floor(Math.random() * 999999);
                feature.properties.label = props.label || props.title || props.name || "Untitled " + feature.geometry.type + " Feature";
                feature.properties.description = props.description || props.desc || "This feature needs a description!";
                feature.properties.style = props.style || style;
                layer.bindTooltip(props.label);
                /*
                toggle: setLabelNoHide(bool)
                it may only exist on markers!
                */
            }),
            pointToLayer: (/**
             * @param {?} feature
             * @param {?} latlng
             * @return {?}
             */
            function (feature, latlng) {
                /** @type {?} */
                var style = feature.properties.style || {};
                style.radius = style.radius || 4;
                style.weight = style.weight || 2;
                style.color = style.color || '#03f';
                style.opacity = style.opacity || 0.9;
                style.fillOpacity = style.opacity;
                style.fillColor = style.color;
                return circleMarker(latlng, style);
            })
        };
    }
    /**
     * @return {?}
     */
    dispose() {
        this.destroyMap();
        this.svcCache = null;
        this.serviceFactory = null;
        this.httpClient = null;
        this._key = null;
        this._mapId = null;
        this._mapDef = null;
        this._mapInstance = null;
        this._defaultExtent = null;
        this._baseLayerDef = null;
        this._baseLayer = null;
        this._layerStates = null;
        this._layerCache = null;
        this._layerErrors = null;
        this._featureLayer = null;
        this._featureLayerVisible = true;
        this._tools = null;
        this.state = null;
        this._geoJsonLayerOpts = null;
    }
    /**
     * @return {?}
     */
    getKey() {
        return this._key;
    }
    /**
     * Override default (JQuery-based) map service used by this instance
     * @deprecated use setServiceFactory instead
     * @param {?} mapService - service to use to CRUD map objects
     * @return {?}
     */
    setService(mapService) {
        // this.mapService = mapService;
    }
    /**
     * @param {?} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     * @return {?}
     */
    setServiceFactory(factory) {
        this.svcCache = {}; //wipe out cached services
        this.serviceFactory = factory;
    }
    /**
     * @param {?} httpClient - HttpClient impl to use with the new factory
     * @return {?}
     */
    setHttpClient(httpClient) {
        this.svcCache = {}; //wipe out cached services
        this.httpClient = httpClient;
    }
    /**
     * @param {?} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {?} item service implementation for the requested type
     */
    getService(type) {
        if (!this.svcCache[type])
            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);
        return this.svcCache[type];
    }
    /**
     * @param {?} fn - callback when an error is encountered
     * @return {?}
     */
    setErrorHandler(fn) {
        this._layerErrorHandler = fn;
    }
    //-----------------
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerStateIndex(layerId) {
        if (!layerId)
            return -1;
        for (let i = 0; i < this._layerStates.length; ++i) {
            if (this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {
                return i;
            }
        }
        return -1;
        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerState(layerId) {
        /** @type {?} */
        let index = this.getLayerStateIndex(layerId);
        return index >= 0 ? this._layerStates[index] : null;
    }
    //-----------------
    /**
     * @return {?}
     */
    initializeMapDefinition() {
        return {
            type: ItemTypes.MAP,
            title: "My New Map",
            label: "My New Map",
            description: "This map needs a description",
            createdBy: null,
            baseLayer: this._baseLayerDef,
            layers: [],
            keywords: [],
            themes: [],
            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']
        };
    }
    /**
     * @param {?=} metadata object
     * @return {?} object definition of the current map suitable for sending to WMVR
     */
    getMapResourceContent(metadata) {
        metadata = metadata || {};
        //map layers
        metadata.layers = this._layerStates.map((/**
         * @param {?} state
         * @return {?}
         */
        state => {
            /** @type {?} */
            let result = {
                visibility: state.visibility || true,
                opacity: isNaN(state.opacity) ? 1.0 : state.opacity * 1,
                layer: {
                    id: state.layer.id,
                    uri: state.layer.uri,
                    label: state.layer.label
                }
            };
            return result;
        }));
        // ... UAL should support accepting just an id here, so we'll do just that
        metadata.baseLayer = {
            id: this._baseLayerDef.id,
            uri: this._baseLayerDef.uri,
            label: this._baseLayerDef.label
        };
        metadata.annotations = this._featureLayer ?
            { title: "Map Features", geoJSON: this._featureLayer.toGeoJSON() } : null;
        //geographic extent
        /** @type {?} */
        let extent = this._mapInstance.getBounds();
        metadata.extent = {
            minx: extent.getWest(),
            miny: extent.getSouth(),
            maxx: extent.getEast(),
            maxy: extent.getNorth()
        };
        return metadata;
    }
    /**
     * @return {?} Leaflet toolbar
     */
    getDrawControlToolbar() {
        if (!((/** @type {?} */ (this._mapInstance))).drawControl)
            return null;
        /** @type {?} */
        var toolbars = ((/** @type {?} */ (this._mapInstance))).drawControl._toolbars;
        /** @type {?} */
        var toolbar = null;
        for (var key in toolbars) {
            if (toolbars.hasOwnProperty(key)) {
                if (toolbars[key]._modes) {
                    toolbar = toolbars[key];
                    break;
                }
            }
        }
        return toolbar;
    }
    /**
     * @param {?} error Leaflet tile load error (.target is layer, .tile is image)
     * @return {?}
     */
    handleLayerError(error) {
        // console.log("MapInstance.handleLayerError() - " +
        //     "Layer's tile failed to load: " + error.tile.src);
        if (!this._layerCache) {
            console.log("Unable to find layer in layer cache. Layer error is " + error);
            return;
        }
        /** @type {?} */
        var layer = error.target;
        for (var id in this._layerCache) {
            if (this._layerCache[id] === layer) {
                this.processLayerError(error, id);
                break;
            }
        }
    }
    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     * @param {?} error
     * @param {?} id
     * @return {?}
     */
    processLayerError(error, id) {
        /** @type {?} */
        var finder = (/**
         * @param {?} l
         * @return {?}
         */
        (l) => { return l.id === id || (l.layer && l.layer.id === id); });
        if (!this._layerErrors.find(finder)) {
            /** @type {?} */
            let obj = this.logLayerError(id, "Layer ('" + id + "') failed to completely load. " +
                "It may be inaccessible or misconfigured.");
            /** @type {?} */
            var url = ((/** @type {?} */ (error))).tile.src;
            /** @type {?} */
            var params = { id: id };
            url.substring(url.indexOf("?") + 1, url.length).split('&').forEach((/**
             * @param {?} param
             * @return {?}
             */
            function (param) {
                /** @type {?} */
                var p = param.split('=');
                params[p[0]] = p[1];
            }));
            /** @type {?} */
            let layerService = (/** @type {?} */ (this.getService(ItemTypes.LAYER)));
            if (layerService) {
                layerService.validate(id, params)
                    .catch((/**
                 * @param {?} e
                 * @return {?}
                 */
                e => {
                    /** @type {?} */
                    var def = this._layerStates.find(finder);
                    if (def) {
                        obj.message = "Layer '" + def.layer.label + "' failed to completely load. " +
                            "Reported cause: " + e.message;
                    }
                    this.notify('layer:error', obj);
                }));
            }
        }
    }
    /**
     * @param {?} layerId - identifier of layer generating the error
     * @param {?} errorMsg - message of the error
     * @return {?}
     */
    logLayerError(layerId, errorMsg) {
        // console.log("MapInstance.logLayerError() - layer "  + id +
        //     " generated error '" + errorMsg + "'");
        /** @type {?} */
        let err = { id: layerId, message: errorMsg };
        this._layerErrors.push(err);
        if (this._layerErrorHandler) {
            this._layerErrorHandler(err);
        }
        return err;
    }
    /* -- State Management of internal model -- */
    /**
     * @param {?=} event
     * @param {...?} options
     * @return {?}
     */
    touch(event, ...options) {
        this.state.dirty = true;
        if (event) {
            if (arguments.length > 1) {
                this.notify.apply(this, Array.prototype.slice.call(arguments));
            }
            else
                this.notify(event);
            // console.log("Dirtying map for " + event);
        }
        // else console.log("Dirtying map");
    }
    /**
     * @return {?}
     */
    clean() {
        // console.log("Cleaning map");
        this.state.dirty = false;
    }
    /* --------------------------------------- */
    /* ==============================================
            Map manipulation operations
           ============================================== */
    /**
     * @param {?} map
     * @return {?}
     */
    setMap(map) { this._mapInstance = map; }
    /**
     * @return {?} map instance
     */
    getMap() { return this._mapInstance; }
    /**
     * @return {?} definition of map
     */
    getMapDefinition() { return this._mapDef; }
    /**
     * @return {?} identifier of map
     */
    getMapId() { return this._mapId; }
    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param {?} lat number
     * @param {?} lng number
     * @param {?=} zoom number (optional)
     * @return {?}
     */
    setView(lat, lng, zoom) {
        /** @type {?} */
        let z = zoom;
        if (typeof (z) === 'undefined')
            z = this._mapInstance.getZoom();
        this._mapInstance.setView([lat, lng], z);
        this.touch('map:view:changed');
    }
    /**
     * Retrieve the current center of the map
     * @return {?} [lat,lng]
     */
    getView() {
        /** @type {?} */
        var latLng = this._mapInstance.getCenter();
        return [latLng.lat, latLng.lng];
    }
    /**
     * @return {?} integer current zoom level of the map
     */
    getZoom() {
        return this._mapInstance.getZoom();
    }
    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     * @return {?}
     */
    zoomToDefault() {
        if (!this._mapInstance)
            return;
        if (this._defaultExtent) {
            this._mapInstance.fitBounds([
                [this._defaultExtent.miny, this._defaultExtent.minx],
                [this._defaultExtent.maxy, this._defaultExtent.maxx]
            ]);
        }
        else {
            console.log("MapInstance.zoomToDefault() - No default extent specified");
            this._mapInstance.setView([38, -96], 5);
        }
        try {
            this.touch('map:view:changed');
        }
        catch (e) { }
    }
    /**
     * @param {?} extent - either a GP extent object or Leaflet LatLngBounds object
     * @return {?}
     */
    setExtent(extent) {
        if (!extent)
            return;
        if (typeof (extent.minx) !== 'undefined' &&
            typeof (extent.miny) !== 'undefined' &&
            typeof (extent.maxx) !== 'undefined' &&
            typeof (extent.maxy) !== 'undefined') {
            //GP model extent
            this._mapInstance.fitBounds([
                [extent.miny, extent.minx],
                [extent.maxy, extent.maxx]
            ]);
        }
        else if (typeof (extent.getWest) !== 'undefined') {
            //L.LatLngBounds
            this._mapInstance.fitBounds(extent);
        }
        else {
        }
    }
    /* ==============================================
            Layer operations
           ============================================== */
    /**
     * @param {?} layer Leaflet Layer instance or object definition
     * @return {?}
     */
    setBaseLayer(layer) {
        /** @type {?} */
        let promise = null;
        if (!layer) {
            /** @type {?} */
            let svc = (/** @type {?} */ (this.getService(ItemTypes.LAYER)));
            promise = DefaultBaseLayer.get(svc);
        }
        else
            promise = Promise.resolve(layer);
        promise.then((/**
         * @param {?} layer
         * @return {?}
         */
        layer => {
            /** @type {?} */
            let leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                console.log("Warning: MapInstance could not create base " +
                    "layer for '" + layer.id + "'");
                return;
            }
            this._mapInstance.addLayer(leafletLayer);
            ((/** @type {?} */ (leafletLayer))).setZIndex(0); //set at bottom
            //set at bottom
            /** @type {?} */
            let oldBaseLayer = this._baseLayer;
            if (oldBaseLayer) {
                this._mapInstance.removeLayer(oldBaseLayer);
            }
            //remember new base layer
            this._baseLayer = leafletLayer;
            this._baseLayerDef = layer;
            //will notify listeners
            this.touch('baselayer:changed', layer, leafletLayer);
            // this.notify('baselayer:changed', layer, leafletLayer);
        }))
            .catch((/**
         * @param {?} e
         * @return {?}
         */
        e => {
            console.log(`MapInstance.setBaseLayer() - Error getting base layer for map : ${e.message}`);
            this.logLayerError(layer.id, "Error setting baselayer on map " +
                "because of the following error(s): " + e.message);
        }));
    }
    /**
     * @return {?} array of base layers definitions that can be used
     */
    // getBaseLayerOptions () {
    //     return this._baseLayerOptions;
    // },
    getBaseLayer() { return this._baseLayerDef; }
    /**
     * @return {?} list of layer states containing layer information
     */
    getLayers() { return this._layerStates; }
    /**
     * @return {?}
     */
    getLayerErrors() { return this._layerErrors; }
    /**
     * @return {?}
     */
    clearLayerErrors() {
        this._layerErrors = [];
        this.notify('layer:error');
    }
    /**
     * @return {?}
     */
    clearOverlays() {
        if (!this._layerCache)
            return;
        for (var i = this._layerStates.length - 1; i >= 0; --i) {
            /** @type {?} */
            var state = this._layerStates[i];
            /** @type {?} */
            var layerInstance = this._layerCache[state.layer.id];
            if (layerInstance) {
                layerInstance.off("layer:error");
                this._layerCache[state.layer.id] = null;
                this._mapInstance.removeLayer(layerInstance);
            }
        }
        this._layerStates = [];
        this.touch('layers:changed');
        //TODO stop listening for layer events
    }
    /**
     * @param {?} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     * @return {?}
     */
    addLayers(layers) {
        if (!this._layerCache) {
            console.log("WARN: attempting to add layers to an empty cache");
            return;
        }
        if (!this._layerCache) {
            console.log("WARN: Attempting to add layers to a map with no layer cache");
            return;
        }
        if (!layers)
            return;
        if (typeof (layers.push) === 'undefined') {
            layers = [layers];
        }
        layers.forEach((/**
         * @param {?} obj
         * @param {?} index
         * @return {?}
         */
        (obj, index) => {
            /** @type {?} */
            let layer = null;
            /** @type {?} */
            let state = null;
            if (obj.type && obj.type === ItemTypes.LAYER) { //is a layer
                layer = obj;
            }
            else if (obj.layer) { //is layer state
                layer = obj.layer; // containing a layer
                state = obj;
            }
            if (!layer) {
                console.log("MapInstance.addLayers() - layer (" + index +
                    ") is not a Layer or a Layer state. Ignoring...");
                return; //layer info is missing, skip it
            }
            //DT-442 prevent adding layer that already exists on map
            if (this._layerCache[layer.id])
                return;
            if (!state) {
                try {
                    //wrapped in try{}catch because layer may contain circular reference
                    // which will cause error when used by JSON methods
                    /** @type {?} */
                    let layerCopy = JSON.parse(JSON.stringify(layer));
                    state = {
                        opacity: 1,
                        visibility: true,
                        layer: layerCopy
                    };
                }
                catch (e) {
                    throw new Error("Unable to add layer to map because of " + e.message);
                }
            }
            /** @type {?} */
            let z = layers.length - index;
            state.zIndex = z;
            this.addLayerWithState(layer, state);
        }));
        this.touch('layers:changed');
    }
    /**
     * @param {?} layer - GeoPlatform Layer instance
     * @param {?} state - GeoPlatform Layer State
     * @return {?}
     */
    addLayerWithState(layer, state) {
        /** @type {?} */
        var leafletLayer = null;
        try {
            if (!layer || !state)
                throw new Error("Invalid argument, missing layer and or state");
            leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                /** @type {?} */
                let msg = "Could not create leaflet instance for GP Layer '" + layer.id + "'.";
                if (!layer.services || !layer.services.length) {
                    msg += '  The layer instance has no services included, ' +
                        'which will prevent most layers from being displayed.';
                }
                throw new Error(msg);
            }
        }
        catch (e) {
            this.logLayerError(layer.id, "Layer '" + layer.label + "' could not be added to the " +
                "map instance; " + e.message);
        }
        if (!leafletLayer)
            return;
        //cache leaflet object first
        if (this._layerCache)
            this._layerCache[layer.id] = leafletLayer;
        //listen for layer errors so we can inform the user
        // that a layer hasn't been loaded in a useful way
        leafletLayer.on('tileerror', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => { this.handleLayerError(e); }));
        this._mapInstance.addLayer(leafletLayer);
        if (!isNaN(state.zIndex) && leafletLayer.setZIndex)
            leafletLayer.setZIndex(state.zIndex);
        this._layerStates.push(state);
        this.notify('layer:added', layer, leafletLayer);
        // if layer is initially "off" or...
        // if layer is initially not 100% opaque
        if (!state.visibility || state.opacity < 1) {
            // initialize layer visibility and opacity async, or else
            // some of the layers won't get properly initialized
            setTimeout((/**
             * @param {?} layer
             * @param {?} state
             * @return {?}
             */
            (layer, state) => {
                this.setLayerVisibility(layer, state.visibility);
                this.setLayerOpacity(layer, state.opacity);
                //TODO notify of change
                //DT-2102 timeout needs to be large enough or else
                // feature layers won't get opacity updated on map load
            }), 2000, leafletLayer, state);
        }
    }
    /**
     * @param {?} from - position of layer being moved
     * @param {?} to - desired position to move layer to
     * @return {?}
     */
    moveLayer(from, to) {
        if (!this._layerCache)
            return;
        if (!this._layerCache)
            return;
        if (isNaN(from))
            return;
        //end of list
        if (isNaN(to))
            to = this._layerStates.length - 1;
        /** @type {?} */
        let copy = this._layerStates.splice(from, 1)[0];
        this._layerStates.splice(to, 0, copy);
        for (let z = 1, i = this._layerStates.length - 1; i >= 0; --i, ++z) {
            /** @type {?} */
            let layerState = this._layerStates[i];
            /** @type {?} */
            let layerInstance = this._layerCache[layerState.layer.id];
            if (layerInstance) {
                layerInstance.setZIndex(z);
                layerState.zIndex = z;
            }
        }
        this.touch('layers:changed', this.getLayers());
    }
    /**
     *
     * @param {?} id
     * @return {?}
     */
    removeLayer(id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            //remove layer from tracked defs array
            /** @type {?} */
            let index = this.getLayerStateIndex(id);
            // console.log("MapInstance.removeLayer(" + id + ")");
            if (index >= 0 && index < this._layerStates.length)
                this._layerStates.splice(index, 1);
            //stop listening for errors
            layerInstance.off("layer:error");
            //remove layer from map
            this._mapInstance.removeLayer(layerInstance);
            //remove layer from cache
            this._layerCache[id] = null;
        }
        this.touch('layers:changed');
    }
    /**
     *
     * @param {?} id
     * @return {?}
     */
    toggleLayerVisibility(id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            let state = this.getLayerState(id);
            state.visibility = !state.visibility;
            if (layerInstance._currentImage) {
                //ESRI Image Service layers have an IMG element
                // that gets modified and replaced every map event (zoom/pan)
                // so we can't just toggle classes like on other layers.
                //Instead, we need to use the ESRI setOpacity method to toggle
                // but need to update layer state as well.
                layerInstance.setOpacity(state.visibility ? 1 : 0);
                state.opacity = layerInstance.getOpacity();
                return;
            }
            this.setLayerVisibility(layerInstance, state.visibility);
        }
    }
    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} visible - flag indicating visibility of layer
     * @return {?}
     */
    setLayerVisibility(layerInstance, visible) {
        if (((/** @type {?} */ (layerInstance))).setVisibility) {
            //using custom method provided in src/layer/module.js
            ((/** @type {?} */ (layerInstance))).setVisibility(visible);
        }
        else if (((/** @type {?} */ (layerInstance)))._container) {
            //otherwise, using jquery on dom directly
            /** @type {?} */
            let el = jQuery(((/** @type {?} */ (layerInstance)))._container);
            // if(visible) el.removeClass("invisible");
            // else el.addClass('invisible');
            el.css({ 'display': visible ? '' : 'none' });
        }
        this.touch('map:layer:changed');
    }
    /**
     *
     * @param {?} id
     * @param {?} opacity
     * @return {?}
     */
    updateLayerOpacity(id, opacity) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        //if layer id is for base layer...
        if (!layerInstance && this._baseLayerDef.id === id) {
            layerInstance = this._baseLayer;
        }
        //adjust rendered leaflet layer
        opacity = this.setLayerOpacity(layerInstance, opacity);
        // if overlay layer, update state value
        /** @type {?} */
        let state = this.getLayerState(id);
        if (state)
            state.opacity = opacity;
    }
    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} opacity - value between 0 and 1.0 or 0 and 100
     * @return {?} normalized opacity value between 0 and 1.0
     */
    setLayerOpacity(layerInstance, opacity) {
        if (layerInstance && ((/** @type {?} */ (layerInstance))).setOpacity) {
            if (opacity > 1.0)
                opacity = opacity / 100.0;
            ((/** @type {?} */ (layerInstance))).setOpacity(opacity);
            this.touch('map:layer:changed');
        }
        return opacity;
    }
    /**
     * @param {?} gpLayer
     * @return {?} Leaflet layer instance representing that layer or null
     */
    getLeafletLayerFor(gpLayer) {
        if (!gpLayer || !this._layerCache)
            return null;
        /** @type {?} */
        let leafletLayer = this._layerCache[gpLayer.id];
        return leafletLayer || null;
    }
    /**
     *
     * @param {?} layerId
     * @return {?}
     */
    toggleGetFeatureInfo(layerId) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[layerId];
        if (layerInstance) {
            if (typeof (layerInstance.enableGetFeatureInfo) !== 'undefined') {
                if (layerInstance.isGetFeatureInfoEnabled()) {
                    layerInstance.disableGetFeatureInfo();
                    jQuery(((/** @type {?} */ (this._mapInstance)))._container).removeClass('selectable-cursor');
                }
                else {
                    layerInstance.enableGetFeatureInfo();
                    jQuery(((/** @type {?} */ (this._mapInstance)))._container).addClass('selectable-cursor');
                }
            }
        }
    }
    /* ==============================================
           Feature operations
           ============================================== */
    /**
     * @return {?} array of features on the map
     */
    getFeatures() {
        if (this._featureLayer) {
            /** @type {?} */
            let geojson = this._featureLayer.toGeoJSON();
            return ((/** @type {?} */ (geojson))).features;
        }
        return [];
    }
    /**
     * @param {?} json geojson object or array of geojson objects
     * @return {?}
     */
    addFeatures(json) {
        if (!json)
            return;
        if (typeof (json.push) !== 'undefined') {
            //array of features
            for (var i = 0; i < json.length; ++i)
                this.addFeature(json[i], false);
            this.touch('features:changed');
        }
        else if (json.features) {
            this.addFeatures(json.features);
        }
        else { //single feature
            this.addFeature(json, true);
        }
    }
    /**
     * @param {?} json geojson object
     * @param {?=} fireEvent
     * @return {?}
     */
    addFeature(json, fireEvent) {
        // var type = json.type;
        // var coordinates = json.coordinates;
        if (!this._featureLayer) {
            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);
            this._featureLayer = featureGroup().addTo(this._mapInstance);
        }
        // _featureLayer.addData(json);
        /** @type {?} */
        var opts = jQuery.extend({}, this._geoJsonLayerOpts);
        geoJSON(json, opts).eachLayer((/**
         * @param {?} l
         * @return {?}
         */
        (l) => this.addFeatureLayer(l)));
        if (typeof (fireEvent) === 'undefined' || fireEvent === true)
            this.touch('features:changed');
        else
            this.touch();
        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));
    }
    /**
     * @param {?} featureJson object defining a GeoJSON feature
     * @return {?}
     */
    updateFeature(featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            ((/** @type {?} */ (layer))).feature = featureJson;
            //update style
            layer.setStyle(featureJson.properties.style);
            //rebind label in case that changed
            /** @type {?} */
            var label = featureJson.properties.label ||
                "Untitled " + featureJson.geometry.type + " Feature";
            layer.bindTooltip(label);
            // layer.redraw();
            this.touch("map:feature:changed");
        }
    }
    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param {?} featureJson object defining GeoJSON feature
     * @return {?}
     */
    replaceFeature(featureJson) {
        //find existing layer for this feature
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            //remove existing
            this._featureLayer.removeLayer(layer);
            //add replacement
            geoJSON(featureJson, this._geoJsonLayerOpts)
                .eachLayer((/**
             * @param {?} l
             * @return {?}
             */
            (l) => this.addFeatureLayer(l)));
            this.touch("map:feature:changed");
        }
    }
    /**
     * @param {?} featureId identifier of feature to focus the map on
     * @return {?}
     */
    focusFeature(featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer) {
            if (typeof (layer.getBounds) !== 'undefined') {
                /** @type {?} */
                let extent = layer.getBounds();
                this._mapInstance.fitBounds(extent);
            }
            else if (typeof (((/** @type {?} */ (layer))).getLatLng) !== 'undefined') {
                /** @type {?} */
                let latLng = ((/** @type {?} */ (layer))).getLatLng();
                this._mapInstance.panTo(latLng);
            }
            else {
                console.log("MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng");
            }
        }
        else {
            console.log("MapInstance.focusFeature() - Cannot focus feature because it has no layer");
        }
    }
    /**
     * @param {?} featureId : string
     * @return {?}
     */
    removeFeature(featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer && this._featureLayer) {
            this._featureLayer.removeLayer(layer);
            this.touch('features:changed');
        }
    }
    /**
     *
     * @return {?}
     */
    removeFeatures() {
        if (this._featureLayer) {
            this._featureLayer.clearLayers();
            this.touch("features:changed");
        }
    }
    /**
     *
     * @param {?=} featureId
     * @return {?}
     */
    getFeatureLayer(featureId) {
        //if no feature was specified, return root feature layer
        if (!featureId)
            return this._featureLayer;
        //otherwise, find feature...
        if (!this._featureLayer)
            return null;
        /** @type {?} */
        var features = this._featureLayer.getLayers();
        for (var i = 0; i < features.length; ++i) {
            if (((/** @type {?} */ (features[i]))).feature &&
                ((/** @type {?} */ (features[i]))).feature.properties.id === featureId) {
                return ((/** @type {?} */ (features[i])));
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    toggleFeaturesLayer() {
        if (!this._featureLayer)
            return false; //ignore if not rendered yet
        this._featureLayerVisible = !this._featureLayerVisible;
        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);
        return this._featureLayerVisible;
    }
    /**
     * @param {?} feature - Leaflet feature instance
     * @param {?} visibility - flag
     * @return {?}
     */
    setFeatureVisibility(feature, visibility) {
        this.setFeatureLayerVisibility(feature, visibility);
    }
    /**
     * @return {?}
     */
    getFeaturesLayerVisibility() {
        return this._featureLayerVisible;
    }
    /*
         * method for adding feature layers to the map
         * when these layers may be layer groups.
         * finds leaf node layers and adds them to the
         * map's feature group
         */
    /**
     * @param {?} layer
     * @return {?}
     */
    addFeatureLayer(layer) {
        this._addFeatureLayer(layer);
        this.touch("features:changed");
    }
    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {?} layer
     * @return {?}
     */
    _addFeatureLayer(layer) {
        if (!((/** @type {?} */ (layer))).feature && layer instanceof LayerGroup) {
            layer.eachLayer((/**
             * @param {?} child
             * @return {?}
             */
            (child) => {
                this._addFeatureLayer(child);
            }));
        }
        else {
            this._featureLayer.addLayer(layer);
        }
    }
    //toggle visibility of parent feature layer
    /**
     * @param {?} layer
     * @param {?} visibility
     * @return {?}
     */
    setFeatureLayerVisibility(layer, visibility) {
        if (!layer)
            return;
        this._featureLayerVisible = visibility;
        if (layer.getLayers) {
            layer.getLayers().forEach((/**
             * @param {?} child
             * @return {?}
             */
            (child) => {
                this.setFeatureLayerVisibility(child, visibility);
            }));
        }
        else {
            /** @type {?} */
            let container = layer._container || layer._path;
            if (container)
                container.style.display = visibility ? '' : 'none';
        }
    }
    /* ==============================================
           Map lifecycle operations
           ============================================== */
    /**
     * @param {?} metadata
     * @return {?} resolving persisted map
     */
    save(metadata) {
        return this.saveMap(metadata);
    }
    /**
     * @param {?} md object containing metadata properties for map
     * @return {?}
     */
    saveMap(md) {
        /** @type {?} */
        let metadata = md || {};
        //add GeoPlatformMap resource type if not already present
        /** @type {?} */
        const gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';
        metadata.resourceTypes = metadata.resourceTypes || [];
        if (metadata.resourceTypes.indexOf(gpMapType) < 0)
            metadata.resourceTypes.push(gpMapType);
        /** @type {?} */
        var content = this.getMapResourceContent(metadata);
        //ensure the two name properties line up
        if (content.title && content.title !== content.label) {
            content.label = content.title;
        }
        else if (content.label && !content.title) {
            content.title = content.label;
        }
        // console.log("Updating: " + JSON.stringify(map));
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.getService(ItemTypes.MAP).save(content)
                .then((/**
             * @param {?} result
             * @return {?}
             */
            result => {
                //track new map's info so we can update it with next save
                if (!this._mapId)
                    this._mapId = result.id;
                this._mapDef = result;
                this._defaultExtent = result.extent;
                this.clean();
                resolve(result);
            }))
                .catch((/**
             * @param {?} err
             * @return {?}
             */
            err => {
                console.log("MapCore MapInstance.saveMap() - " +
                    "The requested map could not be saved because: " + err.message);
                /** @type {?} */
                let e = new Error("The requested map could not be saved because of the following error(s): " +
                    err.message);
                reject(e);
            }));
        }));
    }
    /**
     * Retrieve a map's descriptor from the registry
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    fetchMap(mapId) {
        //Having to send cache busting parameter to avoid CORS header cache
        // not sending correct Origin value
        return this.getService(ItemTypes.MAP).get(mapId);
    }
    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    loadMap(mapId) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.fetchMap(mapId).then((/**
             * @param {?} map
             * @return {?}
             */
            map => {
                if (!map) {
                    throw new Error("The requested map ('" + mapId +
                        "') came back null");
                }
                else if (typeof (map) === 'string') {
                    throw new Error("The requested map ('" + mapId +
                        "') came back as a string");
                }
                else if (((/** @type {?} */ (map))).message) {
                    throw new Error("There was an error loading the requested map ('" +
                        mapId + "'): " + ((/** @type {?} */ (map))).message);
                }
                //loading a map by its ID, so we need to increment it's view count
                if ('development' !== Config.env) {
                    setTimeout((/**
                     * @param {?} map
                     * @return {?}
                     */
                    (map) => {
                        //update view count
                        /** @type {?} */
                        let views = map.statistics ? (map.statistics.numViews || 0) : 0;
                        /** @type {?} */
                        let patch = [{ op: 'replace', path: '/statistics/numViews', value: views + 1 }];
                        this.getService(ItemTypes.MAP).patch(map.id, patch)
                            // this.mapService.patch(map.id, patch)
                            .then((/**
                         * @param {?} updated
                         * @return {?}
                         */
                        updated => { map.statistics = updated.statistics; }))
                            .catch((/**
                         * @param {?} e
                         * @return {?}
                         */
                        e => {
                            console.log("MapInstance.loadMap() - Error updating view " +
                                "count for map ('" + mapId + "'): " + e);
                        }));
                    }), 1000, map);
                }
                //load the map into the viewer
                this.loadMapFromObj(map);
                resolve(map);
            }))
                .catch((/**
             * @param {?} err
             * @return {?}
             */
            err => {
                console.log("MapInstance.loadMap() - " +
                    "The requested map could not be loaded because " + err.message);
                /** @type {?} */
                let e = new Error("The requested map ('" + mapId +
                    "') could not be loaded because of the following error(s): " +
                    err.message);
                reject(e);
            }));
        }));
    }
    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param {?} map object
     * @return {?}
     */
    loadMapFromObj(map) {
        // console.log("Loading Map Object");
        // console.log(map);
        this._mapId = map.id;
        this._mapDef = map;
        map.extent = this.ensureExtent(map.extent);
        //set extent from loaded map
        this._defaultExtent = map.extent;
        /** @type {?} */
        var extent = map.extent;
        //remove existing layers
        this._mapInstance.eachLayer((/**
         * @param {?} l
         * @return {?}
         */
        (l) => {
            this._mapInstance.removeLayer(l);
        }));
        this._layerCache = {};
        this._layerStates = [];
        //set new base layer
        this.setBaseLayer(map.baseLayer);
        //add layers from loaded map
        this.addLayers(map.layers);
        //add features
        if (map.annotations && map.annotations.geoJSON) {
            /** @type {?} */
            let fc = map.annotations.geoJSON;
            if (fc.features)
                this.addFeatures(fc.features);
            else
                this.addFeatures([fc]);
        }
        this._mapInstance.fitBounds([
            [extent.miny, extent.minx],
            [extent.maxy, extent.maxx]
        ]);
        this.clean();
        this.notify('map:loaded', map);
    }
    /**
     * @param {?} extent
     * @return {?} corrected or default extent
     */
    ensureExtent(extent) {
        /** @type {?} */
        let west = !extent || isNaN(extent.minx) ? -179.0 : extent.minx * 1.0;
        /** @type {?} */
        let east = !extent || isNaN(extent.maxx) ? 179.0 : extent.maxx * 1.0;
        /** @type {?} */
        let south = !extent || isNaN(extent.miny) ? -89.0 : extent.miny * 1.0;
        /** @type {?} */
        let north = !extent || isNaN(extent.maxy) ? 89.0 : extent.maxy * 1.0;
        //ensure x,y is ordered correctly
        /** @type {?} */
        let t;
        if (west > east) {
            t = Math.min(west, east);
            east = Math.max(west, east);
            west = t;
        }
        if (south > north) {
            t = Math.min(south, north);
            north = Math.max(south, north);
            south = t;
        }
        //prevent out-of-bounds extents
        if (west < -180.0)
            west = -179.0;
        if (east > 180.0)
            east = 179.0;
        if (south < -90.0)
            south = -89.0;
        if (north > 90.0)
            north = 89.0;
        return { minx: west, miny: south, maxx: east, maxy: north };
    }
    /**
     *
     * @return {?}
     */
    destroyMap() {
        // console.log("Destroying Map");
        this._mapInstance = null;
        this._layerCache = null;
        this._layerStates = null;
        this._featureLayer = null;
    }
    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     * @param {?} mapToUse
     * @return {?}
     */
    setAsNewMap(mapToUse) {
        this._mapId = null;
        this._mapDef = mapToUse || this.initializeMapDefinition();
    }
    /* ==============================================
            Tool operations
           ============================================== */
    /**
     * @param {?} id
     * @param {?} tool
     * @return {?}
     */
    registerTool(id, tool) {
        this._tools[id] = tool;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    unregisterTool(id) {
        this._tools[id] = null;
    }
    /**
     * @param {?} id
     * @param {?} finish
     * @return {?}
     */
    enableTool(id, finish) {
        if (!this._tools[id])
            return false;
        this._tools[id].activate((/**
         * @return {?}
         */
        function () {
            this.notify('tool:disabled', id);
        }));
        this.notify('tool:enabled', id);
    }
    /* ----------- MISC ------------ */
    //https://github.com/gsklee/ngStorage
    /**
     * @return {?}
     */
    cacheMap() {
        if (this.state && this.state.dirty) {
            /** @type {?} */
            var map = this.getMapResourceContent();
            //use exploded layer info
            map.layers = this._layerStates.slice(0);
            // $sessionStorage.map = map;
        }
    }
    /**
     * @return {?}
     */
    restoreMap() {
        // if($sessionStorage.map) {
        //     console.log("Restoring cached map");
        //     let map = $sessionStorage.map;
        //     // console.log(JSON.stringify(map));
        //     $sessionStorage.map = null;
        //     this.loadMapFromObj(map);
        // }
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype.svcCache;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype.serviceFactory;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype.httpClient;
    /** @type {?} */
    MapInstance.prototype._key;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._mapId;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._mapDef;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._mapInstance;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._defaultExtent;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._baseLayerDef;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._baseLayer;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._layerStates;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._layerCache;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._layerErrors;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._layerErrorHandler;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._featureLayer;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._featureLayerVisible;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._tools;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype.state;
    /**
     * @type {?}
     * @private
     */
    MapInstance.prototype._geoJsonLayerOpts;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdGFuY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ2VvcGxhdGZvcm0vbWFwY29yZS8iLCJzb3VyY2VzIjpbIm1hcC9pbnN0YW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBRUEsT0FBTyxLQUFLLE1BQU0sTUFBTSxRQUFRLENBQUM7O01BQzNCLE1BQU0sR0FBRyxNQUFNO0FBSXJCLE9BQU8sRUFFSCxZQUFZLEVBQUUsT0FBTyxFQUNyQixZQUFZLEVBQWdCLFVBQVUsRUFDekMsTUFBTSxTQUFTLENBQUM7QUFFakIsT0FBTyxFQUNILE1BQU0sRUFBRSxTQUFTLEVBQ2pCLGNBQWMsRUFDZCxhQUFhLEVBQ2hCLE1BQU0scUJBQXFCLENBQUM7QUFFN0IsT0FBTyxZQUFZLE1BQU0sa0JBQWtCLENBQUM7QUFFNUMsT0FBTyxnQkFBZ0IsTUFBTSw0QkFBNEIsQ0FBQztBQUcxRCxNQUFNLFFBQVE7SUFJVjtRQUNJLDJDQUEyQztRQUMzQyxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUN6QixDQUFDOzs7Ozs7SUFFRCxFQUFFLENBQUUsSUFBSSxFQUFFLFFBQVE7UUFDZCxJQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7WUFDckIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDekMsQ0FBQzs7Ozs7O0lBRUQsR0FBRyxDQUFFLElBQUksRUFBRSxRQUFRO1FBQ2YsSUFBRyxDQUFDLElBQUk7WUFBRSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUMvQixJQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPO1FBQ2xDLElBQUcsQ0FBQyxRQUFRO1lBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FB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eEMsNkJBQWdDOzs7OztJQUNoQyw0QkFBOEI7Ozs7O0lBQzlCLHdDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG5pbXBvcnQgKiBhcyBqcXVlcnkgZnJvbSBcImpxdWVyeVwiO1xuY29uc3QgalF1ZXJ5ID0ganF1ZXJ5O1xuXG5pbXBvcnQgKiBhcyBRIGZyb20gXCJxXCI7XG5pbXBvcnQgKiBhcyBnZW9qc29uIGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHtcbiAgICBNYXAsIExheWVyLCBMYXRMbmcsIExhdExuZ0JvdW5kcyxcbiAgICBjaXJjbGVNYXJrZXIsIGdlb0pTT04sXG4gICAgZmVhdHVyZUdyb3VwLCBGZWF0dXJlR3JvdXAsIExheWVyR3JvdXBcbn0gZnJvbSAnbGVhZmxldCc7XG5cbmltcG9ydCB7XG4gICAgQ29uZmlnLCBJdGVtVHlwZXMsXG4gICAgU2VydmljZUZhY3RvcnksIEl0ZW1TZXJ2aWNlLCBNYXBTZXJ2aWNlLCBMYXllclNlcnZpY2UsXG4gICAgWEhSSHR0cENsaWVudFxufSBmcm9tICdAZ2VvcGxhdGZvcm0vY2xpZW50JztcblxuaW1wb3J0IExheWVyRmFjdG9yeSBmcm9tICcuLi9sYXllci9mYWN0b3J5JztcbmltcG9ydCBPU00gZnJvbSBcIi4uL2xheWVyL29zbVwiO1xuaW1wb3J0IERlZmF1bHRCYXNlTGF5ZXIgZnJvbSAnLi4vbGF5ZXIvYmFzZWxheWVyLWRlZmF1bHQnO1xuXG5cbmNsYXNzIExpc3RlbmVyIHtcblxuICAgIF9saXN0ZW5lcnMgOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy9saXN0ZW5lcnMgdG8gYmUgdW5yZWdpc3RlcmVkIHVwb24gZGVzdHJveVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG5cbiAgICBvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSlcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgb2ZmICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZighdHlwZSkgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgIGlmKCF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pIHJldHVybjtcbiAgICAgICAgaWYoIWxpc3RlbmVyKSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYoaWR4ID49IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm90aWZ5KHR5cGUsIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSkgcmV0dXJuO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHsgbC5hcHBseShudWxsLCBhcmdzKTsgfSk7XG4gICAgfVxuXG59XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBJbnN0YW5jZSBleHRlbmRzIExpc3RlbmVyIHtcblxuICAgIHByaXZhdGUgc3ZjQ2FjaGUgICAgICAgIDogYW55O1xuICAgIHByaXZhdGUgc2VydmljZUZhY3RvcnkgIDogYW55O1xuICAgIHByaXZhdGUgaHR0cENsaWVudCAgICAgIDogYW55O1xuICAgIHB1YmxpYyBfa2V5ICAgICAgICAgICAgOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfbWFwSWQgICAgICAgICAgOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfbWFwRGVmICAgICAgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfbWFwSW5zdGFuY2UgICAgOiBNYXA7XG4gICAgcHJpdmF0ZSBfZGVmYXVsdEV4dGVudCAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfYmFzZUxheWVyRGVmICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfYmFzZUxheWVyICAgICAgOiBMYXllcjtcbiAgICBwcml2YXRlIF9sYXllclN0YXRlcyAgICA6IGFueTtcbiAgICBwcml2YXRlIF9sYXllckNhY2hlICAgICA6IGFueTtcbiAgICBwcml2YXRlIF9sYXllckVycm9ycyAgICA6IGFueVtdO1xuICAgIHByaXZhdGUgX2xheWVyRXJyb3JIYW5kbGVyIDogRnVuY3Rpb247XG4gICAgcHJpdmF0ZSBfZmVhdHVyZUxheWVyICAgOiBGZWF0dXJlR3JvdXA7XG4gICAgcHJpdmF0ZSBfZmVhdHVyZUxheWVyVmlzaWJsZSAgOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3Rvb2xzICAgICAgICAgIDogYW55W107XG4gICAgcHJpdmF0ZSBzdGF0ZSAgICAgICAgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfZ2VvSnNvbkxheWVyT3B0cyA6IGFueTtcblxuXG5cblxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuc2V0SHR0cENsaWVudChuZXcgWEhSSHR0cENsaWVudCgpKTtcbiAgICAgICAgdGhpcy5zZXRTZXJ2aWNlRmFjdG9yeShTZXJ2aWNlRmFjdG9yeSk7XG5cbiAgICAgICAgLy9nZW5lcmF0ZSByYW5kb20ga2V5IChzZWUgZmFjdG9yeSBiZWxvdylcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5IHx8IE1hdGguY2VpbChNYXRoLnJhbmRvbSgpKjk5OTkpO1xuXG4gICAgICAgIC8vcmVnaXN0cnkgaWQgb2YgY3VycmVudCBtYXAgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRoaXMuX21hcElkID0gbnVsbCxcblxuICAgICAgICAvL2RlZmluaXRpb24gb2YgbWFwIChpZSwgZnJvbSBzZXJ2ZXIpXG4gICAgICAgIHRoaXMuX21hcERlZiA9IHRoaXMuaW5pdGlhbGl6ZU1hcERlZmluaXRpb24oKSxcblxuICAgICAgICAvL3ByaW1hcnkgbWFwIGluc3RhbmNlIChpZSwgbGVhZmxldClcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UgPSBudWxsLFxuXG4gICAgICAgIC8vZGVmYXVsdCBtYXAgZXh0ZW50IChpZiBtYXAgZG9lc24ndCBoYXZlIG9uZSBmb3IgYmVpbmcgc2F2ZWQpXG4gICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSBudWxsLFxuXG4gICAgICAgIC8vY3VycmVudCBiYXNlIGxheWVyIG9iamVjdCBhbmQgbGVhZmxldCBpbnN0YW5jZVxuICAgICAgICB0aGlzLl9iYXNlTGF5ZXJEZWYgPSBudWxsLFxuICAgICAgICB0aGlzLl9iYXNlTGF5ZXIgPSBudWxsLFxuXG4gICAgICAgIC8vc2V0IGRlZmluaXRpb25zIG9mIGxheWVyIHN0YXRlcyAoaW5jbHVkaW5nIGxheWVyIGluZm8pIG9uIG1hcFxuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IFtdLFxuXG4gICAgICAgIC8vbWFwIGxheWVyIGRlZiBpZHMgd2l0aCBsZWFmbGV0IGluc3RhbmNlc1xuICAgICAgICB0aGlzLl9sYXllckNhY2hlID0ge30sXG5cbiAgICAgICAgLy9lcnJvcnMgZ2VuZXJhdGVkIGJ5IGxheWVycyBsb2FkaW5nXG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JzPSBbXSxcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTWFwSW5zdGFuY2UuZGVmYXVsdExheWVyRXJyb3JIYW5kbGVyKCkgLSAke2UuaWR9IDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9sYXllciB1c2VkIHRvIHN0b3JlIGZlYXR1cmVzIG9uIG1hcFxuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIgPSBudWxsLFxuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlID0gdHJ1ZSxcblxuICAgICAgICAvL3NldCBvZiByZWdpc3RlcmVkIG1hcCB0b29sc1xuICAgICAgICB0aGlzLl90b29scyA9IFtdLFxuXG4gICAgICAgIC8vc3RhdGUgbWFuYWdlbWVudFxuICAgICAgICB0aGlzLnN0YXRlID0geyBkaXJ0eTogZmFsc2UgfTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgICAgdGhpcy5fZ2VvSnNvbkxheWVyT3B0cyAgPSB7XG4gICAgICAgICAgICBzdHlsZTogZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGlmKGZlYXR1cmUucHJvcGVydGllcy5zdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVhY2hGZWF0dXJlOiBmdW5jdGlvbihmZWF0dXJlLCBsYXllcikge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0geyB3ZWlnaHQ6IDIsIGNvbG9yOiAnIzAzZicsIG9wYWNpdHk6IDAuOSwgcmFkaXVzOiA0LCBmaWxsQ29sb3I6ICcjMDNmJywgZmlsbE9wYWNpdHk6IDAuNSB9O1xuICAgICAgICAgICAgICAgIGlmKH5mZWF0dXJlLmdlb21ldHJ5LnR5cGUuaW5kZXhPZignUG9pbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5maWxsT3BhY2l0eSA9IDAuOTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmZWF0dXJlLnByb3BlcnRpZXMgPSBmZWF0dXJlLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgICAgICAgICAgaWYoZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID09PSB1bmRlZmluZWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOTk5OTk5KTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMubGFiZWwgPSBwcm9wcy5sYWJlbCB8fCBwcm9wcy50aXRsZSB8fCBwcm9wcy5uYW1lIHx8IFwiVW50aXRsZWQgXCIgKyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgKyBcIiBGZWF0dXJlXCI7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uID0gcHJvcHMuZGVzY3JpcHRpb24gfHwgcHJvcHMuZGVzYyB8fCBcIlRoaXMgZmVhdHVyZSBuZWVkcyBhIGRlc2NyaXB0aW9uIVwiO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZSA9IHByb3BzLnN0eWxlIHx8IHN0eWxlO1xuXG4gICAgICAgICAgICAgICAgbGF5ZXIuYmluZFRvb2x0aXAocHJvcHMubGFiZWwpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgdG9nZ2xlOiBzZXRMYWJlbE5vSGlkZShib29sKVxuICAgICAgICAgICAgICAgIGl0IG1heSBvbmx5IGV4aXN0IG9uIG1hcmtlcnMhXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludFRvTGF5ZXI6IGZ1bmN0aW9uIChmZWF0dXJlIDogYW55LCBsYXRsbmcgOiBMYXRMbmcgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHN0eWxlLnJhZGl1cyA9IHN0eWxlLnJhZGl1cyB8fCA0O1xuICAgICAgICAgICAgICAgIHN0eWxlLndlaWdodCA9IHN0eWxlLndlaWdodCB8fCAyO1xuICAgICAgICAgICAgICAgIHN0eWxlLmNvbG9yID0gc3R5bGUuY29sb3IgfHwgJyMwM2YnO1xuICAgICAgICAgICAgICAgIHN0eWxlLm9wYWNpdHkgPSBzdHlsZS5vcGFjaXR5IHx8IDAuOTtcbiAgICAgICAgICAgICAgICBzdHlsZS5maWxsT3BhY2l0eSA9IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgc3R5bGUuZmlsbENvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcmNsZU1hcmtlcihsYXRsbmcsIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBkaXNwb3NlICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95TWFwKCk7XG4gICAgICAgIHRoaXMuc3ZjQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZpY2VGYWN0b3J5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fa2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXBEZWYgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9iYXNlTGF5ZXJEZWYgPSBudWxsO1xuICAgICAgICB0aGlzLl9iYXNlTGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllckVycm9ycz0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Rvb2xzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dlb0pzb25MYXllck9wdHMgPSBudWxsO1xuICAgIH1cblxuXG4gICAgZ2V0S2V5ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBkZWZhdWx0IChKUXVlcnktYmFzZWQpIG1hcCBzZXJ2aWNlIHVzZWQgYnkgdGhpcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtYXBTZXJ2aWNlIC0gc2VydmljZSB0byB1c2UgdG8gQ1JVRCBtYXAgb2JqZWN0c1xuICAgICAqIEBkZXByZWNhdGVkIHVzZSBzZXRTZXJ2aWNlRmFjdG9yeSBpbnN0ZWFkXG4gICAgICovXG4gICAgc2V0U2VydmljZShtYXBTZXJ2aWNlIDogTWFwU2VydmljZSkge1xuICAgICAgICAvLyB0aGlzLm1hcFNlcnZpY2UgPSBtYXBTZXJ2aWNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmYWN0b3J5IC0gR2VvUGxhdGZvcm0gU2VydmljZUZhY3RvcnkgdG8gaW5zdGFudGlhdGUgc2VydmljZXMgZm9yIG1hcHMgYW5kIGxheWVyc1xuICAgICAqL1xuICAgIHNldFNlcnZpY2VGYWN0b3J5KGZhY3RvcnkgOiBhbnkpIHtcbiAgICAgICAgdGhpcy5zdmNDYWNoZSA9IHt9OyAvL3dpcGUgb3V0IGNhY2hlZCBzZXJ2aWNlc1xuICAgICAgICB0aGlzLnNlcnZpY2VGYWN0b3J5ID0gZmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaHR0cENsaWVudCAtIEh0dHBDbGllbnQgaW1wbCB0byB1c2Ugd2l0aCB0aGUgbmV3IGZhY3RvcnlcbiAgICAgKi9cbiAgICBzZXRIdHRwQ2xpZW50KGh0dHBDbGllbnQgOiBhbnkpIHtcbiAgICAgICAgdGhpcy5zdmNDYWNoZSA9IHt9OyAvL3dpcGUgb3V0IGNhY2hlZCBzZXJ2aWNlc1xuICAgICAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gR2VvUGxhdGZvcm0gT2JqZWN0IG1vZGVsIHR5cGUgdG8gc3VwcG9ydCAoXCJNYXBcIiwgXCJMYXllclwiLCBldGMpXG4gICAgICogQHJldHVybiBpdGVtIHNlcnZpY2UgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZXF1ZXN0ZWQgdHlwZVxuICAgICAqL1xuICAgIGdldFNlcnZpY2UodHlwZSA6IHN0cmluZykgOiBJdGVtU2VydmljZSB7XG4gICAgICAgIGlmKCF0aGlzLnN2Y0NhY2hlW3R5cGVdKVxuICAgICAgICAgICAgdGhpcy5zdmNDYWNoZVt0eXBlXSA9IHRoaXMuc2VydmljZUZhY3RvcnkodHlwZSwgQ29uZmlnLnVhbFVybCwgdGhpcy5odHRwQ2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZjQ2FjaGVbdHlwZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZuIC0gY2FsbGJhY2sgd2hlbiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZFxuICAgICAqL1xuICAgIHNldEVycm9ySGFuZGxlcihmbikge1xuICAgICAgICB0aGlzLl9sYXllckVycm9ySGFuZGxlciA9IGZuO1xuICAgIH1cblxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldExheWVyU3RhdGVJbmRleCAobGF5ZXJJZCkge1xuICAgICAgICBpZighbGF5ZXJJZCkgcmV0dXJuIC0xO1xuICAgICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLl9sYXllclN0YXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYodGhpcy5fbGF5ZXJTdGF0ZXNbaV0ubGF5ZXIgJiYgbGF5ZXJJZCA9PT0gdGhpcy5fbGF5ZXJTdGF0ZXNbaV0ubGF5ZXIuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLl9sYXllclN0YXRlcy5pbmRleE9mT2JqKGxheWVySWQsIChpZCwgc3RhdGUpID0+IHN0YXRlLmxheWVyLmlkID09PSBpZCApO1xuICAgIH1cblxuICAgIGdldExheWVyU3RhdGUgKGxheWVySWQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRMYXllclN0YXRlSW5kZXgobGF5ZXJJZCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdGhpcy5fbGF5ZXJTdGF0ZXNbaW5kZXhdIDogbnVsbDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICBpbml0aWFsaXplTWFwRGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IEl0ZW1UeXBlcy5NQVAsXG4gICAgICAgICAgICB0aXRsZTogXCJNeSBOZXcgTWFwXCIsXG4gICAgICAgICAgICBsYWJlbDogXCJNeSBOZXcgTWFwXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGlzIG1hcCBuZWVkcyBhIGRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBjcmVhdGVkQnk6IG51bGwsXG4gICAgICAgICAgICBiYXNlTGF5ZXI6IHRoaXMuX2Jhc2VMYXllckRlZixcbiAgICAgICAgICAgIGxheWVyczogW10sXG4gICAgICAgICAgICBrZXl3b3JkczogW10sXG4gICAgICAgICAgICB0aGVtZXM6IFtdLFxuICAgICAgICAgICAgcmVzb3VyY2VUeXBlczogWydodHRwOi8vd3d3Lmdlb3BsYXRmb3JtLmdvdi9vbnQvb3Blbm1hcC9HZW9wbGF0Zm9ybU1hcCddXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gb2JqZWN0IGRlZmluaXRpb24gb2YgdGhlIGN1cnJlbnQgbWFwIHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIFdNVlJcbiAgICAgKi9cbiAgICBnZXRNYXBSZXNvdXJjZUNvbnRlbnQobWV0YWRhdGEgPzogYW55KSB7XG5cbiAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YSB8fCB7fTtcblxuICAgICAgICAvL21hcCBsYXllcnNcbiAgICAgICAgbWV0YWRhdGEubGF5ZXJzID0gdGhpcy5fbGF5ZXJTdGF0ZXMubWFwKHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eSA6IHN0YXRlLnZpc2liaWxpdHkgfHwgdHJ1ZSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5IDogaXNOYU4oc3RhdGUub3BhY2l0eSkgPyAxLjAgOiBzdGF0ZS5vcGFjaXR5KjEsXG4gICAgICAgICAgICAgICAgbGF5ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHN0YXRlLmxheWVyLmlkLFxuICAgICAgICAgICAgICAgICAgICB1cmk6IHN0YXRlLmxheWVyLnVyaSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHN0YXRlLmxheWVyLmxhYmVsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAuLi4gVUFMIHNob3VsZCBzdXBwb3J0IGFjY2VwdGluZyBqdXN0IGFuIGlkIGhlcmUsIHNvIHdlJ2xsIGRvIGp1c3QgdGhhdFxuICAgICAgICBtZXRhZGF0YS5iYXNlTGF5ZXIgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5fYmFzZUxheWVyRGVmLmlkLFxuICAgICAgICAgICAgdXJpOiB0aGlzLl9iYXNlTGF5ZXJEZWYudXJpLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMuX2Jhc2VMYXllckRlZi5sYWJlbFxuICAgICAgICB9O1xuXG4gICAgICAgIG1ldGFkYXRhLmFubm90YXRpb25zID0gdGhpcy5fZmVhdHVyZUxheWVyID9cbiAgICAgICAgICAgIHsgdGl0bGU6IFwiTWFwIEZlYXR1cmVzXCIsIGdlb0pTT046IHRoaXMuX2ZlYXR1cmVMYXllci50b0dlb0pTT04oKSB9IDogbnVsbDtcblxuICAgICAgICAvL2dlb2dyYXBoaWMgZXh0ZW50XG4gICAgICAgIGxldCBleHRlbnQgPSB0aGlzLl9tYXBJbnN0YW5jZS5nZXRCb3VuZHMoKTtcbiAgICAgICAgbWV0YWRhdGEuZXh0ZW50ID0ge1xuICAgICAgICAgICAgbWlueDogZXh0ZW50LmdldFdlc3QoKSxcbiAgICAgICAgICAgIG1pbnk6IGV4dGVudC5nZXRTb3V0aCgpLFxuICAgICAgICAgICAgbWF4eDogZXh0ZW50LmdldEVhc3QoKSxcbiAgICAgICAgICAgIG1heHk6IGV4dGVudC5nZXROb3J0aCgpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gTGVhZmxldCB0b29sYmFyXG4gICAgICovXG4gICAgZ2V0RHJhd0NvbnRyb2xUb29sYmFyKCkge1xuICAgICAgICBpZighKHRoaXMuX21hcEluc3RhbmNlIGFzIGFueSkuZHJhd0NvbnRyb2wpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgdG9vbGJhcnMgPSAodGhpcy5fbWFwSW5zdGFuY2UgYXMgYW55KS5kcmF3Q29udHJvbC5fdG9vbGJhcnM7XG4gICAgICAgIHZhciB0b29sYmFyID0gbnVsbDtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdG9vbGJhcnMpIHtcbiAgICAgICAgICAgIGlmKHRvb2xiYXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZih0b29sYmFyc1trZXldLl9tb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyID0gdG9vbGJhcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b29sYmFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBlcnJvciBMZWFmbGV0IHRpbGUgbG9hZCBlcnJvciAoLnRhcmdldCBpcyBsYXllciwgLnRpbGUgaXMgaW1hZ2UpXG4gICAgICovXG4gICAgaGFuZGxlTGF5ZXJFcnJvcihlcnJvcikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmhhbmRsZUxheWVyRXJyb3IoKSAtIFwiICtcbiAgICAgICAgLy8gICAgIFwiTGF5ZXIncyB0aWxlIGZhaWxlZCB0byBsb2FkOiBcIiArIGVycm9yLnRpbGUuc3JjKTtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5hYmxlIHRvIGZpbmQgbGF5ZXIgaW4gbGF5ZXIgY2FjaGUuIExheWVyIGVycm9yIGlzIFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXllciA9IGVycm9yLnRhcmdldDtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLl9sYXllckNhY2hlKSB7XG4gICAgICAgICAgICBpZih0aGlzLl9sYXllckNhY2hlW2lkXSA9PT0gbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NMYXllckVycm9yKGVycm9yLCBpZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIExlYWZsZXQgdGlsZSBsb2FkIGVycm9yIGFuZCB0aGUgcmVzcG9uc2libGUgbGF5ZXIgaWQsXG4gICAgICogVHJ5IHRvIGlzb2xhdGUgdGhlIGNhdXNlIG9mIHRoZSBlcnJvciB1c2luZyB0aGUgcHJveHlcbiAgICAgKiBhbmQgbm90aWZ5IGxpc3RlbmVycyB0aGF0IGFuIGVycm9yIGhhcyBvY2N1cnJlZFxuICAgICAqL1xuICAgIHByb2Nlc3NMYXllckVycm9yKGVycm9yIDogRXJyb3IsIGlkIDogc3RyaW5nKSB7XG5cbiAgICAgICAgdmFyIGZpbmRlciA9IChsKSA9PiB7IHJldHVybiBsLmlkID09PSBpZCB8fCAobC5sYXllciAmJiBsLmxheWVyLmlkID09PSBpZCk7IH07XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyRXJyb3JzLmZpbmQoZmluZGVyKSkge1xuXG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5sb2dMYXllckVycm9yKGlkLCBcIkxheWVyICgnXCIgKyBpZCArIFwiJykgZmFpbGVkIHRvIGNvbXBsZXRlbHkgbG9hZC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiSXQgbWF5IGJlIGluYWNjZXNzaWJsZSBvciBtaXNjb25maWd1cmVkLlwiKTtcblxuICAgICAgICAgICAgdmFyIHVybCA9IChlcnJvciBhcyBhbnkpLnRpbGUuc3JjO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtpZDppZH07XG4gICAgICAgICAgICB1cmwuc3Vic3RyaW5nKHVybC5pbmRleE9mKFwiP1wiKSsxLCB1cmwubGVuZ3RoKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhcmFtLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3BbMF1dID0gcFsxXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgbGF5ZXJTZXJ2aWNlID0gdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5MQVlFUikgYXMgTGF5ZXJTZXJ2aWNlO1xuICAgICAgICAgICAgaWYobGF5ZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJTZXJ2aWNlLnZhbGlkYXRlKGlkLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gdGhpcy5fbGF5ZXJTdGF0ZXMuZmluZChmaW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZihkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5tZXNzYWdlID0gXCJMYXllciAnXCIgKyBkZWYubGF5ZXIubGFiZWwgKyBcIicgZmFpbGVkIHRvIGNvbXBsZXRlbHkgbG9hZC4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlJlcG9ydGVkIGNhdXNlOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeSgnbGF5ZXI6ZXJyb3InLCBvYmopO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxheWVySWQgLSBpZGVudGlmaWVyIG9mIGxheWVyIGdlbmVyYXRpbmcgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIGVycm9yTXNnIC0gbWVzc2FnZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBsb2dMYXllckVycm9yKGxheWVySWQsIGVycm9yTXNnKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UubG9nTGF5ZXJFcnJvcigpIC0gbGF5ZXIgXCIgICsgaWQgK1xuICAgICAgICAvLyAgICAgXCIgZ2VuZXJhdGVkIGVycm9yICdcIiArIGVycm9yTXNnICsgXCInXCIpO1xuICAgICAgICBsZXQgZXJyID0geyBpZDogbGF5ZXJJZCwgbWVzc2FnZTogZXJyb3JNc2cgfTtcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICBpZih0aGlzLl9sYXllckVycm9ySGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJFcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIC8qIC0tIFN0YXRlIE1hbmFnZW1lbnQgb2YgaW50ZXJuYWwgbW9kZWwgLS0gKi9cblxuICAgIHRvdWNoIChldmVudCA/OiBhbnksIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmKGV2ZW50KSB7XG4gICAgICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5LmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoZXZlbnQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJEaXJ0eWluZyBtYXAgZm9yIFwiICsgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgY29uc29sZS5sb2coXCJEaXJ0eWluZyBtYXBcIik7XG4gICAgfVxuICAgIGNsZWFuKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNsZWFuaW5nIG1hcFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgTWFwIG1hbmlwdWxhdGlvbiBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgc2V0TWFwIChtYXAgOiBNYXApIHsgdGhpcy5fbWFwSW5zdGFuY2UgPSBtYXA7IH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gIG1hcCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldE1hcCAoKSA6IE1hcCB7IHJldHVybiB0aGlzLl9tYXBJbnN0YW5jZTsgfVxuXG4gICAgLyoqIEByZXR1cm4gZGVmaW5pdGlvbiBvZiBtYXAgKi9cbiAgICBnZXRNYXBEZWZpbml0aW9uICgpIDogYW55IHsgcmV0dXJuIHRoaXMuX21hcERlZjsgfVxuXG4gICAgLyoqIEByZXR1cm4gaWRlbnRpZmllciBvZiBtYXAgKi9cbiAgICBnZXRNYXBJZCAoKSA6IHN0cmluZyB7IHJldHVybiB0aGlzLl9tYXBJZDsgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbWFwIG9uIHRoZSBzcGVjaWZpZWQgbGF0L2xuZyBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIGxhdCBudW1iZXJcbiAgICAgKiBAcGFyYW0gbG5nIG51bWJlclxuICAgICAqIEBwYXJhbSB6b29tIG51bWJlciAob3B0aW9uYWwpXG4gICAgICovXG4gICAgc2V0VmlldyAobGF0IDogbnVtYmVyLCBsbmcgOiBudW1iZXIsIHpvb20gPzogbnVtYmVyKSB7XG4gICAgICAgIGxldCB6ID0gem9vbTtcbiAgICAgICAgaWYodHlwZW9mKHopID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHogPSB0aGlzLl9tYXBJbnN0YW5jZS5nZXRab29tKCk7XG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnNldFZpZXcoW2xhdCxsbmddLCB6KTtcbiAgICAgICAgdGhpcy50b3VjaCgnbWFwOnZpZXc6Y2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGNlbnRlciBvZiB0aGUgbWFwXG4gICAgICogQHJldHVybiBbbGF0LGxuZ11cbiAgICAgKi9cbiAgICBnZXRWaWV3ICgpIDogbnVtYmVyW10ge1xuICAgICAgICB2YXIgbGF0TG5nID0gdGhpcy5fbWFwSW5zdGFuY2UuZ2V0Q2VudGVyKCk7XG4gICAgICAgIHJldHVybiBbbGF0TG5nLmxhdCwgbGF0TG5nLmxuZ107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBpbnRlZ2VyIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwXG4gICAgICovXG4gICAgZ2V0Wm9vbSAoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBJbnN0YW5jZS5nZXRab29tKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0byB0aGUgbWFwJ3MgZGVmYXVsdCBleHRlbnRcbiAgICAgKiBJZiB0aGUgbWFwIGlzIHNhdmVkLCB0aGlzIHdpbGwgYmUgdGhlIHNhdmVkIHZpZXdwb3J0XG4gICAgICogb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIENPTlVTXG4gICAgICovXG4gICAgem9vbVRvRGVmYXVsdCAoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9tYXBJbnN0YW5jZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLl9kZWZhdWx0RXh0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoW1xuICAgICAgICAgICAgICAgIFt0aGlzLl9kZWZhdWx0RXh0ZW50Lm1pbnksIHRoaXMuX2RlZmF1bHRFeHRlbnQubWlueF0sXG4gICAgICAgICAgICAgICAgW3RoaXMuX2RlZmF1bHRFeHRlbnQubWF4eSwgdGhpcy5fZGVmYXVsdEV4dGVudC5tYXh4XVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLnpvb21Ub0RlZmF1bHQoKSAtIE5vIGRlZmF1bHQgZXh0ZW50IHNwZWNpZmllZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnNldFZpZXcoWzM4LCAtOTZdLCA1KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnbWFwOnZpZXc6Y2hhbmdlZCcpO1xuICAgICAgICB9IGNhdGNoKGUpIHsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBleHRlbnQgLSBlaXRoZXIgYSBHUCBleHRlbnQgb2JqZWN0IG9yIExlYWZsZXQgTGF0TG5nQm91bmRzIG9iamVjdFxuICAgICAqL1xuICAgIHNldEV4dGVudChleHRlbnQgOiBMYXRMbmdCb3VuZHN8YW55KSB7XG4gICAgICAgIGlmKCFleHRlbnQpIHJldHVybjtcbiAgICAgICAgaWYoIHR5cGVvZihleHRlbnQubWlueCkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YoZXh0ZW50Lm1pbnkpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mKGV4dGVudC5tYXh4KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZihleHRlbnQubWF4eSkgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgLy9HUCBtb2RlbCBleHRlbnRcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhbXG4gICAgICAgICAgICAgICAgW2V4dGVudC5taW55LCBleHRlbnQubWlueF0sXG4gICAgICAgICAgICAgICAgW2V4dGVudC5tYXh5LCBleHRlbnQubWF4eF1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYodHlwZW9mKGV4dGVudC5nZXRXZXN0KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vTC5MYXRMbmdCb3VuZHNcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhleHRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgTGF5ZXIgb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxheWVyIExlYWZsZXQgTGF5ZXIgaW5zdGFuY2Ugb3Igb2JqZWN0IGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBzZXRCYXNlTGF5ZXIgKGxheWVyIDogYW55KSB7XG5cbiAgICAgICAgbGV0IHByb21pc2UgPSBudWxsO1xuICAgICAgICBpZighbGF5ZXIpIHtcbiAgICAgICAgICAgIGxldCBzdmMgPSB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLkxBWUVSKSBhcyBMYXllclNlcnZpY2U7XG4gICAgICAgICAgICBwcm9taXNlID0gRGVmYXVsdEJhc2VMYXllci5nZXQoc3ZjKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGxheWVyKTtcblxuICAgICAgICBwcm9taXNlLnRoZW4oIGxheWVyID0+IHtcblxuICAgICAgICAgICAgbGV0IGxlYWZsZXRMYXllciA9IExheWVyRmFjdG9yeS5jcmVhdGUobGF5ZXIpO1xuICAgICAgICAgICAgaWYoIWxlYWZsZXRMYXllcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogTWFwSW5zdGFuY2UgY291bGQgbm90IGNyZWF0ZSBiYXNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJsYXllciBmb3IgJ1wiICsgbGF5ZXIuaWQgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5hZGRMYXllcihsZWFmbGV0TGF5ZXIpO1xuXG4gICAgICAgICAgICAobGVhZmxldExheWVyIGFzIGFueSkuc2V0WkluZGV4KDApOyAgLy9zZXQgYXQgYm90dG9tXG5cbiAgICAgICAgICAgIGxldCBvbGRCYXNlTGF5ZXIgPSB0aGlzLl9iYXNlTGF5ZXI7XG4gICAgICAgICAgICBpZihvbGRCYXNlTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihvbGRCYXNlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3JlbWVtYmVyIG5ldyBiYXNlIGxheWVyXG4gICAgICAgICAgICB0aGlzLl9iYXNlTGF5ZXIgPSBsZWFmbGV0TGF5ZXI7XG4gICAgICAgICAgICB0aGlzLl9iYXNlTGF5ZXJEZWYgPSBsYXllcjtcblxuICAgICAgICAgICAgLy93aWxsIG5vdGlmeSBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ2Jhc2VsYXllcjpjaGFuZ2VkJywgbGF5ZXIsIGxlYWZsZXRMYXllcik7XG4gICAgICAgICAgICAvLyB0aGlzLm5vdGlmeSgnYmFzZWxheWVyOmNoYW5nZWQnLCBsYXllciwgbGVhZmxldExheWVyKTtcblxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTWFwSW5zdGFuY2Uuc2V0QmFzZUxheWVyKCkgLSBFcnJvciBnZXR0aW5nIGJhc2UgbGF5ZXIgZm9yIG1hcCA6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgdGhpcy5sb2dMYXllckVycm9yKCBsYXllci5pZCwgXCJFcnJvciBzZXR0aW5nIGJhc2VsYXllciBvbiBtYXAgXCIgK1xuICAgICAgICAgICAgICAgIFwiYmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGVycm9yKHMpOiBcIiArIGUubWVzc2FnZSApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGFycmF5IG9mIGJhc2UgbGF5ZXJzIGRlZmluaXRpb25zIHRoYXQgY2FuIGJlIHVzZWRcbiAgICAgKi9cbiAgICAvLyBnZXRCYXNlTGF5ZXJPcHRpb25zICgpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuX2Jhc2VMYXllck9wdGlvbnM7XG4gICAgLy8gfSxcblxuICAgIGdldEJhc2VMYXllciAoKSA6IGFueSB7IHJldHVybiB0aGlzLl9iYXNlTGF5ZXJEZWY7IH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gbGlzdCBvZiBsYXllciBzdGF0ZXMgY29udGFpbmluZyBsYXllciBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGdldExheWVycyAoKSA6IGFueVtdIHsgcmV0dXJuIHRoaXMuX2xheWVyU3RhdGVzOyB9XG5cbiAgICBnZXRMYXllckVycm9ycyAoKSA6IGFueVtdIHsgcmV0dXJuIHRoaXMuX2xheWVyRXJyb3JzOyB9XG5cbiAgICBjbGVhckxheWVyRXJyb3JzICgpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xheWVyOmVycm9yJyk7XG4gICAgfVxuXG4gICAgY2xlYXJPdmVybGF5cyAoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIGZvcih2YXIgaT10aGlzLl9sYXllclN0YXRlcy5sZW5ndGgtMTsgaT49MDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9sYXllclN0YXRlc1tpXTtcbiAgICAgICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtzdGF0ZS5sYXllci5pZF07XG4gICAgICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5vZmYoXCJsYXllcjplcnJvclwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllckNhY2hlW3N0YXRlLmxheWVyLmlkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIobGF5ZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy50b3VjaCgnbGF5ZXJzOmNoYW5nZWQnKTtcblxuICAgICAgICAvL1RPRE8gc3RvcCBsaXN0ZW5pbmcgZm9yIGxheWVyIGV2ZW50c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsYXllcnMgLSBsaXN0IG9mIGxheWVycyAoTk9URTogbm90IHdyYXBwZWQgYnkgbGF5ZXIgc3RhdGVzLCB0aGlzIG1ldGhvZCBhcHBsaWVzIHRoYXQpXG4gICAgICovXG4gICAgYWRkTGF5ZXJzIChsYXllcnMgOiBhbnl8YW55W10gKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk46IGF0dGVtcHRpbmcgdG8gYWRkIGxheWVycyB0byBhbiBlbXB0eSBjYWNoZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk46IEF0dGVtcHRpbmcgdG8gYWRkIGxheWVycyB0byBhIG1hcCB3aXRoIG5vIGxheWVyIGNhY2hlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWxheWVycykgcmV0dXJuO1xuICAgICAgICBpZih0eXBlb2YobGF5ZXJzLnB1c2gpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGF5ZXJzID0gW2xheWVyc107XG4gICAgICAgIH1cblxuICAgICAgICBsYXllcnMuZm9yRWFjaCggKG9iaixpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgbGF5ZXIgPSBudWxsLCBzdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmKG9iai50eXBlICYmIG9iai50eXBlPT09SXRlbVR5cGVzLkxBWUVSKSB7IC8vaXMgYSBsYXllclxuICAgICAgICAgICAgICAgIGxheWVyID0gb2JqO1xuICAgICAgICAgICAgfSBlbHNlIGlmKG9iai5sYXllcikgeyAgLy9pcyBsYXllciBzdGF0ZVxuICAgICAgICAgICAgICAgIGxheWVyID0gb2JqLmxheWVyOyAgLy8gY29udGFpbmluZyBhIGxheWVyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBvYmo7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFsYXllcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UuYWRkTGF5ZXJzKCkgLSBsYXllciAoXCIgKyBpbmRleCArXG4gICAgICAgICAgICAgICAgICAgIFwiKSBpcyBub3QgYSBMYXllciBvciBhIExheWVyIHN0YXRlLiBJZ25vcmluZy4uLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAvL2xheWVyIGluZm8gaXMgbWlzc2luZywgc2tpcCBpdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL0RULTQ0MiBwcmV2ZW50IGFkZGluZyBsYXllciB0aGF0IGFscmVhZHkgZXhpc3RzIG9uIG1hcFxuICAgICAgICAgICAgaWYodGhpcy5fbGF5ZXJDYWNoZVtsYXllci5pZF0pIHJldHVybjtcblxuICAgICAgICAgICAgaWYoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy93cmFwcGVkIGluIHRyeXt9Y2F0Y2ggYmVjYXVzZSBsYXllciBtYXkgY29udGFpbiBjaXJjdWxhciByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSBlcnJvciB3aGVuIHVzZWQgYnkgSlNPTiBtZXRob2RzXG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXllckNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxheWVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcjogbGF5ZXJDb3B5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBhZGQgbGF5ZXIgdG8gbWFwIGJlY2F1c2Ugb2YgXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHogPSBsYXllcnMubGVuZ3RoIC0gaW5kZXg7XG4gICAgICAgICAgICBzdGF0ZS56SW5kZXggPSB6O1xuXG4gICAgICAgICAgICB0aGlzLmFkZExheWVyV2l0aFN0YXRlKGxheWVyLCBzdGF0ZSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50b3VjaCgnbGF5ZXJzOmNoYW5nZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBHZW9QbGF0Zm9ybSBMYXllciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEdlb1BsYXRmb3JtIExheWVyIFN0YXRlXG4gICAgICovXG4gICAgYWRkTGF5ZXJXaXRoU3RhdGUobGF5ZXIsIHN0YXRlKSB7XG5cbiAgICAgICAgdmFyIGxlYWZsZXRMYXllciA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZighbGF5ZXIgfHwgIXN0YXRlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQsIG1pc3NpbmcgbGF5ZXIgYW5kIG9yIHN0YXRlXCIpO1xuXG4gICAgICAgICAgICBsZWFmbGV0TGF5ZXIgPSBMYXllckZhY3RvcnkuY3JlYXRlKGxheWVyKTtcbiAgICAgICAgICAgIGlmKCFsZWFmbGV0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbXNnID0gXCJDb3VsZCBub3QgY3JlYXRlIGxlYWZsZXQgaW5zdGFuY2UgZm9yIEdQIExheWVyICdcIiArIGxheWVyLmlkICsgXCInLlwiO1xuICAgICAgICAgICAgICAgIGlmKCFsYXllci5zZXJ2aWNlcyB8fCAhbGF5ZXIuc2VydmljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSAnICBUaGUgbGF5ZXIgaW5zdGFuY2UgaGFzIG5vIHNlcnZpY2VzIGluY2x1ZGVkLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aGljaCB3aWxsIHByZXZlbnQgbW9zdCBsYXllcnMgZnJvbSBiZWluZyBkaXNwbGF5ZWQuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ0xheWVyRXJyb3IoIGxheWVyLmlkLFxuICAgICAgICAgICAgICAgIFwiTGF5ZXIgJ1wiICsgbGF5ZXIubGFiZWwgKyBcIicgY291bGQgbm90IGJlIGFkZGVkIHRvIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgXCJtYXAgaW5zdGFuY2U7IFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFsZWFmbGV0TGF5ZXIpIHJldHVybjtcblxuICAgICAgICAvL2NhY2hlIGxlYWZsZXQgb2JqZWN0IGZpcnN0XG4gICAgICAgIGlmKHRoaXMuX2xheWVyQ2FjaGUpIHRoaXMuX2xheWVyQ2FjaGVbbGF5ZXIuaWRdID0gbGVhZmxldExheWVyO1xuXG4gICAgICAgIC8vbGlzdGVuIGZvciBsYXllciBlcnJvcnMgc28gd2UgY2FuIGluZm9ybSB0aGUgdXNlclxuICAgICAgICAvLyB0aGF0IGEgbGF5ZXIgaGFzbid0IGJlZW4gbG9hZGVkIGluIGEgdXNlZnVsIHdheVxuICAgICAgICBsZWFmbGV0TGF5ZXIub24oJ3RpbGVlcnJvcicsIChlKSA9PiB7IHRoaXMuaGFuZGxlTGF5ZXJFcnJvcihlKTsgfSk7XG5cbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuYWRkTGF5ZXIobGVhZmxldExheWVyKTtcblxuICAgICAgICBpZiggIWlzTmFOKHN0YXRlLnpJbmRleCkgJiYgbGVhZmxldExheWVyLnNldFpJbmRleCApXG4gICAgICAgICAgICBsZWFmbGV0TGF5ZXIuc2V0WkluZGV4KHN0YXRlLnpJbmRleCk7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMucHVzaChzdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xheWVyOmFkZGVkJywgbGF5ZXIsIGxlYWZsZXRMYXllcik7XG5cblxuICAgICAgICAvLyBpZiBsYXllciBpcyBpbml0aWFsbHkgXCJvZmZcIiBvci4uLlxuICAgICAgICAvLyBpZiBsYXllciBpcyBpbml0aWFsbHkgbm90IDEwMCUgb3BhcXVlXG4gICAgICAgIGlmKCFzdGF0ZS52aXNpYmlsaXR5IHx8IHN0YXRlLm9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGxheWVyIHZpc2liaWxpdHkgYW5kIG9wYWNpdHkgYXN5bmMsIG9yIGVsc2VcbiAgICAgICAgICAgIC8vIHNvbWUgb2YgdGhlIGxheWVycyB3b24ndCBnZXQgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoIChsYXllciwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExheWVyVmlzaWJpbGl0eShsYXllciwgc3RhdGUudmlzaWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMYXllck9wYWNpdHkobGF5ZXIsIHN0YXRlLm9wYWNpdHkpO1xuICAgICAgICAgICAgICAgIC8vVE9ETyBub3RpZnkgb2YgY2hhbmdlXG5cbiAgICAgICAgICAgICAgICAvL0RULTIxMDIgdGltZW91dCBuZWVkcyB0byBiZSBsYXJnZSBlbm91Z2ggb3IgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGZlYXR1cmUgbGF5ZXJzIHdvbid0IGdldCBvcGFjaXR5IHVwZGF0ZWQgb24gbWFwIGxvYWRcbiAgICAgICAgICAgIH0sIDIwMDAsIGxlYWZsZXRMYXllciwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZyb20gLSBwb3NpdGlvbiBvZiBsYXllciBiZWluZyBtb3ZlZFxuICAgICAqIEBwYXJhbSB0byAtIGRlc2lyZWQgcG9zaXRpb24gdG8gbW92ZSBsYXllciB0b1xuICAgICAqL1xuICAgIG1vdmVMYXllciAoZnJvbSA6IG51bWJlciwgdG8gOiBudW1iZXIpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmKGlzTmFOKGZyb20pKSByZXR1cm47XG5cbiAgICAgICAgLy9lbmQgb2YgbGlzdFxuICAgICAgICBpZihpc05hTih0bykpIHRvID0gdGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoLTE7XG5cbiAgICAgICAgbGV0IGNvcHkgPSB0aGlzLl9sYXllclN0YXRlcy5zcGxpY2UoZnJvbSwgMSlbMF07ICAgIC8vZ3JhYiBsYXllciBiZWluZyBtb3ZlZFxuICAgICAgICB0aGlzLl9sYXllclN0YXRlcy5zcGxpY2UodG8sIDAsIGNvcHkpO1xuXG4gICAgICAgIGZvcihsZXQgej0xLCBpPXRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aC0xOyBpPj0wOyAtLWksKyt6KSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXJTdGF0ZSA9IHRoaXMuX2xheWVyU3RhdGVzW2ldO1xuICAgICAgICAgICAgbGV0IGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlWyBsYXllclN0YXRlLmxheWVyLmlkIF07XG4gICAgICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5zZXRaSW5kZXgoeik7XG4gICAgICAgICAgICAgICAgbGF5ZXJTdGF0ZS56SW5kZXggPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b3VjaCgnbGF5ZXJzOmNoYW5nZWQnLCB0aGlzLmdldExheWVycygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUxheWVyIChpZCkge1xuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtpZF07XG4gICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcblxuICAgICAgICAgICAgLy9yZW1vdmUgbGF5ZXIgZnJvbSB0cmFja2VkIGRlZnMgYXJyYXlcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZUluZGV4KGlkKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIoXCIgKyBpZCArIFwiKVwiKTtcbiAgICAgICAgICAgIGlmKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9sYXllclN0YXRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgLy9zdG9wIGxpc3RlbmluZyBmb3IgZXJyb3JzXG4gICAgICAgICAgICBsYXllckluc3RhbmNlLm9mZihcImxheWVyOmVycm9yXCIpO1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBsYXllciBmcm9tIG1hcFxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIobGF5ZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGxheWVyIGZyb20gY2FjaGVcbiAgICAgICAgICAgIHRoaXMuX2xheWVyQ2FjaGVbaWRdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoKCdsYXllcnM6Y2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlTGF5ZXJWaXNpYmlsaXR5IChpZCkge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbaWRdO1xuICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoaWQpO1xuICAgICAgICAgICAgc3RhdGUudmlzaWJpbGl0eSA9ICFzdGF0ZS52aXNpYmlsaXR5O1xuXG4gICAgICAgICAgICBpZihsYXllckluc3RhbmNlLl9jdXJyZW50SW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAvL0VTUkkgSW1hZ2UgU2VydmljZSBsYXllcnMgaGF2ZSBhbiBJTUcgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgZ2V0cyBtb2RpZmllZCBhbmQgcmVwbGFjZWQgZXZlcnkgbWFwIGV2ZW50ICh6b29tL3BhbilcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4ndCBqdXN0IHRvZ2dsZSBjbGFzc2VzIGxpa2Ugb24gb3RoZXIgbGF5ZXJzLlxuICAgICAgICAgICAgICAgIC8vSW5zdGVhZCwgd2UgbmVlZCB0byB1c2UgdGhlIEVTUkkgc2V0T3BhY2l0eSBtZXRob2QgdG8gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLy8gYnV0IG5lZWQgdG8gdXBkYXRlIGxheWVyIHN0YXRlIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5zZXRPcGFjaXR5KHN0YXRlLnZpc2liaWxpdHkgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgc3RhdGUub3BhY2l0eSA9IGxheWVySW5zdGFuY2UuZ2V0T3BhY2l0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRMYXllclZpc2liaWxpdHkobGF5ZXJJbnN0YW5jZSwgc3RhdGUudmlzaWJpbGl0eSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHVwZGF0ZSBsYXllciBkZWZpbml0aW9uIHN0YXRlLiBVc2VcbiAgICAgKiBNYXBJbnN0YW5jZS50b2dnbGVMYXllclZpc2liaWxpdHkgdG8gZG8gdGhhdCBhbmQgYWRqdXN0XG4gICAgICogcmVuZGVyZWQgbGF5ZXIncyB2aXNpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVySW5zdGFuY2UgLSBsZWFmbGV0IGxheWVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBmbGFnIGluZGljYXRpbmcgdmlzaWJpbGl0eSBvZiBsYXllclxuICAgICAqL1xuICAgIHNldExheWVyVmlzaWJpbGl0eSAobGF5ZXJJbnN0YW5jZSA6IExheWVyLCB2aXNpYmxlIDogYm9vbGVhbikge1xuXG4gICAgICAgIGlmKChsYXllckluc3RhbmNlIGFzIGFueSkuc2V0VmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgLy91c2luZyBjdXN0b20gbWV0aG9kIHByb3ZpZGVkIGluIHNyYy9sYXllci9tb2R1bGUuanNcbiAgICAgICAgICAgIChsYXllckluc3RhbmNlIGFzIGFueSkuc2V0VmlzaWJpbGl0eSh2aXNpYmxlKTtcblxuICAgICAgICB9IGVsc2UgaWYoKGxheWVySW5zdGFuY2UgYXMgYW55KS5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICAvL290aGVyd2lzZSwgdXNpbmcganF1ZXJ5IG9uIGRvbSBkaXJlY3RseVxuICAgICAgICAgICAgbGV0IGVsID0galF1ZXJ5KChsYXllckluc3RhbmNlIGFzIGFueSkuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyBpZih2aXNpYmxlKSBlbC5yZW1vdmVDbGFzcyhcImludmlzaWJsZVwiKTtcbiAgICAgICAgICAgIC8vIGVsc2UgZWwuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgICAgICAgICAgZWwuY3NzKHsnZGlzcGxheSc6IHZpc2libGUgPyAnJyA6ICdub25lJ30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b3VjaCgnbWFwOmxheWVyOmNoYW5nZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZUxheWVyT3BhY2l0eSAoaWQgOiBzdHJpbmcsIG9wYWNpdHkgOiBudW1iZXIpIHtcblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbaWRdO1xuXG4gICAgICAgIC8vaWYgbGF5ZXIgaWQgaXMgZm9yIGJhc2UgbGF5ZXIuLi5cbiAgICAgICAgaWYoIWxheWVySW5zdGFuY2UgJiYgdGhpcy5fYmFzZUxheWVyRGVmLmlkID09PSBpZCkge1xuICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2Jhc2VMYXllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYWRqdXN0IHJlbmRlcmVkIGxlYWZsZXQgbGF5ZXJcbiAgICAgICAgb3BhY2l0eSA9IHRoaXMuc2V0TGF5ZXJPcGFjaXR5KGxheWVySW5zdGFuY2UsIG9wYWNpdHkpO1xuXG4gICAgICAgIC8vIGlmIG92ZXJsYXkgbGF5ZXIsIHVwZGF0ZSBzdGF0ZSB2YWx1ZVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoaWQpO1xuICAgICAgICBpZihzdGF0ZSkgc3RhdGUub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBkb2VzIG5vdCB1cGRhdGUgdGhlIGFzc29jaWF0ZWQgTGF5ZXIgRGVmaW5pdGlvblxuICAgICAqIHN0YXRlIHZhbHVlIGZvciBvcGFjaXR5LiBVc2UgTWFwSW5zdGFuY2UudXBkYXRlTGF5ZXJPcGFjaXR5KCkgdG9cbiAgICAgKiBib3RoIHVwZGF0ZSBzdGF0ZSBhbmQgYWRqdXN0IHJlbmRlcmVkIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVySW5zdGFuY2UgLSBsZWFmbGV0IGxheWVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG9wYWNpdHkgLSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuMCBvciAwIGFuZCAxMDBcbiAgICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgb3BhY2l0eSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuMFxuICAgICAqL1xuICAgIHNldExheWVyT3BhY2l0eSAobGF5ZXJJbnN0YW5jZSA6IExheWVyLCBvcGFjaXR5IDogbnVtYmVyKSA6IG51bWJlciB7XG4gICAgICAgIGlmKGxheWVySW5zdGFuY2UgJiYgKGxheWVySW5zdGFuY2UgYXMgYW55KS5zZXRPcGFjaXR5KSB7XG4gICAgICAgICAgICBpZihvcGFjaXR5ID4gMS4wKSBvcGFjaXR5ID0gb3BhY2l0eSAvIDEwMC4wO1xuICAgICAgICAgICAgKGxheWVySW5zdGFuY2UgYXMgYW55KS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnbWFwOmxheWVyOmNoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gR2VvUGxhdGZvcm0gTGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIExlYWZsZXQgbGF5ZXIgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoYXQgbGF5ZXIgb3IgbnVsbFxuICAgICAqL1xuICAgIGdldExlYWZsZXRMYXllckZvciAoZ3BMYXllciA6IGFueSkgOiBMYXllciB7XG4gICAgICAgIGlmKCFncExheWVyIHx8ICF0aGlzLl9sYXllckNhY2hlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxlYWZsZXRMYXllciA9IHRoaXMuX2xheWVyQ2FjaGVbZ3BMYXllci5pZF07XG4gICAgICAgIHJldHVybiBsZWFmbGV0TGF5ZXIgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUdldEZlYXR1cmVJbmZvIChsYXllcklkIDogc3RyaW5nKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtsYXllcklkXTtcbiAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYodHlwZW9mKGxheWVySW5zdGFuY2UuZW5hYmxlR2V0RmVhdHVyZUluZm8pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlmKGxheWVySW5zdGFuY2UuaXNHZXRGZWF0dXJlSW5mb0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLmRpc2FibGVHZXRGZWF0dXJlSW5mbygpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoKHRoaXMuX21hcEluc3RhbmNlIGFzIGFueSkuX2NvbnRhaW5lcikucmVtb3ZlQ2xhc3MoJ3NlbGVjdGFibGUtY3Vyc29yJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5lbmFibGVHZXRGZWF0dXJlSW5mbygpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoKHRoaXMuX21hcEluc3RhbmNlIGFzIGFueSkuX2NvbnRhaW5lcikuYWRkQ2xhc3MoJ3NlbGVjdGFibGUtY3Vyc29yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICBGZWF0dXJlIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gYXJyYXkgb2YgZmVhdHVyZXMgb24gdGhlIG1hcFxuICAgICAqL1xuICAgIGdldEZlYXR1cmVzICgpIDogYW55W10ge1xuICAgICAgICBpZih0aGlzLl9mZWF0dXJlTGF5ZXIpIHtcbiAgICAgICAgICAgIGxldCBnZW9qc29uID0gdGhpcy5fZmVhdHVyZUxheWVyLnRvR2VvSlNPTigpO1xuICAgICAgICAgICAgcmV0dXJuIChnZW9qc29uIGFzIGFueSkuZmVhdHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBqc29uIGdlb2pzb24gb2JqZWN0IG9yIGFycmF5IG9mIGdlb2pzb24gb2JqZWN0c1xuICAgICAqL1xuICAgIGFkZEZlYXR1cmVzIChqc29uIDogYW55KSB7XG5cbiAgICAgICAgaWYoIWpzb24pIHJldHVybjtcblxuICAgICAgICBpZih0eXBlb2YoanNvbi5wdXNoKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vYXJyYXkgb2YgZmVhdHVyZXNcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGpzb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGpzb25baV0sIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ2ZlYXR1cmVzOmNoYW5nZWQnKTtcblxuICAgICAgICB9IGVsc2UgaWYoanNvbi5mZWF0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlcyhqc29uLmZlYXR1cmVzKTtcblxuICAgICAgICB9IGVsc2UgeyAvL3NpbmdsZSBmZWF0dXJlXG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoanNvbiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBqc29uIGdlb2pzb24gb2JqZWN0XG4gICAgICovXG4gICAgYWRkRmVhdHVyZSAoanNvbiA6IGFueSwgZmlyZUV2ZW50ID86IGJvb2xlYW4pIHtcbiAgICAgICAgLy8gdmFyIHR5cGUgPSBqc29uLnR5cGU7XG4gICAgICAgIC8vIHZhciBjb29yZGluYXRlcyA9IGpzb24uY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgaWYoIXRoaXMuX2ZlYXR1cmVMYXllcikge1xuXG4gICAgICAgICAgICAvLyBfZmVhdHVyZUxheWVyID0gZ2VvSlNPTihbXSwgX2dlb0pzb25MYXllck9wdHMpLmFkZFRvKF9tYXBJbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIgPSBmZWF0dXJlR3JvdXAoKS5hZGRUbyh0aGlzLl9tYXBJbnN0YW5jZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIF9mZWF0dXJlTGF5ZXIuYWRkRGF0YShqc29uKTtcbiAgICAgICAgdmFyIG9wdHMgPSBqUXVlcnkuZXh0ZW5kKHt9LCB0aGlzLl9nZW9Kc29uTGF5ZXJPcHRzKTtcbiAgICAgICAgZ2VvSlNPTihqc29uLCBvcHRzKS5lYWNoTGF5ZXIoKGwpPT50aGlzLmFkZEZlYXR1cmVMYXllcihsKSk7XG5cbiAgICAgICAgaWYodHlwZW9mKGZpcmVFdmVudCkgPT09ICd1bmRlZmluZWQnIHx8IGZpcmVFdmVudCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ2ZlYXR1cmVzOmNoYW5nZWQnKTtcbiAgICAgICAgZWxzZSB0aGlzLnRvdWNoKCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoX2ZlYXR1cmVMYXllci50b0dlb0pTT04oKSkpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZlYXR1cmVKc29uIG9iamVjdCBkZWZpbmluZyBhIEdlb0pTT04gZmVhdHVyZVxuICAgICAqL1xuICAgIHVwZGF0ZUZlYXR1cmUgKGZlYXR1cmVKc29uIDogYW55KSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0RmVhdHVyZUxheWVyKGZlYXR1cmVKc29uLnByb3BlcnRpZXMuaWQpO1xuICAgICAgICBpZihsYXllcikge1xuXG4gICAgICAgICAgICAobGF5ZXIgYXMgYW55KS5mZWF0dXJlID0gZmVhdHVyZUpzb247XG5cbiAgICAgICAgICAgIC8vdXBkYXRlIHN0eWxlXG4gICAgICAgICAgICBsYXllci5zZXRTdHlsZShmZWF0dXJlSnNvbi5wcm9wZXJ0aWVzLnN0eWxlKTtcblxuICAgICAgICAgICAgLy9yZWJpbmQgbGFiZWwgaW4gY2FzZSB0aGF0IGNoYW5nZWRcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGZlYXR1cmVKc29uLnByb3BlcnRpZXMubGFiZWwgfHxcbiAgICAgICAgICAgICAgICBcIlVudGl0bGVkIFwiICsgZmVhdHVyZUpzb24uZ2VvbWV0cnkudHlwZSArIFwiIEZlYXR1cmVcIjtcbiAgICAgICAgICAgIGxheWVyLmJpbmRUb29sdGlwKGxhYmVsKTtcblxuICAgICAgICAgICAgLy8gbGF5ZXIucmVkcmF3KCk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKFwibWFwOmZlYXR1cmU6Y2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYW4gZXhpc3RpbmcgTC5QYXRoLWJhc2VkIGxheWVyIHdpdGggb25lIHVzaW5nXG4gICAgICogdGhlIHN1cHBsaWVkIEZlYXR1cmUgR2VvSlNPTiBvYmplY3QuICBSZW1vdmVzIHRoZSBleGlzdGluZ1xuICAgICAqIGxheWVyIGFuZCBhZGRzIGEgbmV3IG9uZSBjcmVhdGVkIGZyb20gdGhlIEdlb0pTT04uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUpzb24gb2JqZWN0IGRlZmluaW5nIEdlb0pTT04gZmVhdHVyZVxuICAgICAqL1xuICAgIHJlcGxhY2VGZWF0dXJlIChmZWF0dXJlSnNvbiA6IGFueSkge1xuXG4gICAgICAgIC8vZmluZCBleGlzdGluZyBsYXllciBmb3IgdGhpcyBmZWF0dXJlXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0RmVhdHVyZUxheWVyKGZlYXR1cmVKc29uLnByb3BlcnRpZXMuaWQpO1xuICAgICAgICBpZihsYXllcikge1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBleGlzdGluZ1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLnJlbW92ZUxheWVyKGxheWVyKTtcblxuICAgICAgICAgICAgLy9hZGQgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGdlb0pTT04oZmVhdHVyZUpzb24sIHRoaXMuX2dlb0pzb25MYXllck9wdHMpXG4gICAgICAgICAgICAgICAgLmVhY2hMYXllcigobCk9PnRoaXMuYWRkRmVhdHVyZUxheWVyKGwpKTtcblxuICAgICAgICAgICAgdGhpcy50b3VjaChcIm1hcDpmZWF0dXJlOmNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUlkIGlkZW50aWZpZXIgb2YgZmVhdHVyZSB0byBmb2N1cyB0aGUgbWFwIG9uXG4gICAgICovXG4gICAgZm9jdXNGZWF0dXJlIChmZWF0dXJlSWQgOiBzdHJpbmcpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRGZWF0dXJlTGF5ZXIoZmVhdHVyZUlkKTtcbiAgICAgICAgaWYobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YobGF5ZXIuZ2V0Qm91bmRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW50ID0gbGF5ZXIuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKGV4dGVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZW9mKCAobGF5ZXIgYXMgYW55KS5nZXRMYXRMbmcpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBsYXRMbmcgPSAobGF5ZXIgYXMgYW55KS5nZXRMYXRMbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5wYW5UbyhsYXRMbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmZvY3VzRmVhdHVyZSgpIC0gQ2Fubm90IGZvY3VzIGZlYXR1cmUgYmVjYXVzZSBpdCBoYXMgbm8gYm91bmRzIG9yIGxhdC9sbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmZvY3VzRmVhdHVyZSgpIC0gQ2Fubm90IGZvY3VzIGZlYXR1cmUgYmVjYXVzZSBpdCBoYXMgbm8gbGF5ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUlkIDogc3RyaW5nXG4gICAgICovXG4gICAgcmVtb3ZlRmVhdHVyZSAoZmVhdHVyZUlkKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0RmVhdHVyZUxheWVyKGZlYXR1cmVJZCk7XG4gICAgICAgIGlmKGxheWVyICYmIHRoaXMuX2ZlYXR1cmVMYXllcikge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLnJlbW92ZUxheWVyKGxheWVyKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ2ZlYXR1cmVzOmNoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlRmVhdHVyZXMgKCkge1xuICAgICAgICBpZih0aGlzLl9mZWF0dXJlTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllci5jbGVhckxheWVycygpO1xuICAgICAgICAgICAgdGhpcy50b3VjaChcImZlYXR1cmVzOmNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldEZlYXR1cmVMYXllciAoIGZlYXR1cmVJZCA/OiBzdHJpbmcgKSA6IEZlYXR1cmVHcm91cCB7XG4gICAgICAgIC8vaWYgbm8gZmVhdHVyZSB3YXMgc3BlY2lmaWVkLCByZXR1cm4gcm9vdCBmZWF0dXJlIGxheWVyXG4gICAgICAgIGlmKCFmZWF0dXJlSWQpIHJldHVybiB0aGlzLl9mZWF0dXJlTGF5ZXI7XG5cbiAgICAgICAgLy9vdGhlcndpc2UsIGZpbmQgZmVhdHVyZS4uLlxuICAgICAgICBpZighdGhpcy5fZmVhdHVyZUxheWVyKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLl9mZWF0dXJlTGF5ZXIuZ2V0TGF5ZXJzKCk7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGZlYXR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiggKGZlYXR1cmVzW2ldIGFzIGFueSkuZmVhdHVyZSAmJlxuICAgICAgICAgICAgICAgIChmZWF0dXJlc1tpXSBhcyBhbnkpLmZlYXR1cmUucHJvcGVydGllcy5pZCA9PT0gZmVhdHVyZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmZWF0dXJlc1tpXSBhcyBhbnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRvZ2dsZUZlYXR1cmVzTGF5ZXIgKCkge1xuICAgICAgICBpZighdGhpcy5fZmVhdHVyZUxheWVyKSByZXR1cm4gZmFsc2U7ICAgIC8vaWdub3JlIGlmIG5vdCByZW5kZXJlZCB5ZXRcblxuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlID0gIXRoaXMuX2ZlYXR1cmVMYXllclZpc2libGU7XG4gICAgICAgIHRoaXMuc2V0RmVhdHVyZUxheWVyVmlzaWJpbGl0eSh0aGlzLl9mZWF0dXJlTGF5ZXIsIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIGZlYXR1cmUgLSBMZWFmbGV0IGZlYXR1cmUgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gIHZpc2liaWxpdHkgLSBmbGFnXG4gICAgICovXG4gICAgc2V0RmVhdHVyZVZpc2liaWxpdHkgKGZlYXR1cmUsIHZpc2liaWxpdHkgOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuc2V0RmVhdHVyZUxheWVyVmlzaWJpbGl0eShmZWF0dXJlLCB2aXNpYmlsaXR5KTtcbiAgICB9XG5cbiAgICBnZXRGZWF0dXJlc0xheWVyVmlzaWJpbGl0eSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlO1xuICAgIH1cblxuXG4gICAgLypcbiAgICAgKiBtZXRob2QgZm9yIGFkZGluZyBmZWF0dXJlIGxheWVycyB0byB0aGUgbWFwXG4gICAgICogd2hlbiB0aGVzZSBsYXllcnMgbWF5IGJlIGxheWVyIGdyb3Vwcy5cbiAgICAgKiBmaW5kcyBsZWFmIG5vZGUgbGF5ZXJzIGFuZCBhZGRzIHRoZW0gdG8gdGhlXG4gICAgICogbWFwJ3MgZmVhdHVyZSBncm91cFxuICAgICAqL1xuICAgIGFkZEZlYXR1cmVMYXllcihsYXllcikge1xuICAgICAgICB0aGlzLl9hZGRGZWF0dXJlTGF5ZXIobGF5ZXIpO1xuICAgICAgICB0aGlzLnRvdWNoKFwiZmVhdHVyZXM6Y2hhbmdlZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QsIHVzZSAnYWRkRmVhdHVyZUxheWVyJyBpbnN0ZWFkXG4gICAgICogQHBhcmFtIGxheWVyXG4gICAgICovXG4gICAgX2FkZEZlYXR1cmVMYXllcihsYXllciA6IExheWVyKSB7XG4gICAgICAgIGlmKCEobGF5ZXIgYXMgYW55KS5mZWF0dXJlICYmIGxheWVyIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkge1xuICAgICAgICAgICAgbGF5ZXIuZWFjaExheWVyKCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRGZWF0dXJlTGF5ZXIoY2hpbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIuYWRkTGF5ZXIobGF5ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvL3RvZ2dsZSB2aXNpYmlsaXR5IG9mIHBhcmVudCBmZWF0dXJlIGxheWVyXG4gICAgc2V0RmVhdHVyZUxheWVyVmlzaWJpbGl0eShsYXllciwgdmlzaWJpbGl0eSkge1xuICAgICAgICBpZighbGF5ZXIpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSA9IHZpc2liaWxpdHk7XG5cbiAgICAgICAgaWYobGF5ZXIuZ2V0TGF5ZXJzKSB7XG4gICAgICAgICAgICBsYXllci5nZXRMYXllcnMoKS5mb3JFYWNoKCAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZlYXR1cmVMYXllclZpc2liaWxpdHkoY2hpbGQsIHZpc2liaWxpdHkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyIHx8IGxheWVyLl9wYXRoO1xuICAgICAgICAgICAgaWYoY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gdmlzaWJpbGl0eSA/ICcnIDogJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICBNYXAgbGlmZWN5Y2xlIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHJlc29sdmluZyBwZXJzaXN0ZWQgbWFwXG4gICAgICovXG4gICAgc2F2ZSAobWV0YWRhdGEgOiBhbnkpIDogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1hcChtZXRhZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1kIG9iamVjdCBjb250YWluaW5nIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIG1hcFxuICAgICAqL1xuICAgIHNhdmVNYXAgKG1kIDogYW55KSA6IFByb21pc2U8YW55PiB7XG5cbiAgICAgICAgbGV0IG1ldGFkYXRhID0gbWQgfHwge307XG5cbiAgICAgICAgLy9hZGQgR2VvUGxhdGZvcm1NYXAgcmVzb3VyY2UgdHlwZSBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgIGNvbnN0IGdwTWFwVHlwZSA9ICdodHRwOi8vd3d3Lmdlb3BsYXRmb3JtLmdvdi9vbnQvb3Blbm1hcC9HZW9wbGF0Zm9ybU1hcCc7XG4gICAgICAgIG1ldGFkYXRhLnJlc291cmNlVHlwZXMgPSBtZXRhZGF0YS5yZXNvdXJjZVR5cGVzIHx8IFtdO1xuICAgICAgICBpZihtZXRhZGF0YS5yZXNvdXJjZVR5cGVzLmluZGV4T2YoZ3BNYXBUeXBlKSA8IDApXG4gICAgICAgICAgICBtZXRhZGF0YS5yZXNvdXJjZVR5cGVzLnB1c2goZ3BNYXBUeXBlKTtcblxuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuZ2V0TWFwUmVzb3VyY2VDb250ZW50KG1ldGFkYXRhKTtcblxuICAgICAgICAvL2Vuc3VyZSB0aGUgdHdvIG5hbWUgcHJvcGVydGllcyBsaW5lIHVwXG4gICAgICAgIGlmKGNvbnRlbnQudGl0bGUgJiYgY29udGVudC50aXRsZSAhPT0gY29udGVudC5sYWJlbCkge1xuICAgICAgICAgICAgY29udGVudC5sYWJlbCA9IGNvbnRlbnQudGl0bGU7XG4gICAgICAgIH0gZWxzZSBpZihjb250ZW50LmxhYmVsICYmICFjb250ZW50LnRpdGxlKSB7XG4gICAgICAgICAgICBjb250ZW50LnRpdGxlID0gY29udGVudC5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVXBkYXRpbmc6IFwiICsgSlNPTi5zdHJpbmdpZnkobWFwKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLk1BUCkuc2F2ZShjb250ZW50KVxuICAgICAgICAgICAgLnRoZW4oIHJlc3VsdCA9PiB7XG5cbiAgICAgICAgICAgICAgICAvL3RyYWNrIG5ldyBtYXAncyBpbmZvIHNvIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCBuZXh0IHNhdmVcbiAgICAgICAgICAgICAgICBpZighdGhpcy5fbWFwSWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcElkID0gcmVzdWx0LmlkO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwRGVmID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSByZXN1bHQuZXh0ZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycj0+e1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwQ29yZSBNYXBJbnN0YW5jZS5zYXZlTWFwKCkgLSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlIHJlcXVlc3RlZCBtYXAgY291bGQgbm90IGJlIHNhdmVkIGJlY2F1c2U6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgY291bGQgbm90IGJlIHNhdmVkIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcihzKTogXCIgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBtYXAncyBkZXNjcmlwdG9yIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIG1hcElkIGlkZW50aWZpZXIgb2YgbWFwXG4gICAgICogQHJldHVybiByZXNvbHZpbmcgdGhlIG1hcCBvYmplY3RcbiAgICAgKi9cbiAgICBmZXRjaE1hcCAobWFwSWQgOiBzdHJpbmcpIDogYW55IHtcbiAgICAgICAgLy9IYXZpbmcgdG8gc2VuZCBjYWNoZSBidXN0aW5nIHBhcmFtZXRlciB0byBhdm9pZCBDT1JTIGhlYWRlciBjYWNoZVxuICAgICAgICAvLyBub3Qgc2VuZGluZyBjb3JyZWN0IE9yaWdpbiB2YWx1ZVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5NQVApLmdldChtYXBJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBtYXAncyBkZXNjcmlwdG9yIGFuZCBsb2FkIGl0IGFzIHRoZVxuICAgICAqIGN1cnJlbnQgbWFwIG1hbmFnZWQgYnkgdGhpcyBzZXJ2aWNlXG4gICAgICogQHBhcmFtIG1hcElkIGlkZW50aWZpZXIgb2YgbWFwXG4gICAgICogQHJldHVybiByZXNvbHZpbmcgdGhlIG1hcCBvYmplY3RcbiAgICAgKi9cbiAgICBsb2FkTWFwIChtYXBJZCA6IHN0cmluZykgOiBhbnkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMuZmV0Y2hNYXAobWFwSWQpLnRoZW4obWFwID0+IHtcblxuICAgICAgICAgICAgICAgIGlmKCFtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArIG1hcElkICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJykgY2FtZSBiYWNrIG51bGxcIik7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHlwZW9mKG1hcCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgbWFwICgnXCIgKyBtYXBJZCArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicpIGNhbWUgYmFjayBhcyBhIHN0cmluZ1wiKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZigobWFwIGFzIGFueSkubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3IgbG9hZGluZyB0aGUgcmVxdWVzdGVkIG1hcCAoJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcElkICsgXCInKTogXCIgKyAobWFwIGFzIGFueSkubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvL2xvYWRpbmcgYSBtYXAgYnkgaXRzIElELCBzbyB3ZSBuZWVkIHRvIGluY3JlbWVudCBpdCdzIHZpZXcgY291bnRcbiAgICAgICAgICAgICAgICBpZignZGV2ZWxvcG1lbnQnICE9PSBDb25maWcuZW52KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCggKG1hcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgdmlldyBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZpZXdzID0gbWFwLnN0YXRpc3RpY3MgPyAobWFwLnN0YXRpc3RpY3MubnVtVmlld3N8fDApIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRjaCA9IFsgeyBvcDogJ3JlcGxhY2UnLCBwYXRoOiAnL3N0YXRpc3RpY3MvbnVtVmlld3MnLCB2YWx1ZTogdmlld3MrMSB9IF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLk1BUCkucGF0Y2gobWFwLmlkLCBwYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMubWFwU2VydmljZS5wYXRjaChtYXAuaWQsIHBhdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oIHVwZGF0ZWQgPT4geyBtYXAuc3RhdGlzdGljcyA9IHVwZGF0ZWQuc3RhdGlzdGljczsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCggZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5sb2FkTWFwKCkgLSBFcnJvciB1cGRhdGluZyB2aWV3IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb3VudCBmb3IgbWFwICgnXCIgKyBtYXBJZCArIFwiJyk6IFwiICsgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCwgbWFwKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vbG9hZCB0aGUgbWFwIGludG8gdGhlIHZpZXdlclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZE1hcEZyb21PYmoobWFwKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUobWFwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5sb2FkTWFwKCkgLSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlIHJlcXVlc3RlZCBtYXAgY291bGQgbm90IGJlIGxvYWRlZCBiZWNhdXNlIFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArIG1hcElkICtcbiAgICAgICAgICAgICAgICAgICAgXCInKSBjb3VsZCBub3QgYmUgbG9hZGVkIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcihzKTogXCIgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgYSBtYXAgZnJvbSBpdHMgZGVzY3JpcHRvciBhcyB0aGUgY3VycmVudFxuICAgICAqIG1hcCBtYW5hZ2VkIGJ5IHRoaXMgc2VydmljZVxuICAgICAqIEBwYXJhbSBtYXAgb2JqZWN0XG4gICAgICovXG4gICAgbG9hZE1hcEZyb21PYmogKG1hcCA6IGFueSkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTG9hZGluZyBNYXAgT2JqZWN0XCIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhtYXApO1xuXG4gICAgICAgIHRoaXMuX21hcElkID0gbWFwLmlkO1xuICAgICAgICB0aGlzLl9tYXBEZWYgPSBtYXA7XG5cbiAgICAgICAgbWFwLmV4dGVudCA9IHRoaXMuZW5zdXJlRXh0ZW50KG1hcC5leHRlbnQpO1xuXG4gICAgICAgIC8vc2V0IGV4dGVudCBmcm9tIGxvYWRlZCBtYXBcbiAgICAgICAgdGhpcy5fZGVmYXVsdEV4dGVudCA9IG1hcC5leHRlbnQ7XG4gICAgICAgIHZhciBleHRlbnQgPSBtYXAuZXh0ZW50O1xuXG4gICAgICAgIC8vcmVtb3ZlIGV4aXN0aW5nIGxheWVyc1xuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5lYWNoTGF5ZXIoKGwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnJlbW92ZUxheWVyKGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IFtdO1xuXG4gICAgICAgIC8vc2V0IG5ldyBiYXNlIGxheWVyXG4gICAgICAgIHRoaXMuc2V0QmFzZUxheWVyKG1hcC5iYXNlTGF5ZXIpO1xuXG4gICAgICAgIC8vYWRkIGxheWVycyBmcm9tIGxvYWRlZCBtYXBcbiAgICAgICAgdGhpcy5hZGRMYXllcnMobWFwLmxheWVycyk7XG5cbiAgICAgICAgLy9hZGQgZmVhdHVyZXNcbiAgICAgICAgaWYobWFwLmFubm90YXRpb25zICYmIG1hcC5hbm5vdGF0aW9ucy5nZW9KU09OKSB7XG4gICAgICAgICAgICBsZXQgZmMgPSBtYXAuYW5ub3RhdGlvbnMuZ2VvSlNPTjtcbiAgICAgICAgICAgIGlmKGZjLmZlYXR1cmVzKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZXMoZmMuZmVhdHVyZXMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZXMoW2ZjXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoW1xuICAgICAgICAgICAgW2V4dGVudC5taW55LCBleHRlbnQubWlueF0sXG4gICAgICAgICAgICBbZXh0ZW50Lm1heHksIGV4dGVudC5tYXh4XVxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdtYXA6bG9hZGVkJywgbWFwKTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV4dGVudFxuICAgICAqIEByZXR1cm4gY29ycmVjdGVkIG9yIGRlZmF1bHQgZXh0ZW50XG4gICAgICovXG4gICAgZW5zdXJlRXh0ZW50KCBleHRlbnQgOiBhbnkgKSA6IGFueSB7XG5cbiAgICAgICAgbGV0IHdlc3QgID0gIWV4dGVudCB8fCBpc05hTihleHRlbnQubWlueCkgPyAtMTc5LjAgOiBleHRlbnQubWlueCoxLjA7XG4gICAgICAgIGxldCBlYXN0ICA9ICFleHRlbnQgfHwgaXNOYU4oZXh0ZW50Lm1heHgpID8gIDE3OS4wIDogZXh0ZW50Lm1heHgqMS4wO1xuICAgICAgICBsZXQgc291dGggPSAhZXh0ZW50IHx8IGlzTmFOKGV4dGVudC5taW55KSA/ICAtODkuMCA6IGV4dGVudC5taW55KjEuMDtcbiAgICAgICAgbGV0IG5vcnRoID0gIWV4dGVudCB8fCBpc05hTihleHRlbnQubWF4eSkgPyAgIDg5LjAgOiBleHRlbnQubWF4eSoxLjA7XG5cbiAgICAgICAgLy9lbnN1cmUgeCx5IGlzIG9yZGVyZWQgY29ycmVjdGx5XG4gICAgICAgIGxldCB0O1xuICAgICAgICBpZih3ZXN0ID4gZWFzdCkge1xuICAgICAgICAgICAgdCA9IE1hdGgubWluKHdlc3QsIGVhc3QpO1xuICAgICAgICAgICAgZWFzdCA9IE1hdGgubWF4KHdlc3QsIGVhc3QpO1xuICAgICAgICAgICAgd2VzdCA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc291dGggPiBub3J0aCkge1xuICAgICAgICAgICAgdCA9IE1hdGgubWluKHNvdXRoLCBub3J0aCk7XG4gICAgICAgICAgICBub3J0aCA9IE1hdGgubWF4KHNvdXRoLCBub3J0aCk7XG4gICAgICAgICAgICBzb3V0aCA9IHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL3ByZXZlbnQgb3V0LW9mLWJvdW5kcyBleHRlbnRzXG4gICAgICAgIGlmKHdlc3QgPCAtMTgwLjApIHdlc3QgPSAtMTc5LjA7XG4gICAgICAgIGlmKGVhc3QgPiAxODAuMCkgIGVhc3QgPSAgMTc5LjA7XG4gICAgICAgIGlmKHNvdXRoIDwgLTkwLjApIHNvdXRoID0gLTg5LjA7XG4gICAgICAgIGlmKG5vcnRoID4gOTAuMCkgIG5vcnRoID0gIDg5LjA7XG5cbiAgICAgICAgcmV0dXJuIHsgbWlueCA6IHdlc3QsIG1pbnkgOiBzb3V0aCwgbWF4eCA6IGVhc3QsIG1heHkgOiBub3J0aCB9O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95TWFwICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJEZXN0cm95aW5nIE1hcFwiKTtcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllckNhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIgPSBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIG1hcCB0aGF0IGlzIGFscmVhZHkgcGVyc2lzdGVkIG9uIHRoZVxuICAgICAqIHNlcnZlciBhbmQgdW5saW5rIGl0IGhlcmUgaW4gdGhlIGNsaWVudCBzbyB0aGF0IGl0IHdpbGwgYmUgc2F2ZWRcbiAgICAgKiBhcyBhIGNvbXBsZXRlbHkgbmV3IG1hcCB3aGVuIG1hcFNlcnZpY2Uuc2F2ZU1hcCguLi4pIGlzIG5leHQgY2FsbGVkXG4gICAgICovXG4gICAgc2V0QXNOZXdNYXAgKG1hcFRvVXNlKSB7XG4gICAgICAgIHRoaXMuX21hcElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gbWFwVG9Vc2UgfHwgdGhpcy5pbml0aWFsaXplTWFwRGVmaW5pdGlvbigpO1xuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBUb29sIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICByZWdpc3RlclRvb2wgKGlkLCB0b29sKSB7XG4gICAgICAgIHRoaXMuX3Rvb2xzW2lkXSA9IHRvb2w7XG4gICAgfVxuXG4gICAgdW5yZWdpc3RlclRvb2wgKGlkKSB7XG4gICAgICAgIHRoaXMuX3Rvb2xzW2lkXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZW5hYmxlVG9vbCAoaWQsIGZpbmlzaCkge1xuICAgICAgICBpZighdGhpcy5fdG9vbHNbaWRdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Rvb2xzW2lkXS5hY3RpdmF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCd0b29sOmRpc2FibGVkJywgaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ3Rvb2w6ZW5hYmxlZCcsIGlkKTtcbiAgICB9XG5cblxuICAgIC8qIC0tLS0tLS0tLS0tIE1JU0MgLS0tLS0tLS0tLS0tICovXG5cbiAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9nc2tsZWUvbmdTdG9yYWdlXG4gICAgY2FjaGVNYXAgKCkge1xuXG4gICAgICAgIGlmKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5kaXJ0eSkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwUmVzb3VyY2VDb250ZW50KCk7XG4gICAgICAgICAgICAvL3VzZSBleHBsb2RlZCBsYXllciBpbmZvXG4gICAgICAgICAgICBtYXAubGF5ZXJzID0gdGhpcy5fbGF5ZXJTdGF0ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICAvLyAkc2Vzc2lvblN0b3JhZ2UubWFwID0gbWFwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdG9yZU1hcCAoKSB7XG4gICAgICAgIC8vIGlmKCRzZXNzaW9uU3RvcmFnZS5tYXApIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwiUmVzdG9yaW5nIGNhY2hlZCBtYXBcIik7XG4gICAgICAgIC8vICAgICBsZXQgbWFwID0gJHNlc3Npb25TdG9yYWdlLm1hcDtcbiAgICAgICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG1hcCkpO1xuICAgICAgICAvLyAgICAgJHNlc3Npb25TdG9yYWdlLm1hcCA9IG51bGw7XG4gICAgICAgIC8vICAgICB0aGlzLmxvYWRNYXBGcm9tT2JqKG1hcCk7XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xufVxuIl19