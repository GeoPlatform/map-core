/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as jquery from "jquery";
/** @type {?} */
const jQuery = jquery;
import { circleMarker, geoJSON, featureGroup, LayerGroup } from 'leaflet';
import { Config, ItemTypes, ServiceFactory, XHRHttpClient } from '@geoplatform/client';
import LayerFactory from '../layer/factory';
import DefaultBaseLayer from '../layer/baselayer-default';
class Listener {
    constructor() {
        //listeners to be unregistered upon destroy
        this._listeners = {};
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    on(type, listener) {
        if (!this._listeners[type])
            this._listeners[type] = [];
        this._listeners[type].push(listener);
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    off(type, listener) {
        if (!type)
            this._listeners = {};
        if (!this._listeners[type])
            return;
        if (!listener)
            this._listeners[type] = [];
        else {
            /** @type {?} */
            var idx = this._listeners[type].indexOf(listener);
            if (idx >= 0)
                this._listeners[type].splice(idx, 1);
        }
    }
    /**
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    notify(type, ...options) {
        if (!this._listeners[type])
            return;
        /** @type {?} */
        var args = Array.prototype.slice.call(arguments, 1);
        this._listeners[type].forEach(function (l) { l.apply(null, args); });
    }
}
if (false) {
    /** @type {?} */
    Listener.prototype._listeners;
}
export default class MapInstance extends Listener {
    /**
     * @param {?} key
     */
    constructor(key) {
        super();
        this.setHttpClient(new XHRHttpClient());
        this.setServiceFactory(ServiceFactory);
        //generate random key (see factory below)
        this._key = key || Math.ceil(Math.random() * 9999);
        //registry id of current map if available
        this._mapId = null,
            //definition of map (ie, from server)
            this._mapDef = this.initializeMapDefinition(),
            //primary map instance (ie, leaflet)
            this._mapInstance = null,
            //default map extent (if map doesn't have one for being saved)
            this._defaultExtent = null,
            //current base layer object and leaflet instance
            this._baseLayerDef = null,
            this._baseLayer = null,
            //set definitions of layer states (including layer info) on map
            this._layerStates = [],
            //map layer def ids with leaflet instances
            this._layerCache = {},
            //errors generated by layers loading
            this._layerErrors = [],
            this._layerErrorHandler = function (e) {
                console.log(`MapInstance.defaultLayerErrorHandler() - ${e.id} : ${e.message}`);
            },
            //layer used to store features on map
            this._featureLayer = null,
            this._featureLayerVisible = true,
            //set of registered map tools
            this._tools = [],
            //state management
            this.state = { dirty: false }; // jshint ignore:line
        this._geoJsonLayerOpts = {
            style: function (feature) {
                if (feature.properties.style)
                    return feature.properties.style;
            },
            onEachFeature: function (feature, layer) {
                /** @type {?} */
                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };
                if (~feature.geometry.type.indexOf('Point')) {
                    style.fillOpacity = 0.9;
                }
                /** @type {?} */
                var props = feature.properties = feature.properties || {};
                if (feature.properties.id === undefined || feature.properties.id === null)
                    feature.properties.id = Math.floor(Math.random() * 999999);
                feature.properties.label = props.label || props.title || props.name || "Untitled " + feature.geometry.type + " Feature";
                feature.properties.description = props.description || props.desc || "This feature needs a description!";
                feature.properties.style = props.style || style;
                layer.bindTooltip(props.label);
                /*
                                toggle: setLabelNoHide(bool)
                                it may only exist on markers!
                                */
            },
            pointToLayer: function (feature, latlng) {
                /** @type {?} */
                var style = feature.properties.style || {};
                style.radius = style.radius || 4;
                style.weight = style.weight || 2;
                style.color = style.color || '#03f';
                style.opacity = style.opacity || 0.9;
                style.fillOpacity = style.opacity;
                style.fillColor = style.color;
                return circleMarker(latlng, style);
            }
        };
    }
    /**
     * @return {?}
     */
    dispose() {
        this.destroyMap();
        this.svcCache = null;
        this.serviceFactory = null;
        this.httpClient = null;
        this._key = null;
        this._mapId = null;
        this._mapDef = null;
        this._mapInstance = null;
        this._defaultExtent = null;
        this._baseLayerDef = null;
        this._baseLayer = null;
        this._layerStates = null;
        this._layerCache = null;
        this._layerErrors = null;
        this._featureLayer = null;
        this._featureLayerVisible = true;
        this._tools = null;
        this.state = null;
        this._geoJsonLayerOpts = null;
    }
    /**
     * @return {?}
     */
    getKey() {
        return this._key;
    }
    /**
     * Override default (JQuery-based) map service used by this instance
     * @deprecated use setServiceFactory instead
     * @param {?} mapService - service to use to CRUD map objects
     * @return {?}
     */
    setService(mapService) {
        // this.mapService = mapService;
    }
    /**
     * @param {?} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     * @return {?}
     */
    setServiceFactory(factory) {
        this.svcCache = {}; //wipe out cached services
        this.serviceFactory = factory;
    }
    /**
     * @param {?} httpClient - HttpClient impl to use with the new factory
     * @return {?}
     */
    setHttpClient(httpClient) {
        this.svcCache = {}; //wipe out cached services
        this.httpClient = httpClient;
    }
    /**
     * @param {?} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {?} item service implementation for the requested type
     */
    getService(type) {
        if (!this.svcCache[type])
            this.svcCache[type] = this.serviceFactory(type, Config["ualUrl"], this.httpClient);
        return this.svcCache[type];
    }
    /**
     * @param {?} fn - callback when an error is encountered
     * @return {?}
     */
    setErrorHandler(fn) {
        this._layerErrorHandler = fn;
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerStateIndex(layerId) {
        if (!layerId)
            return -1;
        for (let i = 0; i < this._layerStates.length; ++i) {
            if (this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {
                return i;
            }
        }
        return -1;
        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerState(layerId) {
        /** @type {?} */
        let index = this.getLayerStateIndex(layerId);
        return index >= 0 ? this._layerStates[index] : null;
    }
    /**
     * @return {?}
     */
    initializeMapDefinition() {
        return {
            type: ItemTypes.MAP,
            title: "My New Map",
            label: "My New Map",
            description: "This map needs a description",
            createdBy: null,
            baseLayer: this._baseLayerDef,
            layers: [],
            keywords: [],
            themes: [],
            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']
        };
    }
    /**
     * @param {?=} metadata object
     * @return {?} object definition of the current map suitable for sending to WMVR
     */
    getMapResourceContent(metadata) {
        metadata = metadata || {};
        //map layers
        metadata.layers = this._layerStates.map(state => {
            /** @type {?} */
            let result = {
                visibility: state.visibility || true,
                opacity: isNaN(state.opacity) ? 1.0 : state.opacity * 1,
                layer: {
                    id: state.layer.id,
                    uri: state.layer.uri,
                    label: state.layer.label
                }
            };
            return result;
        });
        // ... UAL should support accepting just an id here, so we'll do just that
        metadata.baseLayer = {
            id: this._baseLayerDef.id,
            uri: this._baseLayerDef.uri,
            label: this._baseLayerDef.label
        };
        metadata.annotations = this._featureLayer ?
            { title: "Map Features", geoJSON: this._featureLayer.toGeoJSON() } : null;
        /** @type {?} */
        let extent = this._mapInstance.getBounds();
        metadata.extent = {
            minx: extent.getWest(),
            miny: extent.getSouth(),
            maxx: extent.getEast(),
            maxy: extent.getNorth()
        };
        return metadata;
    }
    /**
     * @return {?} Leaflet toolbar
     */
    getDrawControlToolbar() {
        if (!(/** @type {?} */ (this._mapInstance)).drawControl)
            return null;
        /** @type {?} */
        var toolbars = (/** @type {?} */ (this._mapInstance)).drawControl._toolbars;
        /** @type {?} */
        var toolbar = null;
        for (var key in toolbars) {
            if (toolbars.hasOwnProperty(key)) {
                if (toolbars[key]._modes) {
                    toolbar = toolbars[key];
                    break;
                }
            }
        }
        return toolbar;
    }
    /**
     * @param {?} error Leaflet tile load error (.target is layer, .tile is image)
     * @return {?}
     */
    handleLayerError(error) {
        // console.log("MapInstance.handleLayerError() - " +
        //     "Layer's tile failed to load: " + error.tile.src);
        if (!this._layerCache) {
            console.log("Unable to find layer in layer cache. Layer error is " + error);
            return;
        }
        /** @type {?} */
        var layer = error.target;
        for (var id in this._layerCache) {
            if (this._layerCache[id] === layer) {
                this.processLayerError(error, id);
                break;
            }
        }
    }
    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     * @param {?} error
     * @param {?} id
     * @return {?}
     */
    processLayerError(error, id) {
        /** @type {?} */
        var finder = (l) => { return l.id === id || (l.layer && l.layer.id === id); };
        if (!this._layerErrors.find(finder)) {
            /** @type {?} */
            let obj = this.logLayerError(id, "Layer ('" + id + "') failed to completely load. " +
                "It may be inaccessible or misconfigured.");
            /** @type {?} */
            var url = (/** @type {?} */ (error)).tile.src;
            /** @type {?} */
            var params = { id: id };
            url.substring(url.indexOf("?") + 1, url.length).split('&').forEach(function (param) {
                /** @type {?} */
                var p = param.split('=');
                params[p[0]] = p[1];
            });
            /** @type {?} */
            let layerService = /** @type {?} */ (this.getService(ItemTypes.LAYER));
            if (layerService) {
                layerService.validate(id, params)
                    .catch(e => {
                    /** @type {?} */
                    var def = this._layerStates.find(finder);
                    if (def) {
                        obj.message = "Layer '" + def.layer.label + "' failed to completely load. " +
                            "Reported cause: " + e.message;
                    }
                    this.notify('layer:error', obj);
                });
            }
        }
    }
    /**
     * @param {?} layerId - identifier of layer generating the error
     * @param {?} errorMsg - message of the error
     * @return {?}
     */
    logLayerError(layerId, errorMsg) {
        /** @type {?} */
        let err = { id: layerId, message: errorMsg };
        this._layerErrors.push(err);
        if (this._layerErrorHandler) {
            this._layerErrorHandler(err);
        }
        return err;
    }
    /**
     * @param {?=} event
     * @param {...?} options
     * @return {?}
     */
    touch(event, ...options) {
        this.state.dirty = true;
        if (event) {
            if (arguments.length > 1) {
                this.notify.apply(this, Array.prototype.slice.call(arguments));
            }
            else
                this.notify(event);
            // console.log("Dirtying map for " + event);
        }
        // else console.log("Dirtying map");
    }
    /**
     * @return {?}
     */
    clean() {
        // console.log("Cleaning map");
        this.state.dirty = false;
    }
    /**
     * @param {?} map
     * @return {?}
     */
    setMap(map) { this._mapInstance = map; }
    /**
     * @return {?} map instance
     */
    getMap() { return this._mapInstance; }
    /**
     * @return {?} definition of map
     */
    getMapDefinition() { return this._mapDef; }
    /**
     * @return {?} identifier of map
     */
    getMapId() { return this._mapId; }
    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param {?} lat number
     * @param {?} lng number
     * @param {?=} zoom number (optional)
     * @return {?}
     */
    setView(lat, lng, zoom) {
        /** @type {?} */
        let z = zoom;
        if (typeof (z) === 'undefined')
            z = this._mapInstance.getZoom();
        this._mapInstance.setView([lat, lng], z);
        this.touch('map:view:changed');
    }
    /**
     * Retrieve the current center of the map
     * @return {?} [lat,lng]
     */
    getView() {
        /** @type {?} */
        var latLng = this._mapInstance.getCenter();
        return [latLng.lat, latLng.lng];
    }
    /**
     * @return {?} integer current zoom level of the map
     */
    getZoom() {
        return this._mapInstance.getZoom();
    }
    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     * @return {?}
     */
    zoomToDefault() {
        if (!this._mapInstance)
            return;
        if (this._defaultExtent) {
            this._mapInstance.fitBounds([
                [this._defaultExtent.miny, this._defaultExtent.minx],
                [this._defaultExtent.maxy, this._defaultExtent.maxx]
            ]);
        }
        else {
            console.log("MapInstance.zoomToDefault() - No default extent specified");
            this._mapInstance.setView([38, -96], 5);
        }
        try {
            this.touch('map:view:changed');
        }
        catch (e) { }
    }
    /**
     * @param {?} extent - either a GP extent object or Leaflet LatLngBounds object
     * @return {?}
     */
    setExtent(extent) {
        if (!extent)
            return;
        if (typeof (extent.minx) !== 'undefined' &&
            typeof (extent.miny) !== 'undefined' &&
            typeof (extent.maxx) !== 'undefined' &&
            typeof (extent.maxy) !== 'undefined') {
            //GP model extent
            this._mapInstance.fitBounds([
                [extent.miny, extent.minx],
                [extent.maxy, extent.maxx]
            ]);
        }
        else if (typeof (extent.getWest) !== 'undefined') {
            //L.LatLngBounds
            this._mapInstance.fitBounds(extent);
        }
        else {
        }
    }
    /**
     * @param {?} layer Leaflet Layer instance or object definition
     * @return {?}
     */
    setBaseLayer(layer) {
        /** @type {?} */
        let promise = null;
        if (!layer) {
            /** @type {?} */
            let svc = /** @type {?} */ (this.getService(ItemTypes.LAYER));
            promise = DefaultBaseLayer.get(svc);
        }
        else
            promise = Promise.resolve(layer);
        promise.then(layer => {
            /** @type {?} */
            let leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                console.log("Warning: MapInstance could not create base " +
                    "layer for '" + layer.id + "'");
                return;
            }
            this._mapInstance.addLayer(leafletLayer);
            (/** @type {?} */ (leafletLayer)).setZIndex(0);
            /** @type {?} */
            let oldBaseLayer = this._baseLayer;
            if (oldBaseLayer) {
                this._mapInstance.removeLayer(oldBaseLayer);
            }
            //remember new base layer
            this._baseLayer = leafletLayer;
            this._baseLayerDef = layer;
            //will notify listeners
            this.touch('baselayer:changed', layer, leafletLayer);
            // this.notify('baselayer:changed', layer, leafletLayer);
        })
            .catch(e => {
            console.log(`MapInstance.setBaseLayer() - Error getting base layer for map : ${e.message}`);
            this.logLayerError(layer.id, "Error setting baselayer on map " +
                "because of the following error(s): " + e.message);
        });
    }
    /**
     * @return {?} array of base layers definitions that can be used
     */
    getBaseLayer() { return this._baseLayerDef; }
    /**
     * @return {?} list of layer states containing layer information
     */
    getLayers() { return this._layerStates; }
    /**
     * @return {?}
     */
    getLayerErrors() { return this._layerErrors; }
    /**
     * @return {?}
     */
    clearLayerErrors() {
        this._layerErrors = [];
        this.notify('layer:error');
    }
    /**
     * @return {?}
     */
    clearOverlays() {
        if (!this._layerCache)
            return;
        for (var i = this._layerStates.length - 1; i >= 0; --i) {
            /** @type {?} */
            var state = this._layerStates[i];
            /** @type {?} */
            var layerInstance = this._layerCache[state.layer.id];
            if (layerInstance) {
                layerInstance.off("layer:error");
                this._layerCache[state.layer.id] = null;
                this._mapInstance.removeLayer(layerInstance);
            }
        }
        this._layerStates = [];
        this.touch('layers:changed');
        //TODO stop listening for layer events
    }
    /**
     * @param {?} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     * @return {?}
     */
    addLayers(layers) {
        if (!this._layerCache) {
            console.log("WARN: attempting to add layers to an empty cache");
            return;
        }
        if (!this._layerCache) {
            console.log("WARN: Attempting to add layers to a map with no layer cache");
            return;
        }
        if (!layers)
            return;
        if (typeof (layers.push) === 'undefined') {
            layers = [layers];
        }
        layers.forEach((obj, index) => {
            /** @type {?} */
            let layer = null;
            /** @type {?} */
            let state = null;
            if (obj.type && obj.type === ItemTypes.LAYER) { //is a layer
                //is a layer
                layer = obj;
            }
            else if (obj.layer) { //is layer state
                //is layer state
                layer = obj.layer; // containing a layer
                state = obj;
            }
            if (!layer) {
                console.log("MapInstance.addLayers() - layer (" + index +
                    ") is not a Layer or a Layer state. Ignoring...");
                return; //layer info is missing, skip it
            }
            //DT-442 prevent adding layer that already exists on map
            if (this._layerCache[layer.id])
                return;
            if (!state) {
                try {
                    /** @type {?} */
                    let layerCopy = JSON.parse(JSON.stringify(layer));
                    state = {
                        opacity: 1,
                        visibility: true,
                        layer: layerCopy
                    };
                }
                catch (e) {
                    throw new Error("Unable to add layer to map because of " + e.message);
                }
            }
            /** @type {?} */
            let z = layers.length - index;
            state.zIndex = z;
            this.addLayerWithState(layer, state);
        });
        this.touch('layers:changed');
    }
    /**
     * @param {?} layer - GeoPlatform Layer instance
     * @param {?} state - GeoPlatform Layer State
     * @return {?}
     */
    addLayerWithState(layer, state) {
        /** @type {?} */
        var leafletLayer = null;
        try {
            if (!layer || !state)
                throw new Error("Invalid argument, missing layer and or state");
            leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                /** @type {?} */
                let msg = "Could not create leaflet instance for GP Layer '" + layer.id + "'.";
                if (!layer.services || !layer.services.length) {
                    msg += '  The layer instance has no services included, ' +
                        'which will prevent most layers from being displayed.';
                }
                throw new Error(msg);
            }
        }
        catch (e) {
            this.logLayerError(layer.id, "Layer '" + layer.label + "' could not be added to the " +
                "map instance; " + e.message);
        }
        if (!leafletLayer)
            return;
        //cache leaflet object first
        if (this._layerCache)
            this._layerCache[layer.id] = leafletLayer;
        //listen for layer errors so we can inform the user
        // that a layer hasn't been loaded in a useful way
        leafletLayer.on('tileerror', (e) => { this.handleLayerError(e); });
        this._mapInstance.addLayer(leafletLayer);
        if (!isNaN(state.zIndex) && leafletLayer.setZIndex)
            leafletLayer.setZIndex(state.zIndex);
        this._layerStates.push(state);
        this.notify('layer:added', layer, leafletLayer);
        // if layer is initially "off" or...
        // if layer is initially not 100% opaque
        if (!state.visibility || state.opacity < 1) {
            // initialize layer visibility and opacity async, or else
            // some of the layers won't get properly initialized
            setTimeout((layer, state) => {
                this.setLayerVisibility(layer, state.visibility);
                this.setLayerOpacity(layer, state.opacity);
                //TODO notify of change
                //DT-2102 timeout needs to be large enough or else
                // feature layers won't get opacity updated on map load
            }, 2000, leafletLayer, state);
        }
    }
    /**
     * @param {?} from - position of layer being moved
     * @param {?} to - desired position to move layer to
     * @return {?}
     */
    moveLayer(from, to) {
        if (!this._layerCache)
            return;
        if (!this._layerCache)
            return;
        if (isNaN(from))
            return;
        //end of list
        if (isNaN(to))
            to = this._layerStates.length - 1;
        /** @type {?} */
        let copy = this._layerStates.splice(from, 1)[0]; //grab layer being moved
        this._layerStates.splice(to, 0, copy);
        for (let z = 1, i = this._layerStates.length - 1; i >= 0; --i, ++z) {
            /** @type {?} */
            let layerState = this._layerStates[i];
            /** @type {?} */
            let layerInstance = this._layerCache[layerState.layer.id];
            if (layerInstance) {
                layerInstance.setZIndex(z);
                layerState.zIndex = z;
            }
        }
        this.touch('layers:changed', this.getLayers());
    }
    /**
     *
     * @param {?} id
     * @return {?}
     */
    removeLayer(id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            let index = this.getLayerStateIndex(id);
            // console.log("MapInstance.removeLayer(" + id + ")");
            if (index >= 0 && index < this._layerStates.length)
                this._layerStates.splice(index, 1);
            //stop listening for errors
            layerInstance.off("layer:error");
            //remove layer from map
            this._mapInstance.removeLayer(layerInstance);
            //remove layer from cache
            this._layerCache[id] = null;
        }
        this.touch('layers:changed');
    }
    /**
     *
     * @param {?} id
     * @return {?}
     */
    toggleLayerVisibility(id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            let state = this.getLayerState(id);
            state.visibility = !state.visibility;
            if (layerInstance._currentImage) {
                //ESRI Image Service layers have an IMG element
                // that gets modified and replaced every map event (zoom/pan)
                // so we can't just toggle classes like on other layers.
                //Instead, we need to use the ESRI setOpacity method to toggle
                // but need to update layer state as well.
                layerInstance.setOpacity(state.visibility ? 1 : 0);
                state.opacity = layerInstance.getOpacity();
                return;
            }
            this.setLayerVisibility(layerInstance, state.visibility);
        }
    }
    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} visible - flag indicating visibility of layer
     * @return {?}
     */
    setLayerVisibility(layerInstance, visible) {
        if ((/** @type {?} */ (layerInstance)).setVisibility) {
            //using custom method provided in src/layer/module.js
            (/** @type {?} */ (layerInstance)).setVisibility(visible);
        }
        else if ((/** @type {?} */ (layerInstance))._container) {
            /** @type {?} */
            let el = jQuery((/** @type {?} */ (layerInstance))._container);
            // if(visible) el.removeClass("invisible");
            // else el.addClass('invisible');
            el.css({ 'display': visible ? '' : 'none' });
        }
        this.touch('map:layer:changed');
    }
    /**
     *
     * @param {?} id
     * @param {?} opacity
     * @return {?}
     */
    updateLayerOpacity(id, opacity) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        //if layer id is for base layer...
        if (!layerInstance && this._baseLayerDef.id === id) {
            layerInstance = this._baseLayer;
        }
        //adjust rendered leaflet layer
        opacity = this.setLayerOpacity(layerInstance, opacity);
        /** @type {?} */
        let state = this.getLayerState(id);
        if (state)
            state.opacity = opacity;
    }
    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} opacity - value between 0 and 1.0 or 0 and 100
     * @return {?} normalized opacity value between 0 and 1.0
     */
    setLayerOpacity(layerInstance, opacity) {
        if (layerInstance && (/** @type {?} */ (layerInstance)).setOpacity) {
            if (opacity > 1.0)
                opacity = opacity / 100.0;
            (/** @type {?} */ (layerInstance)).setOpacity(opacity);
            this.touch('map:layer:changed');
        }
        return opacity;
    }
    /**
     * @param {?} gpLayer
     * @return {?} Leaflet layer instance representing that layer or null
     */
    getLeafletLayerFor(gpLayer) {
        if (!gpLayer || !this._layerCache)
            return null;
        /** @type {?} */
        let leafletLayer = this._layerCache[gpLayer.id];
        return leafletLayer || null;
    }
    /**
     *
     * @param {?} layerId
     * @return {?}
     */
    toggleGetFeatureInfo(layerId) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[layerId];
        if (layerInstance) {
            if (typeof (layerInstance.enableGetFeatureInfo) !== 'undefined') {
                if (layerInstance.isGetFeatureInfoEnabled()) {
                    layerInstance.disableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).removeClass('selectable-cursor');
                }
                else {
                    layerInstance.enableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).addClass('selectable-cursor');
                }
            }
        }
    }
    /**
     * @return {?} array of features on the map
     */
    getFeatures() {
        if (this._featureLayer) {
            /** @type {?} */
            let geojson = this._featureLayer.toGeoJSON();
            return (/** @type {?} */ (geojson)).features;
        }
        return [];
    }
    /**
     * @param {?} json geojson object or array of geojson objects
     * @return {?}
     */
    addFeatures(json) {
        if (!json)
            return;
        if (typeof (json.push) !== 'undefined') {
            //array of features
            for (var i = 0; i < json.length; ++i)
                this.addFeature(json[i], false);
            this.touch('features:changed');
        }
        else if (json.features) {
            this.addFeatures(json.features);
        }
        else { //single feature
            //single feature
            this.addFeature(json, true);
        }
    }
    /**
     * @param {?} json geojson object
     * @param {?=} fireEvent
     * @return {?}
     */
    addFeature(json, fireEvent) {
        // var type = json.type;
        // var coordinates = json.coordinates;
        if (!this._featureLayer) {
            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);
            this._featureLayer = featureGroup().addTo(this._mapInstance);
        }
        /** @type {?} */
        var opts = jQuery.extend({}, this._geoJsonLayerOpts);
        geoJSON(json, opts).eachLayer((l) => this.addFeatureLayer(l));
        if (typeof (fireEvent) === 'undefined' || fireEvent === true)
            this.touch('features:changed');
        else
            this.touch();
        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));
    }
    /**
     * @param {?} featureJson object defining a GeoJSON feature
     * @return {?}
     */
    updateFeature(featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            (/** @type {?} */ (layer)).feature = featureJson;
            //update style
            layer.setStyle(featureJson.properties.style);
            /** @type {?} */
            var label = featureJson.properties.label ||
                "Untitled " + featureJson.geometry.type + " Feature";
            layer.bindTooltip(label);
            // layer.redraw();
            this.touch("map:feature:changed");
        }
    }
    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param {?} featureJson object defining GeoJSON feature
     * @return {?}
     */
    replaceFeature(featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            //remove existing
            this._featureLayer.removeLayer(layer);
            //add replacement
            geoJSON(featureJson, this._geoJsonLayerOpts)
                .eachLayer((l) => this.addFeatureLayer(l));
            this.touch("map:feature:changed");
        }
    }
    /**
     * @param {?} featureId identifier of feature to focus the map on
     * @return {?}
     */
    focusFeature(featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer) {
            if (typeof (layer.getBounds) !== 'undefined') {
                /** @type {?} */
                let extent = layer.getBounds();
                this._mapInstance.fitBounds(extent);
            }
            else if (typeof ((/** @type {?} */ (layer)).getLatLng) !== 'undefined') {
                /** @type {?} */
                let latLng = (/** @type {?} */ (layer)).getLatLng();
                this._mapInstance.panTo(latLng);
            }
            else {
                console.log("MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng");
            }
        }
        else {
            console.log("MapInstance.focusFeature() - Cannot focus feature because it has no layer");
        }
    }
    /**
     * @param {?} featureId : string
     * @return {?}
     */
    removeFeature(featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer && this._featureLayer) {
            this._featureLayer.removeLayer(layer);
            this.touch('features:changed');
        }
    }
    /**
     *
     * @return {?}
     */
    removeFeatures() {
        if (this._featureLayer) {
            this._featureLayer.clearLayers();
            this.touch("features:changed");
        }
    }
    /**
     *
     * @param {?=} featureId
     * @return {?}
     */
    getFeatureLayer(featureId) {
        //if no feature was specified, return root feature layer
        if (!featureId)
            return this._featureLayer;
        //otherwise, find feature...
        if (!this._featureLayer)
            return null;
        /** @type {?} */
        var features = this._featureLayer.getLayers();
        for (var i = 0; i < features.length; ++i) {
            if ((/** @type {?} */ (features[i])).feature &&
                (/** @type {?} */ (features[i])).feature.properties.id === featureId) {
                return (/** @type {?} */ (features[i]));
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    toggleFeaturesLayer() {
        if (!this._featureLayer)
            return false; //ignore if not rendered yet
        this._featureLayerVisible = !this._featureLayerVisible;
        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);
        return this._featureLayerVisible;
    }
    /**
     * @param {?} feature - Leaflet feature instance
     * @param {?} visibility - flag
     * @return {?}
     */
    setFeatureVisibility(feature, visibility) {
        this.setFeatureLayerVisibility(feature, visibility);
    }
    /**
     * @return {?}
     */
    getFeaturesLayerVisibility() {
        return this._featureLayerVisible;
    }
    /**
     * @param {?} layer
     * @return {?}
     */
    addFeatureLayer(layer) {
        this._addFeatureLayer(layer);
        this.touch("features:changed");
    }
    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {?} layer
     * @return {?}
     */
    _addFeatureLayer(layer) {
        if (!(/** @type {?} */ (layer)).feature && layer instanceof LayerGroup) {
            layer.eachLayer((child) => {
                this._addFeatureLayer(child);
            });
        }
        else {
            this._featureLayer.addLayer(layer);
        }
    }
    /**
     * @param {?} layer
     * @param {?} visibility
     * @return {?}
     */
    setFeatureLayerVisibility(layer, visibility) {
        if (!layer)
            return;
        this._featureLayerVisible = visibility;
        if (layer.getLayers) {
            layer.getLayers().forEach((child) => {
                this.setFeatureLayerVisibility(child, visibility);
            });
        }
        else {
            /** @type {?} */
            let container = layer._container || layer._path;
            if (container)
                container.style.display = visibility ? '' : 'none';
        }
    }
    /**
     * @param {?} metadata
     * @return {?} resolving persisted map
     */
    save(metadata) {
        return this.saveMap(metadata);
    }
    /**
     * @param {?} md object containing metadata properties for map
     * @return {?}
     */
    saveMap(md) {
        /** @type {?} */
        let metadata = md || {};
        /** @type {?} */
        const gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';
        metadata.resourceTypes = metadata.resourceTypes || [];
        if (metadata.resourceTypes.indexOf(gpMapType) < 0)
            metadata.resourceTypes.push(gpMapType);
        /** @type {?} */
        var content = this.getMapResourceContent(metadata);
        //ensure the two name properties line up
        if (content.title && content.title !== content.label) {
            content.label = content.title;
        }
        else if (content.label && !content.title) {
            content.title = content.label;
        }
        // console.log("Updating: " + JSON.stringify(map));
        return new Promise((resolve, reject) => {
            this.getService(ItemTypes.MAP).save(content)
                .then(result => {
                //track new map's info so we can update it with next save
                if (!this._mapId)
                    this._mapId = result.id;
                this._mapDef = result;
                this._defaultExtent = result["extent"];
                this.clean();
                resolve(result);
            })
                .catch(err => {
                console.log("MapCore MapInstance.saveMap() - " +
                    "The requested map could not be saved because: " + err.message);
                /** @type {?} */
                let e = new Error("The requested map could not be saved because of the following error(s): " +
                    err.message);
                reject(e);
            });
        });
    }
    /**
     * Retrieve a map's descriptor from the registry
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    fetchMap(mapId) {
        //Having to send cache busting parameter to avoid CORS header cache
        // not sending correct Origin value
        return this.getService(ItemTypes.MAP).get(mapId);
    }
    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    loadMap(mapId) {
        return new Promise((resolve, reject) => {
            this.fetchMap(mapId).then(map => {
                if (!map) {
                    throw new Error("The requested map ('" + mapId +
                        "') came back null");
                }
                else if (typeof (map) === 'string') {
                    throw new Error("The requested map ('" + mapId +
                        "') came back as a string");
                }
                else if ((/** @type {?} */ (map)).message) {
                    throw new Error("There was an error loading the requested map ('" +
                        mapId + "'): " + (/** @type {?} */ (map)).message);
                }
                //loading a map by its ID, so we need to increment it's view count
                if ('development' !== Config["env"]) {
                    setTimeout((map) => {
                        /** @type {?} */
                        let views = map.statistics ? (map.statistics.numViews || 0) : 0;
                        /** @type {?} */
                        let patch = [{ op: 'replace', path: '/statistics/numViews', value: views + 1 }];
                        this.getService(ItemTypes.MAP).patch(map.id, patch)
                            // this.mapService.patch(map.id, patch)
                            .then(updated => { map.statistics = updated["statistics"]; })
                            .catch(e => {
                            console.log("MapInstance.saveMap() - Error updating view " +
                                "count for map ('" + mapId + "'): " + e);
                        });
                    }, 1000, map);
                }
                //load the map into the viewer
                this.loadMapFromObj(map);
                resolve(map);
            })
                .catch(err => {
                console.log("MapInstance.loadMap() - " +
                    "The requested map could not be loaded because " + err.message);
                /** @type {?} */
                let e = new Error("The requested map ('" + mapId +
                    "') could not be loaded because of the following error(s): " +
                    err.message);
                reject(e);
            });
        });
    }
    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param {?} map object
     * @return {?}
     */
    loadMapFromObj(map) {
        // console.log("Loading Map Object");
        // console.log(map);
        this._mapId = map.id;
        this._mapDef = map;
        map.extent = this.ensureExtent(map.extent);
        //set extent from loaded map
        this._defaultExtent = map.extent;
        /** @type {?} */
        var extent = map.extent;
        //remove existing layers
        this._mapInstance.eachLayer((l) => {
            this._mapInstance.removeLayer(l);
        });
        this._layerCache = {};
        this._layerStates = [];
        //set new base layer
        this.setBaseLayer(map.baseLayer);
        //add layers from loaded map
        this.addLayers(map.layers);
        //add features
        if (map.annotations && map.annotations.geoJSON) {
            /** @type {?} */
            let fc = map.annotations.geoJSON;
            if (fc.features)
                this.addFeatures(fc.features);
            else
                this.addFeatures([fc]);
        }
        this._mapInstance.fitBounds([
            [extent.miny, extent.minx],
            [extent.maxy, extent.maxx]
        ]);
        this.clean();
        this.notify('map:loaded', map);
    }
    /**
     * @param {?} extent
     * @return {?} corrected or default extent
     */
    ensureExtent(extent) {
        /** @type {?} */
        let west = !extent || isNaN(extent.minx) ? -179.0 : extent.minx * 1.0;
        /** @type {?} */
        let east = !extent || isNaN(extent.maxx) ? 179.0 : extent.maxx * 1.0;
        /** @type {?} */
        let south = !extent || isNaN(extent.miny) ? -89.0 : extent.miny * 1.0;
        /** @type {?} */
        let north = !extent || isNaN(extent.maxy) ? 89.0 : extent.maxy * 1.0;
        /** @type {?} */
        let t;
        if (west > east) {
            t = Math.min(west, east);
            east = Math.max(west, east);
            west = t;
        }
        if (south > north) {
            t = Math.min(south, north);
            north = Math.max(south, north);
            south = t;
        }
        //prevent out-of-bounds extents
        if (west < -180.0)
            west = -179.0;
        if (east > 180.0)
            east = 179.0;
        if (south < -90.0)
            south = -89.0;
        if (north > 90.0)
            north = 89.0;
        return { minx: west, miny: south, maxx: east, maxy: north };
    }
    /**
     *
     * @return {?}
     */
    destroyMap() {
        // console.log("Destroying Map");
        this._mapInstance = null;
        this._layerCache = null;
        this._layerStates = null;
        this._featureLayer = null;
    }
    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     * @param {?} mapToUse
     * @return {?}
     */
    setAsNewMap(mapToUse) {
        this._mapId = null;
        this._mapDef = mapToUse || this.initializeMapDefinition();
    }
    /**
     * @param {?} id
     * @param {?} tool
     * @return {?}
     */
    registerTool(id, tool) {
        this._tools[id] = tool;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    unregisterTool(id) {
        this._tools[id] = null;
    }
    /**
     * @param {?} id
     * @param {?} finish
     * @return {?}
     */
    enableTool(id, finish) {
        if (!this._tools[id])
            return false;
        this._tools[id].activate(function () {
            this.notify('tool:disabled', id);
        });
        this.notify('tool:enabled', id);
    }
    /**
     * @return {?}
     */
    cacheMap() {
        if (this.state && this.state.dirty) {
            /** @type {?} */
            var map = this.getMapResourceContent();
            //use exploded layer info
            map.layers = this._layerStates.slice(0);
            // $sessionStorage.map = map;
        }
    }
    /**
     * @return {?}
     */
    restoreMap() {
        // if($sessionStorage.map) {
        //     console.log("Restoring cached map");
        //     let map = $sessionStorage.map;
        //     // console.log(JSON.stringify(map));
        //     $sessionStorage.map = null;
        //     this.loadMapFromObj(map);
        // }
    }
}
if (false) {
    /** @type {?} */
    MapInstance.prototype.svcCache;
    /** @type {?} */
    MapInstance.prototype.serviceFactory;
    /** @type {?} */
    MapInstance.prototype.httpClient;
    /** @type {?} */
    MapInstance.prototype._key;
    /** @type {?} */
    MapInstance.prototype._mapId;
    /** @type {?} */
    MapInstance.prototype._mapDef;
    /** @type {?} */
    MapInstance.prototype._mapInstance;
    /** @type {?} */
    MapInstance.prototype._defaultExtent;
    /** @type {?} */
    MapInstance.prototype._baseLayerDef;
    /** @type {?} */
    MapInstance.prototype._baseLayer;
    /** @type {?} */
    MapInstance.prototype._layerStates;
    /** @type {?} */
    MapInstance.prototype._layerCache;
    /** @type {?} */
    MapInstance.prototype._layerErrors;
    /** @type {?} */
    MapInstance.prototype._layerErrorHandler;
    /** @type {?} */
    MapInstance.prototype._featureLayer;
    /** @type {?} */
    MapInstance.prototype._featureLayerVisible;
    /** @type {?} */
    MapInstance.prototype._tools;
    /** @type {?} */
    MapInstance.prototype.state;
    /** @type {?} */
    MapInstance.prototype._geoJsonLayerOpts;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdGFuY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ2VvcGxhdGZvcm0vbWFwY29yZS8iLCJzb3VyY2VzIjpbIm1hcC9pbnN0YW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBRUEsT0FBTyxLQUFLLE1BQU0sTUFBTSxRQUFRLENBQUM7O0FBQ2pDLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUl0QixPQUFPLEVBRUgsWUFBWSxFQUFFLE9BQU8sRUFDckIsWUFBWSxFQUFnQixVQUFVLEVBQ3pDLE1BQU0sU0FBUyxDQUFDO0FBRWpCLE9BQU8sRUFDSCxNQUFNLEVBQUUsU0FBUyxFQUNqQixjQUFjLEVBQ2QsYUFBYSxFQUNoQixNQUFNLHFCQUFxQixDQUFDO0FBRTdCLE9BQU8sWUFBWSxNQUFNLGtCQUFrQixDQUFDO0FBRTVDLE9BQU8sZ0JBQWdCLE1BQU0sNEJBQTRCLENBQUM7QUFHMUQ7SUFJSTs7UUFFSSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztLQUN4Qjs7Ozs7O0lBRUQsRUFBRSxDQUFFLElBQUksRUFBRSxRQUFRO1FBQ2QsSUFBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ3hDOzs7Ozs7SUFFRCxHQUFHLENBQUUsSUFBSSxFQUFFLFFBQVE7UUFDZixJQUFHLENBQUMsSUFBSTtZQUFFLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO1FBQy9CLElBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU87UUFDbEMsSUFBRyxDQUFDLFFBQVE7WUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQzthQUNwQzs7WUFD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LENBQUMsQ0FBQyxDQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFDLEdBQUcsQ0FBQzs7UUFDckUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFDLEdBQUcsQ0FBQzs7UUFHckUsSUFBSSxDQUFDLENBQUM7UUFDTixJQUFHLElBQUksR0FBRyxJQUFJLEVBQUU7WUFDWixDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDekIsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzVCLElBQUksR0FBRyxDQUFDLENBQUM7U0FDWjtRQUNELElBQUcsS0FBSyxHQUFHLEtBQUssRUFBRTtZQUNkLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMzQixLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDL0IsS0FBSyxHQUFHLENBQUMsQ0FBQztTQUNiOztRQUdELElBQUcsSUFBSSxHQUFHLENBQUMsS0FBSztZQUFFLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQztRQUNoQyxJQUFHLElBQUksR0FBRyxLQUFLO1lBQUcsSUFBSSxHQUFJLEtBQUssQ0FBQztRQUNoQyxJQUFHLEtBQUssR0FBRyxDQUFDLElBQUk7WUFBRSxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDaEMsSUFBRyxLQUFLLEdBQUcsSUFBSTtZQUFHLEtBQUssR0FBSSxJQUFJLENBQUM7UUFFaEMsT0FBTyxFQUFFLElBQUksRUFBRyxJQUFJLEVBQUUsSUFBSSxFQUFHLEtBQUssRUFBRSxJQUFJLEVBQUcsSUFBSSxFQUFFLElBQUksRUFBRyxLQUFLLEVBQUUsQ0FBQztLQUNuRTs7Ozs7SUFNRCxVQUFVOztRQUVOLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO0tBQzdCOzs7Ozs7OztJQVFELFdBQVcsQ0FBRSxRQUFRO1FBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ25CLElBQUksQ0FBQyxPQUFPLEdBQUcsUUFBUSxJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO0tBQzdEOzs7Ozs7SUFPRCxZQUFZLENBQUUsRUFBRSxFQUFFLElBQUk7UUFDbEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDMUI7Ozs7O0lBRUQsY0FBYyxDQUFFLEVBQUU7UUFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztLQUMxQjs7Ozs7O0lBRUQsVUFBVSxDQUFFLEVBQUUsRUFBRSxNQUFNO1FBQ2xCLElBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztZQUFFLE9BQU8sS0FBSyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ3BDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0tBQ25DOzs7O0lBTUQsUUFBUTtRQUVKLElBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTs7WUFDL0IsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7O1lBRXZDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7O1NBRTNDO0tBQ0o7Ozs7SUFFRCxVQUFVOzs7Ozs7OztLQVFUO0NBRUoiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0ICogYXMganF1ZXJ5IGZyb20gXCJqcXVlcnlcIjtcbmNvbnN0IGpRdWVyeSA9IGpxdWVyeTtcblxuaW1wb3J0ICogYXMgUSBmcm9tIFwicVwiO1xuaW1wb3J0ICogYXMgZ2VvanNvbiBmcm9tICdnZW9qc29uJztcbmltcG9ydCB7XG4gICAgTWFwLCBMYXllciwgTGF0TG5nLCBMYXRMbmdCb3VuZHMsXG4gICAgY2lyY2xlTWFya2VyLCBnZW9KU09OLFxuICAgIGZlYXR1cmVHcm91cCwgRmVhdHVyZUdyb3VwLCBMYXllckdyb3VwXG59IGZyb20gJ2xlYWZsZXQnO1xuXG5pbXBvcnQge1xuICAgIENvbmZpZywgSXRlbVR5cGVzLFxuICAgIFNlcnZpY2VGYWN0b3J5LCBJdGVtU2VydmljZSwgTWFwU2VydmljZSwgTGF5ZXJTZXJ2aWNlLFxuICAgIFhIUkh0dHBDbGllbnRcbn0gZnJvbSAnQGdlb3BsYXRmb3JtL2NsaWVudCc7XG5cbmltcG9ydCBMYXllckZhY3RvcnkgZnJvbSAnLi4vbGF5ZXIvZmFjdG9yeSc7XG5pbXBvcnQgT1NNIGZyb20gXCIuLi9sYXllci9vc21cIjtcbmltcG9ydCBEZWZhdWx0QmFzZUxheWVyIGZyb20gJy4uL2xheWVyL2Jhc2VsYXllci1kZWZhdWx0JztcblxuXG5jbGFzcyBMaXN0ZW5lciB7XG5cbiAgICBfbGlzdGVuZXJzIDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vbGlzdGVuZXJzIHRvIGJlIHVucmVnaXN0ZXJlZCB1cG9uIGRlc3Ryb3lcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuXG4gICAgb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmKCF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIG9mZiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYoIXR5cGUpIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICBpZighdGhpcy5fbGlzdGVuZXJzW3R5cGVdKSByZXR1cm47XG4gICAgICAgIGlmKCFsaXN0ZW5lcikgdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmKGlkeCA+PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vdGlmeSh0eXBlLCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGlmKCF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pIHJldHVybjtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbihsKSB7IGwuYXBwbHkobnVsbCwgYXJncyk7IH0pO1xuICAgIH1cblxufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwSW5zdGFuY2UgZXh0ZW5kcyBMaXN0ZW5lciB7XG5cbiAgICBwcml2YXRlIHN2Y0NhY2hlICAgICAgICA6IGFueTtcbiAgICBwcml2YXRlIHNlcnZpY2VGYWN0b3J5ICA6IGFueTtcbiAgICBwcml2YXRlIGh0dHBDbGllbnQgICAgICA6IGFueTtcbiAgICBwdWJsaWMgX2tleSAgICAgICAgICAgIDogc3RyaW5nO1xuICAgIHByaXZhdGUgX21hcElkICAgICAgICAgIDogc3RyaW5nO1xuICAgIHByaXZhdGUgX21hcERlZiAgICAgICAgIDogYW55O1xuICAgIHByaXZhdGUgX21hcEluc3RhbmNlICAgIDogTWFwO1xuICAgIHByaXZhdGUgX2RlZmF1bHRFeHRlbnQgIDogYW55O1xuICAgIHByaXZhdGUgX2Jhc2VMYXllckRlZiAgIDogYW55O1xuICAgIHByaXZhdGUgX2Jhc2VMYXllciAgICAgIDogTGF5ZXI7XG4gICAgcHJpdmF0ZSBfbGF5ZXJTdGF0ZXMgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfbGF5ZXJDYWNoZSAgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfbGF5ZXJFcnJvcnMgICAgOiBhbnlbXTtcbiAgICBwcml2YXRlIF9sYXllckVycm9ySGFuZGxlciA6IEZ1bmN0aW9uO1xuICAgIHByaXZhdGUgX2ZlYXR1cmVMYXllciAgIDogRmVhdHVyZUdyb3VwO1xuICAgIHByaXZhdGUgX2ZlYXR1cmVMYXllclZpc2libGUgIDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF90b29scyAgICAgICAgICA6IGFueVtdO1xuICAgIHByaXZhdGUgc3RhdGUgICAgICAgICAgIDogYW55O1xuICAgIHByaXZhdGUgX2dlb0pzb25MYXllck9wdHMgOiBhbnk7XG5cblxuXG5cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnNldEh0dHBDbGllbnQobmV3IFhIUkh0dHBDbGllbnQoKSk7XG4gICAgICAgIHRoaXMuc2V0U2VydmljZUZhY3RvcnkoU2VydmljZUZhY3RvcnkpO1xuXG4gICAgICAgIC8vZ2VuZXJhdGUgcmFuZG9tIGtleSAoc2VlIGZhY3RvcnkgYmVsb3cpXG4gICAgICAgIHRoaXMuX2tleSA9IGtleSB8fCBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSo5OTk5KTtcblxuICAgICAgICAvL3JlZ2lzdHJ5IGlkIG9mIGN1cnJlbnQgbWFwIGlmIGF2YWlsYWJsZVxuICAgICAgICB0aGlzLl9tYXBJZCA9IG51bGwsXG5cbiAgICAgICAgLy9kZWZpbml0aW9uIG9mIG1hcCAoaWUsIGZyb20gc2VydmVyKVxuICAgICAgICB0aGlzLl9tYXBEZWYgPSB0aGlzLmluaXRpYWxpemVNYXBEZWZpbml0aW9uKCksXG5cbiAgICAgICAgLy9wcmltYXJ5IG1hcCBpbnN0YW5jZSAoaWUsIGxlYWZsZXQpXG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbCxcblxuICAgICAgICAvL2RlZmF1bHQgbWFwIGV4dGVudCAoaWYgbWFwIGRvZXNuJ3QgaGF2ZSBvbmUgZm9yIGJlaW5nIHNhdmVkKVxuICAgICAgICB0aGlzLl9kZWZhdWx0RXh0ZW50ID0gbnVsbCxcblxuICAgICAgICAvL2N1cnJlbnQgYmFzZSBsYXllciBvYmplY3QgYW5kIGxlYWZsZXQgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyRGVmID0gbnVsbCxcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyID0gbnVsbCxcblxuICAgICAgICAvL3NldCBkZWZpbml0aW9ucyBvZiBsYXllciBzdGF0ZXMgKGluY2x1ZGluZyBsYXllciBpbmZvKSBvbiBtYXBcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBbXSxcblxuICAgICAgICAvL21hcCBsYXllciBkZWYgaWRzIHdpdGggbGVhZmxldCBpbnN0YW5jZXNcbiAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZSA9IHt9LFxuXG4gICAgICAgIC8vZXJyb3JzIGdlbmVyYXRlZCBieSBsYXllcnMgbG9hZGluZ1xuICAgICAgICB0aGlzLl9sYXllckVycm9ycz0gW10sXG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE1hcEluc3RhbmNlLmRlZmF1bHRMYXllckVycm9ySGFuZGxlcigpIC0gJHtlLmlkfSA6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vbGF5ZXIgdXNlZCB0byBzdG9yZSBmZWF0dXJlcyBvbiBtYXBcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gbnVsbCxcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSA9IHRydWUsXG5cbiAgICAgICAgLy9zZXQgb2YgcmVnaXN0ZXJlZCBtYXAgdG9vbHNcbiAgICAgICAgdGhpcy5fdG9vbHMgPSBbXSxcblxuICAgICAgICAvL3N0YXRlIG1hbmFnZW1lbnRcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHsgZGlydHk6IGZhbHNlIH07IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICAgIHRoaXMuX2dlb0pzb25MYXllck9wdHMgID0ge1xuICAgICAgICAgICAgc3R5bGU6IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZihmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FYWNoRmVhdHVyZTogZnVuY3Rpb24oZmVhdHVyZSwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHsgd2VpZ2h0OiAyLCBjb2xvcjogJyMwM2YnLCBvcGFjaXR5OiAwLjksIHJhZGl1czogNCwgZmlsbENvbG9yOiAnIzAzZicsIGZpbGxPcGFjaXR5OiAwLjUgfTtcbiAgICAgICAgICAgICAgICBpZih+ZmVhdHVyZS5nZW9tZXRyeS50eXBlLmluZGV4T2YoJ1BvaW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZmlsbE9wYWNpdHkgPSAwLjk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmVhdHVyZS5wcm9wZXJ0aWVzID0gZmVhdHVyZS5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmKGZlYXR1cmUucHJvcGVydGllcy5pZCA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmUucHJvcGVydGllcy5pZCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjk5OTk5OSk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLmxhYmVsID0gcHJvcHMubGFiZWwgfHwgcHJvcHMudGl0bGUgfHwgcHJvcHMubmFtZSB8fCBcIlVudGl0bGVkIFwiICsgZmVhdHVyZS5nZW9tZXRyeS50eXBlICsgXCIgRmVhdHVyZVwiO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbiA9IHByb3BzLmRlc2NyaXB0aW9uIHx8IHByb3BzLmRlc2MgfHwgXCJUaGlzIGZlYXR1cmUgbmVlZHMgYSBkZXNjcmlwdGlvbiFcIjtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGUgPSBwcm9wcy5zdHlsZSB8fCBzdHlsZTtcblxuICAgICAgICAgICAgICAgIGxheWVyLmJpbmRUb29sdGlwKHByb3BzLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIHRvZ2dsZTogc2V0TGFiZWxOb0hpZGUoYm9vbClcbiAgICAgICAgICAgICAgICBpdCBtYXkgb25seSBleGlzdCBvbiBtYXJrZXJzIVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnRUb0xheWVyOiBmdW5jdGlvbiAoZmVhdHVyZSA6IGFueSwgbGF0bG5nIDogTGF0TG5nICkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGZlYXR1cmUucHJvcGVydGllcy5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgICAgICBzdHlsZS5yYWRpdXMgPSBzdHlsZS5yYWRpdXMgfHwgNDtcbiAgICAgICAgICAgICAgICBzdHlsZS53ZWlnaHQgPSBzdHlsZS53ZWlnaHQgfHwgMjtcbiAgICAgICAgICAgICAgICBzdHlsZS5jb2xvciA9IHN0eWxlLmNvbG9yIHx8ICcjMDNmJztcbiAgICAgICAgICAgICAgICBzdHlsZS5vcGFjaXR5ID0gc3R5bGUub3BhY2l0eSB8fCAwLjk7XG4gICAgICAgICAgICAgICAgc3R5bGUuZmlsbE9wYWNpdHkgPSBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIHN0eWxlLmZpbGxDb2xvciA9IHN0eWxlLmNvbG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaXJjbGVNYXJrZXIobGF0bG5nLCBzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZGlzcG9zZSAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveU1hcCgpO1xuICAgICAgICB0aGlzLnN2Y0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlRmFjdG9yeSA9IG51bGw7XG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2tleSA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWZhdWx0RXh0ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyRGVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllckNhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvcnM9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl90b29scyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9nZW9Kc29uTGF5ZXJPcHRzID0gbnVsbDtcbiAgICB9XG5cblxuICAgIGdldEtleSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZGVmYXVsdCAoSlF1ZXJ5LWJhc2VkKSBtYXAgc2VydmljZSB1c2VkIGJ5IHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gbWFwU2VydmljZSAtIHNlcnZpY2UgdG8gdXNlIHRvIENSVUQgbWFwIG9iamVjdHNcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2Ugc2V0U2VydmljZUZhY3RvcnkgaW5zdGVhZFxuICAgICAqL1xuICAgIHNldFNlcnZpY2UobWFwU2VydmljZSA6IE1hcFNlcnZpY2UpIHtcbiAgICAgICAgLy8gdGhpcy5tYXBTZXJ2aWNlID0gbWFwU2VydmljZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmFjdG9yeSAtIEdlb1BsYXRmb3JtIFNlcnZpY2VGYWN0b3J5IHRvIGluc3RhbnRpYXRlIHNlcnZpY2VzIGZvciBtYXBzIGFuZCBsYXllcnNcbiAgICAgKi9cbiAgICBzZXRTZXJ2aWNlRmFjdG9yeShmYWN0b3J5IDogYW55KSB7XG4gICAgICAgIHRoaXMuc3ZjQ2FjaGUgPSB7fTsgLy93aXBlIG91dCBjYWNoZWQgc2VydmljZXNcbiAgICAgICAgdGhpcy5zZXJ2aWNlRmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGh0dHBDbGllbnQgLSBIdHRwQ2xpZW50IGltcGwgdG8gdXNlIHdpdGggdGhlIG5ldyBmYWN0b3J5XG4gICAgICovXG4gICAgc2V0SHR0cENsaWVudChodHRwQ2xpZW50IDogYW55KSB7XG4gICAgICAgIHRoaXMuc3ZjQ2FjaGUgPSB7fTsgLy93aXBlIG91dCBjYWNoZWQgc2VydmljZXNcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdHlwZSAtIEdlb1BsYXRmb3JtIE9iamVjdCBtb2RlbCB0eXBlIHRvIHN1cHBvcnQgKFwiTWFwXCIsIFwiTGF5ZXJcIiwgZXRjKVxuICAgICAqIEByZXR1cm4gaXRlbSBzZXJ2aWNlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgcmVxdWVzdGVkIHR5cGVcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlKHR5cGUgOiBzdHJpbmcpIDogSXRlbVNlcnZpY2Uge1xuICAgICAgICBpZighdGhpcy5zdmNDYWNoZVt0eXBlXSlcbiAgICAgICAgICAgIHRoaXMuc3ZjQ2FjaGVbdHlwZV0gPSB0aGlzLnNlcnZpY2VGYWN0b3J5KHR5cGUsIENvbmZpZy51YWxVcmwsIHRoaXMuaHR0cENsaWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN2Y0NhY2hlW3R5cGVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbiAtIGNhbGxiYWNrIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWRcbiAgICAgKi9cbiAgICBzZXRFcnJvckhhbmRsZXIoZm4pIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvckhhbmRsZXIgPSBmbjtcbiAgICB9XG5cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBnZXRMYXllclN0YXRlSW5kZXggKGxheWVySWQpIHtcbiAgICAgICAgaWYoIWxheWVySWQpIHJldHVybiAtMTtcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8dGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuX2xheWVyU3RhdGVzW2ldLmxheWVyICYmIGxheWVySWQgPT09IHRoaXMuX2xheWVyU3RhdGVzW2ldLmxheWVyLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5fbGF5ZXJTdGF0ZXMuaW5kZXhPZk9iaihsYXllcklkLCAoaWQsIHN0YXRlKSA9PiBzdGF0ZS5sYXllci5pZCA9PT0gaWQgKTtcbiAgICB9XG5cbiAgICBnZXRMYXllclN0YXRlIChsYXllcklkKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZUluZGV4KGxheWVySWQpO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IHRoaXMuX2xheWVyU3RhdGVzW2luZGV4XSA6IG51bGw7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgaW5pdGlhbGl6ZU1hcERlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBJdGVtVHlwZXMuTUFQLFxuICAgICAgICAgICAgdGl0bGU6IFwiTXkgTmV3IE1hcFwiLFxuICAgICAgICAgICAgbGFiZWw6IFwiTXkgTmV3IE1hcFwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhpcyBtYXAgbmVlZHMgYSBkZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgY3JlYXRlZEJ5OiBudWxsLFxuICAgICAgICAgICAgYmFzZUxheWVyOiB0aGlzLl9iYXNlTGF5ZXJEZWYsXG4gICAgICAgICAgICBsYXllcnM6IFtdLFxuICAgICAgICAgICAga2V5d29yZHM6IFtdLFxuICAgICAgICAgICAgdGhlbWVzOiBbXSxcbiAgICAgICAgICAgIHJlc291cmNlVHlwZXM6IFsnaHR0cDovL3d3dy5nZW9wbGF0Zm9ybS5nb3Yvb250L29wZW5tYXAvR2VvcGxhdGZvcm1NYXAnXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIG9iamVjdCBkZWZpbml0aW9uIG9mIHRoZSBjdXJyZW50IG1hcCBzdWl0YWJsZSBmb3Igc2VuZGluZyB0byBXTVZSXG4gICAgICovXG4gICAgZ2V0TWFwUmVzb3VyY2VDb250ZW50KG1ldGFkYXRhID86IGFueSkge1xuXG4gICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGEgfHwge307XG5cbiAgICAgICAgLy9tYXAgbGF5ZXJzXG4gICAgICAgIG1ldGFkYXRhLmxheWVycyA9IHRoaXMuX2xheWVyU3RhdGVzLm1hcChzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgOiBzdGF0ZS52aXNpYmlsaXR5IHx8IHRydWUsXG4gICAgICAgICAgICAgICAgb3BhY2l0eSA6IGlzTmFOKHN0YXRlLm9wYWNpdHkpID8gMS4wIDogc3RhdGUub3BhY2l0eSoxLFxuICAgICAgICAgICAgICAgIGxheWVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzdGF0ZS5sYXllci5pZCxcbiAgICAgICAgICAgICAgICAgICAgdXJpOiBzdGF0ZS5sYXllci51cmksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBzdGF0ZS5sYXllci5sYWJlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gLi4uIFVBTCBzaG91bGQgc3VwcG9ydCBhY2NlcHRpbmcganVzdCBhbiBpZCBoZXJlLCBzbyB3ZSdsbCBkbyBqdXN0IHRoYXRcbiAgICAgICAgbWV0YWRhdGEuYmFzZUxheWVyID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX2Jhc2VMYXllckRlZi5pZCxcbiAgICAgICAgICAgIHVyaTogdGhpcy5fYmFzZUxheWVyRGVmLnVyaSxcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLl9iYXNlTGF5ZXJEZWYubGFiZWxcbiAgICAgICAgfTtcblxuICAgICAgICBtZXRhZGF0YS5hbm5vdGF0aW9ucyA9IHRoaXMuX2ZlYXR1cmVMYXllciA/XG4gICAgICAgICAgICB7IHRpdGxlOiBcIk1hcCBGZWF0dXJlc1wiLCBnZW9KU09OOiB0aGlzLl9mZWF0dXJlTGF5ZXIudG9HZW9KU09OKCkgfSA6IG51bGw7XG5cbiAgICAgICAgLy9nZW9ncmFwaGljIGV4dGVudFxuICAgICAgICBsZXQgZXh0ZW50ID0gdGhpcy5fbWFwSW5zdGFuY2UuZ2V0Qm91bmRzKCk7XG4gICAgICAgIG1ldGFkYXRhLmV4dGVudCA9IHtcbiAgICAgICAgICAgIG1pbng6IGV4dGVudC5nZXRXZXN0KCksXG4gICAgICAgICAgICBtaW55OiBleHRlbnQuZ2V0U291dGgoKSxcbiAgICAgICAgICAgIG1heHg6IGV4dGVudC5nZXRFYXN0KCksXG4gICAgICAgICAgICBtYXh5OiBleHRlbnQuZ2V0Tm9ydGgoKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIExlYWZsZXQgdG9vbGJhclxuICAgICAqL1xuICAgIGdldERyYXdDb250cm9sVG9vbGJhcigpIHtcbiAgICAgICAgaWYoISh0aGlzLl9tYXBJbnN0YW5jZSBhcyBhbnkpLmRyYXdDb250cm9sKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHRvb2xiYXJzID0gKHRoaXMuX21hcEluc3RhbmNlIGFzIGFueSkuZHJhd0NvbnRyb2wuX3Rvb2xiYXJzO1xuICAgICAgICB2YXIgdG9vbGJhciA9IG51bGw7XG4gICAgICAgIGZvcih2YXIga2V5IGluIHRvb2xiYXJzKSB7XG4gICAgICAgICAgICBpZih0b29sYmFycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYodG9vbGJhcnNba2V5XS5fbW9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJhciA9IHRvb2xiYXJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9vbGJhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXJyb3IgTGVhZmxldCB0aWxlIGxvYWQgZXJyb3IgKC50YXJnZXQgaXMgbGF5ZXIsIC50aWxlIGlzIGltYWdlKVxuICAgICAqL1xuICAgIGhhbmRsZUxheWVyRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5oYW5kbGVMYXllckVycm9yKCkgLSBcIiArXG4gICAgICAgIC8vICAgICBcIkxheWVyJ3MgdGlsZSBmYWlsZWQgdG8gbG9hZDogXCIgKyBlcnJvci50aWxlLnNyYyk7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuYWJsZSB0byBmaW5kIGxheWVyIGluIGxheWVyIGNhY2hlLiBMYXllciBlcnJvciBpcyBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5ZXIgPSBlcnJvci50YXJnZXQ7XG4gICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5fbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgaWYodGhpcy5fbGF5ZXJDYWNoZVtpZF0gPT09IGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGF5ZXJFcnJvcihlcnJvciwgaWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBMZWFmbGV0IHRpbGUgbG9hZCBlcnJvciBhbmQgdGhlIHJlc3BvbnNpYmxlIGxheWVyIGlkLFxuICAgICAqIFRyeSB0byBpc29sYXRlIHRoZSBjYXVzZSBvZiB0aGUgZXJyb3IgdXNpbmcgdGhlIHByb3h5XG4gICAgICogYW5kIG5vdGlmeSBsaXN0ZW5lcnMgdGhhdCBhbiBlcnJvciBoYXMgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBwcm9jZXNzTGF5ZXJFcnJvcihlcnJvciA6IEVycm9yLCBpZCA6IHN0cmluZykge1xuXG4gICAgICAgIHZhciBmaW5kZXIgPSAobCkgPT4geyByZXR1cm4gbC5pZCA9PT0gaWQgfHwgKGwubGF5ZXIgJiYgbC5sYXllci5pZCA9PT0gaWQpOyB9O1xuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckVycm9ycy5maW5kKGZpbmRlcikpIHtcblxuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMubG9nTGF5ZXJFcnJvcihpZCwgXCJMYXllciAoJ1wiICsgaWQgKyBcIicpIGZhaWxlZCB0byBjb21wbGV0ZWx5IGxvYWQuIFwiICtcbiAgICAgICAgICAgICAgICBcIkl0IG1heSBiZSBpbmFjY2Vzc2libGUgb3IgbWlzY29uZmlndXJlZC5cIik7XG5cbiAgICAgICAgICAgIHZhciB1cmwgPSAoZXJyb3IgYXMgYW55KS50aWxlLnNyYztcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7aWQ6aWR9O1xuICAgICAgICAgICAgdXJsLnN1YnN0cmluZyh1cmwuaW5kZXhPZihcIj9cIikrMSwgdXJsLmxlbmd0aCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwYXJhbS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgIHBhcmFtc1twWzBdXSA9IHBbMV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGV0IGxheWVyU2VydmljZSA9IHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTEFZRVIpIGFzIExheWVyU2VydmljZTtcbiAgICAgICAgICAgIGlmKGxheWVyU2VydmljZSkge1xuICAgICAgICAgICAgICAgIGxheWVyU2VydmljZS52YWxpZGF0ZShpZCwgcGFyYW1zKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2xheWVyU3RhdGVzLmZpbmQoZmluZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoubWVzc2FnZSA9IFwiTGF5ZXIgJ1wiICsgZGVmLmxheWVyLmxhYmVsICsgXCInIGZhaWxlZCB0byBjb21wbGV0ZWx5IGxvYWQuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJSZXBvcnRlZCBjYXVzZTogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ2xheWVyOmVycm9yJywgb2JqKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsYXllcklkIC0gaWRlbnRpZmllciBvZiBsYXllciBnZW5lcmF0aW5nIHRoZSBlcnJvclxuICAgICAqIEBwYXJhbSBlcnJvck1zZyAtIG1lc3NhZ2Ugb2YgdGhlIGVycm9yXG4gICAgICovXG4gICAgbG9nTGF5ZXJFcnJvcihsYXllcklkLCBlcnJvck1zZykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmxvZ0xheWVyRXJyb3IoKSAtIGxheWVyIFwiICArIGlkICtcbiAgICAgICAgLy8gICAgIFwiIGdlbmVyYXRlZCBlcnJvciAnXCIgKyBlcnJvck1zZyArIFwiJ1wiKTtcbiAgICAgICAgbGV0IGVyciA9IHsgaWQ6IGxheWVySWQsIG1lc3NhZ2U6IGVycm9yTXNnIH07XG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgaWYodGhpcy5fbGF5ZXJFcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICAvKiAtLSBTdGF0ZSBNYW5hZ2VtZW50IG9mIGludGVybmFsIG1vZGVsIC0tICovXG5cbiAgICB0b3VjaCAoZXZlbnQgPzogYW55LCAuLi5vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZGlydHkgPSB0cnVlO1xuICAgICAgICBpZihldmVudCkge1xuICAgICAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KGV2ZW50KTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRGlydHlpbmcgbWFwIGZvciBcIiArIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGNvbnNvbGUubG9nKFwiRGlydHlpbmcgbWFwXCIpO1xuICAgIH1cbiAgICBjbGVhbigpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJDbGVhbmluZyBtYXBcIik7XG4gICAgICAgIHRoaXMuc3RhdGUuZGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIE1hcCBtYW5pcHVsYXRpb24gb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIHNldE1hcCAobWFwIDogTWFwKSB7IHRoaXMuX21hcEluc3RhbmNlID0gbWFwOyB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuICBtYXAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRNYXAgKCkgOiBNYXAgeyByZXR1cm4gdGhpcy5fbWFwSW5zdGFuY2U7IH1cblxuICAgIC8qKiBAcmV0dXJuIGRlZmluaXRpb24gb2YgbWFwICovXG4gICAgZ2V0TWFwRGVmaW5pdGlvbiAoKSA6IGFueSB7IHJldHVybiB0aGlzLl9tYXBEZWY7IH1cblxuICAgIC8qKiBAcmV0dXJuIGlkZW50aWZpZXIgb2YgbWFwICovXG4gICAgZ2V0TWFwSWQgKCkgOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fbWFwSWQ7IH1cblxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIG1hcCBvbiB0aGUgc3BlY2lmaWVkIGxhdC9sbmcgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBsYXQgbnVtYmVyXG4gICAgICogQHBhcmFtIGxuZyBudW1iZXJcbiAgICAgKiBAcGFyYW0gem9vbSBudW1iZXIgKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIHNldFZpZXcgKGxhdCA6IG51bWJlciwgbG5nIDogbnVtYmVyLCB6b29tID86IG51bWJlcikge1xuICAgICAgICBsZXQgeiA9IHpvb207XG4gICAgICAgIGlmKHR5cGVvZih6KSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB6ID0gdGhpcy5fbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5zZXRWaWV3KFtsYXQsbG5nXSwgeik7XG4gICAgICAgIHRoaXMudG91Y2goJ21hcDp2aWV3OmNoYW5nZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjZW50ZXIgb2YgdGhlIG1hcFxuICAgICAqIEByZXR1cm4gW2xhdCxsbmddXG4gICAgICovXG4gICAgZ2V0VmlldyAoKSA6IG51bWJlcltdIHtcbiAgICAgICAgdmFyIGxhdExuZyA9IHRoaXMuX21hcEluc3RhbmNlLmdldENlbnRlcigpO1xuICAgICAgICByZXR1cm4gW2xhdExuZy5sYXQsIGxhdExuZy5sbmddO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gaW50ZWdlciBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcFxuICAgICAqL1xuICAgIGdldFpvb20gKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFpvb20gdG8gdGhlIG1hcCdzIGRlZmF1bHQgZXh0ZW50XG4gICAgICogSWYgdGhlIG1hcCBpcyBzYXZlZCwgdGhpcyB3aWxsIGJlIHRoZSBzYXZlZCB2aWV3cG9ydFxuICAgICAqIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBDT05VU1xuICAgICAqL1xuICAgIHpvb21Ub0RlZmF1bHQgKCkge1xuICAgICAgICBpZighdGhpcy5fbWFwSW5zdGFuY2UpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5fZGVmYXVsdEV4dGVudCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKFtcbiAgICAgICAgICAgICAgICBbdGhpcy5fZGVmYXVsdEV4dGVudC5taW55LCB0aGlzLl9kZWZhdWx0RXh0ZW50Lm1pbnhdLFxuICAgICAgICAgICAgICAgIFt0aGlzLl9kZWZhdWx0RXh0ZW50Lm1heHksIHRoaXMuX2RlZmF1bHRFeHRlbnQubWF4eF1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS56b29tVG9EZWZhdWx0KCkgLSBObyBkZWZhdWx0IGV4dGVudCBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5zZXRWaWV3KFszOCwgLTk2XSwgNSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ21hcDp2aWV3OmNoYW5nZWQnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXh0ZW50IC0gZWl0aGVyIGEgR1AgZXh0ZW50IG9iamVjdCBvciBMZWFmbGV0IExhdExuZ0JvdW5kcyBvYmplY3RcbiAgICAgKi9cbiAgICBzZXRFeHRlbnQoZXh0ZW50IDogTGF0TG5nQm91bmRzfGFueSkge1xuICAgICAgICBpZighZXh0ZW50KSByZXR1cm47XG4gICAgICAgIGlmKCB0eXBlb2YoZXh0ZW50Lm1pbngpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mKGV4dGVudC5taW55KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZihleHRlbnQubWF4eCkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YoZXh0ZW50Lm1heHkpICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgIC8vR1AgbW9kZWwgZXh0ZW50XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoW1xuICAgICAgICAgICAgICAgIFtleHRlbnQubWlueSwgZXh0ZW50Lm1pbnhdLFxuICAgICAgICAgICAgICAgIFtleHRlbnQubWF4eSwgZXh0ZW50Lm1heHhdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihleHRlbnQuZ2V0V2VzdCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvL0wuTGF0TG5nQm91bmRzXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoZXh0ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIExheWVyIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsYXllciBMZWFmbGV0IExheWVyIGluc3RhbmNlIG9yIG9iamVjdCBkZWZpbml0aW9uXG4gICAgICovXG4gICAgc2V0QmFzZUxheWVyIChsYXllciA6IGFueSkge1xuXG4gICAgICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgaWYoIWxheWVyKSB7XG4gICAgICAgICAgICBsZXQgc3ZjID0gdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5MQVlFUikgYXMgTGF5ZXJTZXJ2aWNlO1xuICAgICAgICAgICAgcHJvbWlzZSA9IERlZmF1bHRCYXNlTGF5ZXIuZ2V0KHN2Yyk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShsYXllcik7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKCBsYXllciA9PiB7XG5cbiAgICAgICAgICAgIGxldCBsZWFmbGV0TGF5ZXIgPSBMYXllckZhY3RvcnkuY3JlYXRlKGxheWVyKTtcbiAgICAgICAgICAgIGlmKCFsZWFmbGV0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmc6IE1hcEluc3RhbmNlIGNvdWxkIG5vdCBjcmVhdGUgYmFzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibGF5ZXIgZm9yICdcIiArIGxheWVyLmlkICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuYWRkTGF5ZXIobGVhZmxldExheWVyKTtcblxuICAgICAgICAgICAgKGxlYWZsZXRMYXllciBhcyBhbnkpLnNldFpJbmRleCgwKTsgIC8vc2V0IGF0IGJvdHRvbVxuXG4gICAgICAgICAgICBsZXQgb2xkQmFzZUxheWVyID0gdGhpcy5fYmFzZUxheWVyO1xuICAgICAgICAgICAgaWYob2xkQmFzZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIob2xkQmFzZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9yZW1lbWJlciBuZXcgYmFzZSBsYXllclxuICAgICAgICAgICAgdGhpcy5fYmFzZUxheWVyID0gbGVhZmxldExheWVyO1xuICAgICAgICAgICAgdGhpcy5fYmFzZUxheWVyRGVmID0gbGF5ZXI7XG5cbiAgICAgICAgICAgIC8vd2lsbCBub3RpZnkgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdiYXNlbGF5ZXI6Y2hhbmdlZCcsIGxheWVyLCBsZWFmbGV0TGF5ZXIpO1xuICAgICAgICAgICAgLy8gdGhpcy5ub3RpZnkoJ2Jhc2VsYXllcjpjaGFuZ2VkJywgbGF5ZXIsIGxlYWZsZXRMYXllcik7XG5cbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE1hcEluc3RhbmNlLnNldEJhc2VMYXllcigpIC0gRXJyb3IgZ2V0dGluZyBiYXNlIGxheWVyIGZvciBtYXAgOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIHRoaXMubG9nTGF5ZXJFcnJvciggbGF5ZXIuaWQsIFwiRXJyb3Igc2V0dGluZyBiYXNlbGF5ZXIgb24gbWFwIFwiICtcbiAgICAgICAgICAgICAgICBcImJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcihzKTogXCIgKyBlLm1lc3NhZ2UgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBhcnJheSBvZiBiYXNlIGxheWVycyBkZWZpbml0aW9ucyB0aGF0IGNhbiBiZSB1c2VkXG4gICAgICovXG4gICAgLy8gZ2V0QmFzZUxheWVyT3B0aW9ucyAoKSB7XG4gICAgLy8gICAgIHJldHVybiB0aGlzLl9iYXNlTGF5ZXJPcHRpb25zO1xuICAgIC8vIH0sXG5cbiAgICBnZXRCYXNlTGF5ZXIgKCkgOiBhbnkgeyByZXR1cm4gdGhpcy5fYmFzZUxheWVyRGVmOyB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGxpc3Qgb2YgbGF5ZXIgc3RhdGVzIGNvbnRhaW5pbmcgbGF5ZXIgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBnZXRMYXllcnMgKCkgOiBhbnlbXSB7IHJldHVybiB0aGlzLl9sYXllclN0YXRlczsgfVxuXG4gICAgZ2V0TGF5ZXJFcnJvcnMgKCkgOiBhbnlbXSB7IHJldHVybiB0aGlzLl9sYXllckVycm9yczsgfVxuXG4gICAgY2xlYXJMYXllckVycm9ycyAoKSB7XG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMubm90aWZ5KCdsYXllcjplcnJvcicpO1xuICAgIH1cblxuICAgIGNsZWFyT3ZlcmxheXMgKCkge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICBmb3IodmFyIGk9dGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fbGF5ZXJTdGF0ZXNbaV07XG4gICAgICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbc3RhdGUubGF5ZXIuaWRdO1xuICAgICAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2Uub2ZmKFwibGF5ZXI6ZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZVtzdGF0ZS5sYXllci5pZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnJlbW92ZUxheWVyKGxheWVySW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gW107XG4gICAgICAgIHRoaXMudG91Y2goJ2xheWVyczpjaGFuZ2VkJyk7XG5cbiAgICAgICAgLy9UT0RPIHN0b3AgbGlzdGVuaW5nIGZvciBsYXllciBldmVudHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0gbGlzdCBvZiBsYXllcnMgKE5PVEU6IG5vdCB3cmFwcGVkIGJ5IGxheWVyIHN0YXRlcywgdGhpcyBtZXRob2QgYXBwbGllcyB0aGF0KVxuICAgICAqL1xuICAgIGFkZExheWVycyAobGF5ZXJzIDogYW55fGFueVtdICkge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBhdHRlbXB0aW5nIHRvIGFkZCBsYXllcnMgdG8gYW4gZW1wdHkgY2FjaGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBBdHRlbXB0aW5nIHRvIGFkZCBsYXllcnMgdG8gYSBtYXAgd2l0aCBubyBsYXllciBjYWNoZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFsYXllcnMpIHJldHVybjtcbiAgICAgICAgaWYodHlwZW9mKGxheWVycy5wdXNoKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxheWVycyA9IFtsYXllcnNdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5ZXJzLmZvckVhY2goIChvYmosaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgbGV0IGxheWVyID0gbnVsbCwgc3RhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZihvYmoudHlwZSAmJiBvYmoudHlwZT09PUl0ZW1UeXBlcy5MQVlFUikgeyAvL2lzIGEgbGF5ZXJcbiAgICAgICAgICAgICAgICBsYXllciA9IG9iajtcbiAgICAgICAgICAgIH0gZWxzZSBpZihvYmoubGF5ZXIpIHsgIC8vaXMgbGF5ZXIgc3RhdGVcbiAgICAgICAgICAgICAgICBsYXllciA9IG9iai5sYXllcjsgIC8vIGNvbnRhaW5pbmcgYSBsYXllclxuICAgICAgICAgICAgICAgIHN0YXRlID0gb2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmFkZExheWVycygpIC0gbGF5ZXIgKFwiICsgaW5kZXggK1xuICAgICAgICAgICAgICAgICAgICBcIikgaXMgbm90IGEgTGF5ZXIgb3IgYSBMYXllciBzdGF0ZS4gSWdub3JpbmcuLi5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgLy9sYXllciBpbmZvIGlzIG1pc3NpbmcsIHNraXAgaXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9EVC00NDIgcHJldmVudCBhZGRpbmcgbGF5ZXIgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiBtYXBcbiAgICAgICAgICAgIGlmKHRoaXMuX2xheWVyQ2FjaGVbbGF5ZXIuaWRdKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd3JhcHBlZCBpbiB0cnl7fWNhdGNoIGJlY2F1c2UgbGF5ZXIgbWF5IGNvbnRhaW4gY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgZXJyb3Igd2hlbiB1c2VkIGJ5IEpTT04gbWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5ZXJDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsYXllcikpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyQ29weVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYWRkIGxheWVyIHRvIG1hcCBiZWNhdXNlIG9mIFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB6ID0gbGF5ZXJzLmxlbmd0aCAtIGluZGV4O1xuICAgICAgICAgICAgc3RhdGUuekluZGV4ID0gejtcblxuICAgICAgICAgICAgdGhpcy5hZGRMYXllcldpdGhTdGF0ZShsYXllciwgc3RhdGUpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudG91Y2goJ2xheWVyczpjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxheWVyIC0gR2VvUGxhdGZvcm0gTGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBHZW9QbGF0Zm9ybSBMYXllciBTdGF0ZVxuICAgICAqL1xuICAgIGFkZExheWVyV2l0aFN0YXRlKGxheWVyLCBzdGF0ZSkge1xuXG4gICAgICAgIHZhciBsZWFmbGV0TGF5ZXIgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYoIWxheWVyIHx8ICFzdGF0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50LCBtaXNzaW5nIGxheWVyIGFuZCBvciBzdGF0ZVwiKTtcblxuICAgICAgICAgICAgbGVhZmxldExheWVyID0gTGF5ZXJGYWN0b3J5LmNyZWF0ZShsYXllcik7XG4gICAgICAgICAgICBpZighbGVhZmxldExheWVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1zZyA9IFwiQ291bGQgbm90IGNyZWF0ZSBsZWFmbGV0IGluc3RhbmNlIGZvciBHUCBMYXllciAnXCIgKyBsYXllci5pZCArIFwiJy5cIjtcbiAgICAgICAgICAgICAgICBpZighbGF5ZXIuc2VydmljZXMgfHwgIWxheWVyLnNlcnZpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJyAgVGhlIGxheWVyIGluc3RhbmNlIGhhcyBubyBzZXJ2aWNlcyBpbmNsdWRlZCwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2hpY2ggd2lsbCBwcmV2ZW50IG1vc3QgbGF5ZXJzIGZyb20gYmVpbmcgZGlzcGxheWVkLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dMYXllckVycm9yKCBsYXllci5pZCxcbiAgICAgICAgICAgICAgICBcIkxheWVyICdcIiArIGxheWVyLmxhYmVsICsgXCInIGNvdWxkIG5vdCBiZSBhZGRlZCB0byB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIFwibWFwIGluc3RhbmNlOyBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighbGVhZmxldExheWVyKSByZXR1cm47XG5cbiAgICAgICAgLy9jYWNoZSBsZWFmbGV0IG9iamVjdCBmaXJzdFxuICAgICAgICBpZih0aGlzLl9sYXllckNhY2hlKSB0aGlzLl9sYXllckNhY2hlW2xheWVyLmlkXSA9IGxlYWZsZXRMYXllcjtcblxuICAgICAgICAvL2xpc3RlbiBmb3IgbGF5ZXIgZXJyb3JzIHNvIHdlIGNhbiBpbmZvcm0gdGhlIHVzZXJcbiAgICAgICAgLy8gdGhhdCBhIGxheWVyIGhhc24ndCBiZWVuIGxvYWRlZCBpbiBhIHVzZWZ1bCB3YXlcbiAgICAgICAgbGVhZmxldExheWVyLm9uKCd0aWxlZXJyb3InLCAoZSkgPT4geyB0aGlzLmhhbmRsZUxheWVyRXJyb3IoZSk7IH0pO1xuXG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmFkZExheWVyKGxlYWZsZXRMYXllcik7XG5cbiAgICAgICAgaWYoICFpc05hTihzdGF0ZS56SW5kZXgpICYmIGxlYWZsZXRMYXllci5zZXRaSW5kZXggKVxuICAgICAgICAgICAgbGVhZmxldExheWVyLnNldFpJbmRleChzdGF0ZS56SW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzLnB1c2goc3RhdGUpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdsYXllcjphZGRlZCcsIGxheWVyLCBsZWFmbGV0TGF5ZXIpO1xuXG5cbiAgICAgICAgLy8gaWYgbGF5ZXIgaXMgaW5pdGlhbGx5IFwib2ZmXCIgb3IuLi5cbiAgICAgICAgLy8gaWYgbGF5ZXIgaXMgaW5pdGlhbGx5IG5vdCAxMDAlIG9wYXF1ZVxuICAgICAgICBpZighc3RhdGUudmlzaWJpbGl0eSB8fCBzdGF0ZS5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBsYXllciB2aXNpYmlsaXR5IGFuZCBvcGFjaXR5IGFzeW5jLCBvciBlbHNlXG4gICAgICAgICAgICAvLyBzb21lIG9mIHRoZSBsYXllcnMgd29uJ3QgZ2V0IHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCAobGF5ZXIsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMYXllclZpc2liaWxpdHkobGF5ZXIsIHN0YXRlLnZpc2liaWxpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF5ZXJPcGFjaXR5KGxheWVyLCBzdGF0ZS5vcGFjaXR5KTtcbiAgICAgICAgICAgICAgICAvL1RPRE8gbm90aWZ5IG9mIGNoYW5nZVxuXG4gICAgICAgICAgICAgICAgLy9EVC0yMTAyIHRpbWVvdXQgbmVlZHMgdG8gYmUgbGFyZ2UgZW5vdWdoIG9yIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBmZWF0dXJlIGxheWVycyB3b24ndCBnZXQgb3BhY2l0eSB1cGRhdGVkIG9uIG1hcCBsb2FkXG4gICAgICAgICAgICB9LCAyMDAwLCBsZWFmbGV0TGF5ZXIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmcm9tIC0gcG9zaXRpb24gb2YgbGF5ZXIgYmVpbmcgbW92ZWRcbiAgICAgKiBAcGFyYW0gdG8gLSBkZXNpcmVkIHBvc2l0aW9uIHRvIG1vdmUgbGF5ZXIgdG9cbiAgICAgKi9cbiAgICBtb3ZlTGF5ZXIgKGZyb20gOiBudW1iZXIsIHRvIDogbnVtYmVyKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcblxuICAgICAgICBpZihpc05hTihmcm9tKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vZW5kIG9mIGxpc3RcbiAgICAgICAgaWYoaXNOYU4odG8pKSB0byA9IHRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aC0xO1xuXG4gICAgICAgIGxldCBjb3B5ID0gdGhpcy5fbGF5ZXJTdGF0ZXMuc3BsaWNlKGZyb20sIDEpWzBdOyAgICAvL2dyYWIgbGF5ZXIgYmVpbmcgbW92ZWRcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMuc3BsaWNlKHRvLCAwLCBjb3B5KTtcblxuICAgICAgICBmb3IobGV0IHo9MSwgaT10aGlzLl9sYXllclN0YXRlcy5sZW5ndGgtMTsgaT49MDsgLS1pLCsreikge1xuICAgICAgICAgICAgbGV0IGxheWVyU3RhdGUgPSB0aGlzLl9sYXllclN0YXRlc1tpXTtcbiAgICAgICAgICAgIGxldCBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVsgbGF5ZXJTdGF0ZS5sYXllci5pZCBdO1xuICAgICAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2Uuc2V0WkluZGV4KHopO1xuICAgICAgICAgICAgICAgIGxheWVyU3RhdGUuekluZGV4ID0gejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG91Y2goJ2xheWVyczpjaGFuZ2VkJywgdGhpcy5nZXRMYXllcnMoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVMYXllciAoaWQpIHtcblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbaWRdO1xuICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGxheWVyIGZyb20gdHJhY2tlZCBkZWZzIGFycmF5XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldExheWVyU3RhdGVJbmRleChpZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLnJlbW92ZUxheWVyKFwiICsgaWQgKyBcIilcIik7XG4gICAgICAgICAgICBpZihpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU3RhdGVzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIC8vc3RvcCBsaXN0ZW5pbmcgZm9yIGVycm9yc1xuICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5vZmYoXCJsYXllcjplcnJvclwiKTtcblxuICAgICAgICAgICAgLy9yZW1vdmUgbGF5ZXIgZnJvbSBtYXBcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnJlbW92ZUxheWVyKGxheWVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBsYXllciBmcm9tIGNhY2hlXG4gICAgICAgICAgICB0aGlzLl9sYXllckNhY2hlW2lkXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaCgnbGF5ZXJzOmNoYW5nZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUxheWVyVmlzaWJpbGl0eSAoaWQpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW2lkXTtcbiAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKGlkKTtcbiAgICAgICAgICAgIHN0YXRlLnZpc2liaWxpdHkgPSAhc3RhdGUudmlzaWJpbGl0eTtcblxuICAgICAgICAgICAgaWYobGF5ZXJJbnN0YW5jZS5fY3VycmVudEltYWdlKSB7XG4gICAgICAgICAgICAgICAgLy9FU1JJIEltYWdlIFNlcnZpY2UgbGF5ZXJzIGhhdmUgYW4gSU1HIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGdldHMgbW9kaWZpZWQgYW5kIHJlcGxhY2VkIGV2ZXJ5IG1hcCBldmVudCAoem9vbS9wYW4pXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuJ3QganVzdCB0b2dnbGUgY2xhc3NlcyBsaWtlIG9uIG90aGVyIGxheWVycy5cbiAgICAgICAgICAgICAgICAvL0luc3RlYWQsIHdlIG5lZWQgdG8gdXNlIHRoZSBFU1JJIHNldE9wYWNpdHkgbWV0aG9kIHRvIHRvZ2dsZVxuICAgICAgICAgICAgICAgIC8vIGJ1dCBuZWVkIHRvIHVwZGF0ZSBsYXllciBzdGF0ZSBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2Uuc2V0T3BhY2l0eShzdGF0ZS52aXNpYmlsaXR5ID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wYWNpdHkgPSBsYXllckluc3RhbmNlLmdldE9wYWNpdHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0TGF5ZXJWaXNpYmlsaXR5KGxheWVySW5zdGFuY2UsIHN0YXRlLnZpc2liaWxpdHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCB1cGRhdGUgbGF5ZXIgZGVmaW5pdGlvbiBzdGF0ZS4gVXNlXG4gICAgICogTWFwSW5zdGFuY2UudG9nZ2xlTGF5ZXJWaXNpYmlsaXR5IHRvIGRvIHRoYXQgYW5kIGFkanVzdFxuICAgICAqIHJlbmRlcmVkIGxheWVyJ3MgdmlzaWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllckluc3RhbmNlIC0gbGVhZmxldCBsYXllciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gZmxhZyBpbmRpY2F0aW5nIHZpc2liaWxpdHkgb2YgbGF5ZXJcbiAgICAgKi9cbiAgICBzZXRMYXllclZpc2liaWxpdHkgKGxheWVySW5zdGFuY2UgOiBMYXllciwgdmlzaWJsZSA6IGJvb2xlYW4pIHtcblxuICAgICAgICBpZigobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLnNldFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIC8vdXNpbmcgY3VzdG9tIG1ldGhvZCBwcm92aWRlZCBpbiBzcmMvbGF5ZXIvbW9kdWxlLmpzXG4gICAgICAgICAgICAobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLnNldFZpc2liaWxpdHkodmlzaWJsZSk7XG5cbiAgICAgICAgfSBlbHNlIGlmKChsYXllckluc3RhbmNlIGFzIGFueSkuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgLy9vdGhlcndpc2UsIHVzaW5nIGpxdWVyeSBvbiBkb20gZGlyZWN0bHlcbiAgICAgICAgICAgIGxldCBlbCA9IGpRdWVyeSgobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLl9jb250YWluZXIpO1xuICAgICAgICAgICAgLy8gaWYodmlzaWJsZSkgZWwucmVtb3ZlQ2xhc3MoXCJpbnZpc2libGVcIik7XG4gICAgICAgICAgICAvLyBlbHNlIGVsLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgICAgICAgIGVsLmNzcyh7J2Rpc3BsYXknOiB2aXNpYmxlID8gJycgOiAnbm9uZSd9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG91Y2goJ21hcDpsYXllcjpjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVMYXllck9wYWNpdHkgKGlkIDogc3RyaW5nLCBvcGFjaXR5IDogbnVtYmVyKSB7XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW2lkXTtcblxuICAgICAgICAvL2lmIGxheWVyIGlkIGlzIGZvciBiYXNlIGxheWVyLi4uXG4gICAgICAgIGlmKCFsYXllckluc3RhbmNlICYmIHRoaXMuX2Jhc2VMYXllckRlZi5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIGxheWVySW5zdGFuY2UgPSB0aGlzLl9iYXNlTGF5ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvL2FkanVzdCByZW5kZXJlZCBsZWFmbGV0IGxheWVyXG4gICAgICAgIG9wYWNpdHkgPSB0aGlzLnNldExheWVyT3BhY2l0eShsYXllckluc3RhbmNlLCBvcGFjaXR5KTtcblxuICAgICAgICAvLyBpZiBvdmVybGF5IGxheWVyLCB1cGRhdGUgc3RhdGUgdmFsdWVcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKGlkKTtcbiAgICAgICAgaWYoc3RhdGUpIHN0YXRlLm9wYWNpdHkgPSBvcGFjaXR5O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgZG9lcyBub3QgdXBkYXRlIHRoZSBhc3NvY2lhdGVkIExheWVyIERlZmluaXRpb25cbiAgICAgKiBzdGF0ZSB2YWx1ZSBmb3Igb3BhY2l0eS4gVXNlIE1hcEluc3RhbmNlLnVwZGF0ZUxheWVyT3BhY2l0eSgpIHRvXG4gICAgICogYm90aCB1cGRhdGUgc3RhdGUgYW5kIGFkanVzdCByZW5kZXJlZCBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXllckluc3RhbmNlIC0gbGVhZmxldCBsYXllciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBvcGFjaXR5IC0gdmFsdWUgYmV0d2VlbiAwIGFuZCAxLjAgb3IgMCBhbmQgMTAwXG4gICAgICogQHJldHVybiBub3JtYWxpemVkIG9wYWNpdHkgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLjBcbiAgICAgKi9cbiAgICBzZXRMYXllck9wYWNpdHkgKGxheWVySW5zdGFuY2UgOiBMYXllciwgb3BhY2l0eSA6IG51bWJlcikgOiBudW1iZXIge1xuICAgICAgICBpZihsYXllckluc3RhbmNlICYmIChsYXllckluc3RhbmNlIGFzIGFueSkuc2V0T3BhY2l0eSkge1xuICAgICAgICAgICAgaWYob3BhY2l0eSA+IDEuMCkgb3BhY2l0eSA9IG9wYWNpdHkgLyAxMDAuMDtcbiAgICAgICAgICAgIChsYXllckluc3RhbmNlIGFzIGFueSkuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ21hcDpsYXllcjpjaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wYWNpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIEdlb1BsYXRmb3JtIExheWVyIGluc3RhbmNlXG4gICAgICogQHJldHVybiBMZWFmbGV0IGxheWVyIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGF0IGxheWVyIG9yIG51bGxcbiAgICAgKi9cbiAgICBnZXRMZWFmbGV0TGF5ZXJGb3IgKGdwTGF5ZXIgOiBhbnkpIDogTGF5ZXIge1xuICAgICAgICBpZighZ3BMYXllciB8fCAhdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBsZWFmbGV0TGF5ZXIgPSB0aGlzLl9sYXllckNhY2hlW2dwTGF5ZXIuaWRdO1xuICAgICAgICByZXR1cm4gbGVhZmxldExheWVyIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVHZXRGZWF0dXJlSW5mbyAobGF5ZXJJZCA6IHN0cmluZykge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbbGF5ZXJJZF07XG4gICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZihsYXllckluc3RhbmNlLmVuYWJsZUdldEZlYXR1cmVJbmZvKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZihsYXllckluc3RhbmNlLmlzR2V0RmVhdHVyZUluZm9FbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5kaXNhYmxlR2V0RmVhdHVyZUluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCh0aGlzLl9tYXBJbnN0YW5jZSBhcyBhbnkpLl9jb250YWluZXIpLnJlbW92ZUNsYXNzKCdzZWxlY3RhYmxlLWN1cnNvcicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2UuZW5hYmxlR2V0RmVhdHVyZUluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KCh0aGlzLl9tYXBJbnN0YW5jZSBhcyBhbnkpLl9jb250YWluZXIpLmFkZENsYXNzKCdzZWxlY3RhYmxlLWN1cnNvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgRmVhdHVyZSBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGFycmF5IG9mIGZlYXR1cmVzIG9uIHRoZSBtYXBcbiAgICAgKi9cbiAgICBnZXRGZWF0dXJlcyAoKSA6IGFueVtdIHtcbiAgICAgICAgaWYodGhpcy5fZmVhdHVyZUxheWVyKSB7XG4gICAgICAgICAgICBsZXQgZ2VvanNvbiA9IHRoaXMuX2ZlYXR1cmVMYXllci50b0dlb0pTT04oKTtcbiAgICAgICAgICAgIHJldHVybiAoZ2VvanNvbiBhcyBhbnkpLmZlYXR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ganNvbiBnZW9qc29uIG9iamVjdCBvciBhcnJheSBvZiBnZW9qc29uIG9iamVjdHNcbiAgICAgKi9cbiAgICBhZGRGZWF0dXJlcyAoanNvbiA6IGFueSkge1xuXG4gICAgICAgIGlmKCFqc29uKSByZXR1cm47XG5cbiAgICAgICAgaWYodHlwZW9mKGpzb24ucHVzaCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvL2FycmF5IG9mIGZlYXR1cmVzXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxqc29uLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZShqc29uW2ldLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdmZWF0dXJlczpjaGFuZ2VkJyk7XG5cbiAgICAgICAgfSBlbHNlIGlmKGpzb24uZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZXMoanNvbi5mZWF0dXJlcyk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy9zaW5nbGUgZmVhdHVyZVxuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGpzb24sIHRydWUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ganNvbiBnZW9qc29uIG9iamVjdFxuICAgICAqL1xuICAgIGFkZEZlYXR1cmUgKGpzb24gOiBhbnksIGZpcmVFdmVudCA/OiBib29sZWFuKSB7XG4gICAgICAgIC8vIHZhciB0eXBlID0ganNvbi50eXBlO1xuICAgICAgICAvLyB2YXIgY29vcmRpbmF0ZXMgPSBqc29uLmNvb3JkaW5hdGVzO1xuXG4gICAgICAgIGlmKCF0aGlzLl9mZWF0dXJlTGF5ZXIpIHtcblxuICAgICAgICAgICAgLy8gX2ZlYXR1cmVMYXllciA9IGdlb0pTT04oW10sIF9nZW9Kc29uTGF5ZXJPcHRzKS5hZGRUbyhfbWFwSW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gZmVhdHVyZUdyb3VwKCkuYWRkVG8odGhpcy5fbWFwSW5zdGFuY2UpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBfZmVhdHVyZUxheWVyLmFkZERhdGEoanNvbik7XG4gICAgICAgIHZhciBvcHRzID0galF1ZXJ5LmV4dGVuZCh7fSwgdGhpcy5fZ2VvSnNvbkxheWVyT3B0cyk7XG4gICAgICAgIGdlb0pTT04oanNvbiwgb3B0cykuZWFjaExheWVyKChsKT0+dGhpcy5hZGRGZWF0dXJlTGF5ZXIobCkpO1xuXG4gICAgICAgIGlmKHR5cGVvZihmaXJlRXZlbnQpID09PSAndW5kZWZpbmVkJyB8fCBmaXJlRXZlbnQgPT09IHRydWUpXG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdmZWF0dXJlczpjaGFuZ2VkJyk7XG4gICAgICAgIGVsc2UgdGhpcy50b3VjaCgpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KF9mZWF0dXJlTGF5ZXIudG9HZW9KU09OKCkpKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmZWF0dXJlSnNvbiBvYmplY3QgZGVmaW5pbmcgYSBHZW9KU09OIGZlYXR1cmVcbiAgICAgKi9cbiAgICB1cGRhdGVGZWF0dXJlIChmZWF0dXJlSnNvbiA6IGFueSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldEZlYXR1cmVMYXllcihmZWF0dXJlSnNvbi5wcm9wZXJ0aWVzLmlkKTtcbiAgICAgICAgaWYobGF5ZXIpIHtcblxuICAgICAgICAgICAgKGxheWVyIGFzIGFueSkuZmVhdHVyZSA9IGZlYXR1cmVKc29uO1xuXG4gICAgICAgICAgICAvL3VwZGF0ZSBzdHlsZVxuICAgICAgICAgICAgbGF5ZXIuc2V0U3R5bGUoZmVhdHVyZUpzb24ucHJvcGVydGllcy5zdHlsZSk7XG5cbiAgICAgICAgICAgIC8vcmViaW5kIGxhYmVsIGluIGNhc2UgdGhhdCBjaGFuZ2VkXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBmZWF0dXJlSnNvbi5wcm9wZXJ0aWVzLmxhYmVsIHx8XG4gICAgICAgICAgICAgICAgXCJVbnRpdGxlZCBcIiArIGZlYXR1cmVKc29uLmdlb21ldHJ5LnR5cGUgKyBcIiBGZWF0dXJlXCI7XG4gICAgICAgICAgICBsYXllci5iaW5kVG9vbHRpcChsYWJlbCk7XG5cbiAgICAgICAgICAgIC8vIGxheWVyLnJlZHJhdygpO1xuICAgICAgICAgICAgdGhpcy50b3VjaChcIm1hcDpmZWF0dXJlOmNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIGFuIGV4aXN0aW5nIEwuUGF0aC1iYXNlZCBsYXllciB3aXRoIG9uZSB1c2luZ1xuICAgICAqIHRoZSBzdXBwbGllZCBGZWF0dXJlIEdlb0pTT04gb2JqZWN0LiAgUmVtb3ZlcyB0aGUgZXhpc3RpbmdcbiAgICAgKiBsYXllciBhbmQgYWRkcyBhIG5ldyBvbmUgY3JlYXRlZCBmcm9tIHRoZSBHZW9KU09OLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZlYXR1cmVKc29uIG9iamVjdCBkZWZpbmluZyBHZW9KU09OIGZlYXR1cmVcbiAgICAgKi9cbiAgICByZXBsYWNlRmVhdHVyZSAoZmVhdHVyZUpzb24gOiBhbnkpIHtcblxuICAgICAgICAvL2ZpbmQgZXhpc3RpbmcgbGF5ZXIgZm9yIHRoaXMgZmVhdHVyZVxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldEZlYXR1cmVMYXllcihmZWF0dXJlSnNvbi5wcm9wZXJ0aWVzLmlkKTtcbiAgICAgICAgaWYobGF5ZXIpIHtcblxuICAgICAgICAgICAgLy9yZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllci5yZW1vdmVMYXllcihsYXllcik7XG5cbiAgICAgICAgICAgIC8vYWRkIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBnZW9KU09OKGZlYXR1cmVKc29uLCB0aGlzLl9nZW9Kc29uTGF5ZXJPcHRzKVxuICAgICAgICAgICAgICAgIC5lYWNoTGF5ZXIoKGwpPT50aGlzLmFkZEZlYXR1cmVMYXllcihsKSk7XG5cbiAgICAgICAgICAgIHRoaXMudG91Y2goXCJtYXA6ZmVhdHVyZTpjaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZlYXR1cmVJZCBpZGVudGlmaWVyIG9mIGZlYXR1cmUgdG8gZm9jdXMgdGhlIG1hcCBvblxuICAgICAqL1xuICAgIGZvY3VzRmVhdHVyZSAoZmVhdHVyZUlkIDogc3RyaW5nKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0RmVhdHVyZUxheWVyKGZlYXR1cmVJZCk7XG4gICAgICAgIGlmKGxheWVyKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mKGxheWVyLmdldEJvdW5kcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVudCA9IGxheWVyLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhleHRlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiggKGxheWVyIGFzIGFueSkuZ2V0TGF0TG5nKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF0TG5nID0gKGxheWVyIGFzIGFueSkuZ2V0TGF0TG5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucGFuVG8obGF0TG5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5mb2N1c0ZlYXR1cmUoKSAtIENhbm5vdCBmb2N1cyBmZWF0dXJlIGJlY2F1c2UgaXQgaGFzIG5vIGJvdW5kcyBvciBsYXQvbG5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5mb2N1c0ZlYXR1cmUoKSAtIENhbm5vdCBmb2N1cyBmZWF0dXJlIGJlY2F1c2UgaXQgaGFzIG5vIGxheWVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZlYXR1cmVJZCA6IHN0cmluZ1xuICAgICAqL1xuICAgIHJlbW92ZUZlYXR1cmUgKGZlYXR1cmVJZCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldEZlYXR1cmVMYXllcihmZWF0dXJlSWQpO1xuICAgICAgICBpZihsYXllciAmJiB0aGlzLl9mZWF0dXJlTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllci5yZW1vdmVMYXllcihsYXllcik7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdmZWF0dXJlczpjaGFuZ2VkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUZlYXR1cmVzICgpIHtcbiAgICAgICAgaWYodGhpcy5fZmVhdHVyZUxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goXCJmZWF0dXJlczpjaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRGZWF0dXJlTGF5ZXIgKCBmZWF0dXJlSWQgPzogc3RyaW5nICkgOiBGZWF0dXJlR3JvdXAge1xuICAgICAgICAvL2lmIG5vIGZlYXR1cmUgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHJvb3QgZmVhdHVyZSBsYXllclxuICAgICAgICBpZighZmVhdHVyZUlkKSByZXR1cm4gdGhpcy5fZmVhdHVyZUxheWVyO1xuXG4gICAgICAgIC8vb3RoZXJ3aXNlLCBmaW5kIGZlYXR1cmUuLi5cbiAgICAgICAgaWYoIXRoaXMuX2ZlYXR1cmVMYXllcikgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5fZmVhdHVyZUxheWVyLmdldExheWVycygpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxmZWF0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYoIChmZWF0dXJlc1tpXSBhcyBhbnkpLmZlYXR1cmUgJiZcbiAgICAgICAgICAgICAgICAoZmVhdHVyZXNbaV0gYXMgYW55KS5mZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IGZlYXR1cmVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmVhdHVyZXNbaV0gYXMgYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0b2dnbGVGZWF0dXJlc0xheWVyICgpIHtcbiAgICAgICAgaWYoIXRoaXMuX2ZlYXR1cmVMYXllcikgcmV0dXJuIGZhbHNlOyAgICAvL2lnbm9yZSBpZiBub3QgcmVuZGVyZWQgeWV0XG5cbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSA9ICF0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlO1xuICAgICAgICB0aGlzLnNldEZlYXR1cmVMYXllclZpc2liaWxpdHkodGhpcy5fZmVhdHVyZUxheWVyLCB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICBmZWF0dXJlIC0gTGVhZmxldCBmZWF0dXJlIGluc3RhbmNlXG4gICAgICogQHBhcmFtICB2aXNpYmlsaXR5IC0gZmxhZ1xuICAgICAqL1xuICAgIHNldEZlYXR1cmVWaXNpYmlsaXR5IChmZWF0dXJlLCB2aXNpYmlsaXR5IDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnNldEZlYXR1cmVMYXllclZpc2liaWxpdHkoZmVhdHVyZSwgdmlzaWJpbGl0eSk7XG4gICAgfVxuXG4gICAgZ2V0RmVhdHVyZXNMYXllclZpc2liaWxpdHkgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZTtcbiAgICB9XG5cblxuICAgIC8qXG4gICAgICogbWV0aG9kIGZvciBhZGRpbmcgZmVhdHVyZSBsYXllcnMgdG8gdGhlIG1hcFxuICAgICAqIHdoZW4gdGhlc2UgbGF5ZXJzIG1heSBiZSBsYXllciBncm91cHMuXG4gICAgICogZmluZHMgbGVhZiBub2RlIGxheWVycyBhbmQgYWRkcyB0aGVtIHRvIHRoZVxuICAgICAqIG1hcCdzIGZlYXR1cmUgZ3JvdXBcbiAgICAgKi9cbiAgICBhZGRGZWF0dXJlTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgdGhpcy5fYWRkRmVhdHVyZUxheWVyKGxheWVyKTtcbiAgICAgICAgdGhpcy50b3VjaChcImZlYXR1cmVzOmNoYW5nZWRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kLCB1c2UgJ2FkZEZlYXR1cmVMYXllcicgaW5zdGVhZFxuICAgICAqIEBwYXJhbSBsYXllclxuICAgICAqL1xuICAgIF9hZGRGZWF0dXJlTGF5ZXIobGF5ZXIgOiBMYXllcikge1xuICAgICAgICBpZighKGxheWVyIGFzIGFueSkuZmVhdHVyZSAmJiBsYXllciBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgICAgICAgIGxheWVyLmVhY2hMYXllciggKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRmVhdHVyZUxheWVyKGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLmFkZExheWVyKGxheWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy90b2dnbGUgdmlzaWJpbGl0eSBvZiBwYXJlbnQgZmVhdHVyZSBsYXllclxuICAgIHNldEZlYXR1cmVMYXllclZpc2liaWxpdHkobGF5ZXIsIHZpc2liaWxpdHkpIHtcbiAgICAgICAgaWYoIWxheWVyKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSB2aXNpYmlsaXR5O1xuXG4gICAgICAgIGlmKGxheWVyLmdldExheWVycykge1xuICAgICAgICAgICAgbGF5ZXIuZ2V0TGF5ZXJzKCkuZm9yRWFjaCggKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KGNoaWxkLCB2aXNpYmlsaXR5KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciB8fCBsYXllci5fcGF0aDtcbiAgICAgICAgICAgIGlmKGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9IHZpc2liaWxpdHkgPyAnJyA6ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgTWFwIGxpZmVjeWNsZSBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAgICogQHJldHVybiByZXNvbHZpbmcgcGVyc2lzdGVkIG1hcFxuICAgICAqL1xuICAgIHNhdmUgKG1ldGFkYXRhIDogYW55KSA6IFByb21pc2U8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVNYXAobWV0YWRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZCBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciBtYXBcbiAgICAgKi9cbiAgICBzYXZlTWFwIChtZCA6IGFueSkgOiBQcm9taXNlPGFueT4ge1xuXG4gICAgICAgIGxldCBtZXRhZGF0YSA9IG1kIHx8IHt9O1xuXG4gICAgICAgIC8vYWRkIEdlb1BsYXRmb3JtTWFwIHJlc291cmNlIHR5cGUgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICBjb25zdCBncE1hcFR5cGUgPSAnaHR0cDovL3d3dy5nZW9wbGF0Zm9ybS5nb3Yvb250L29wZW5tYXAvR2VvcGxhdGZvcm1NYXAnO1xuICAgICAgICBtZXRhZGF0YS5yZXNvdXJjZVR5cGVzID0gbWV0YWRhdGEucmVzb3VyY2VUeXBlcyB8fCBbXTtcbiAgICAgICAgaWYobWV0YWRhdGEucmVzb3VyY2VUeXBlcy5pbmRleE9mKGdwTWFwVHlwZSkgPCAwKVxuICAgICAgICAgICAgbWV0YWRhdGEucmVzb3VyY2VUeXBlcy5wdXNoKGdwTWFwVHlwZSk7XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldE1hcFJlc291cmNlQ29udGVudChtZXRhZGF0YSk7XG5cbiAgICAgICAgLy9lbnN1cmUgdGhlIHR3byBuYW1lIHByb3BlcnRpZXMgbGluZSB1cFxuICAgICAgICBpZihjb250ZW50LnRpdGxlICYmIGNvbnRlbnQudGl0bGUgIT09IGNvbnRlbnQubGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnQubGFiZWwgPSBjb250ZW50LnRpdGxlO1xuICAgICAgICB9IGVsc2UgaWYoY29udGVudC5sYWJlbCAmJiAhY29udGVudC50aXRsZSkge1xuICAgICAgICAgICAgY29udGVudC50aXRsZSA9IGNvbnRlbnQubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVwZGF0aW5nOiBcIiArIEpTT04uc3RyaW5naWZ5KG1hcCkpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8YW55PiggKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5NQVApLnNhdmUoY29udGVudClcbiAgICAgICAgICAgIC50aGVuKCByZXN1bHQgPT4ge1xuXG4gICAgICAgICAgICAgICAgLy90cmFjayBuZXcgbWFwJ3MgaW5mbyBzbyB3ZSBjYW4gdXBkYXRlIGl0IHdpdGggbmV4dCBzYXZlXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuX21hcElkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBJZCA9IHJlc3VsdC5pZDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX21hcERlZiA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0RXh0ZW50ID0gcmVzdWx0LmV4dGVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnI9PntcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcENvcmUgTWFwSW5zdGFuY2Uuc2F2ZU1hcCgpIC0gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlRoZSByZXF1ZXN0ZWQgbWFwIGNvdWxkIG5vdCBiZSBzYXZlZCBiZWNhdXNlOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgbWFwIGNvdWxkIG5vdCBiZSBzYXZlZCBiZWNhdXNlIG9mIHRoZSBmb2xsb3dpbmcgZXJyb3Iocyk6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWFwJ3MgZGVzY3JpcHRvciBmcm9tIHRoZSByZWdpc3RyeVxuICAgICAqIEBwYXJhbSBtYXBJZCBpZGVudGlmaWVyIG9mIG1hcFxuICAgICAqIEByZXR1cm4gcmVzb2x2aW5nIHRoZSBtYXAgb2JqZWN0XG4gICAgICovXG4gICAgZmV0Y2hNYXAgKG1hcElkIDogc3RyaW5nKSA6IGFueSB7XG4gICAgICAgIC8vSGF2aW5nIHRvIHNlbmQgY2FjaGUgYnVzdGluZyBwYXJhbWV0ZXIgdG8gYXZvaWQgQ09SUyBoZWFkZXIgY2FjaGVcbiAgICAgICAgLy8gbm90IHNlbmRpbmcgY29ycmVjdCBPcmlnaW4gdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTUFQKS5nZXQobWFwSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWFwJ3MgZGVzY3JpcHRvciBhbmQgbG9hZCBpdCBhcyB0aGVcbiAgICAgKiBjdXJyZW50IG1hcCBtYW5hZ2VkIGJ5IHRoaXMgc2VydmljZVxuICAgICAqIEBwYXJhbSBtYXBJZCBpZGVudGlmaWVyIG9mIG1hcFxuICAgICAqIEByZXR1cm4gcmVzb2x2aW5nIHRoZSBtYXAgb2JqZWN0XG4gICAgICovXG4gICAgbG9hZE1hcCAobWFwSWQgOiBzdHJpbmcpIDogYW55IHtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8YW55PiggKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLmZldGNoTWFwKG1hcElkKS50aGVuKG1hcCA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZighbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgbWFwICgnXCIgKyBtYXBJZCArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicpIGNhbWUgYmFjayBudWxsXCIpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihtYXApID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVxdWVzdGVkIG1hcCAoJ1wiICsgbWFwSWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInKSBjYW1lIGJhY2sgYXMgYSBzdHJpbmdcIik7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoKG1hcCBhcyBhbnkpLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcgdGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBJZCArIFwiJyk6IFwiICsgKG1hcCBhcyBhbnkpLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy9sb2FkaW5nIGEgbWFwIGJ5IGl0cyBJRCwgc28gd2UgbmVlZCB0byBpbmNyZW1lbnQgaXQncyB2aWV3IGNvdW50XG4gICAgICAgICAgICAgICAgaWYoJ2RldmVsb3BtZW50JyAhPT0gQ29uZmlnLmVudikge1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIChtYXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIHZpZXcgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2aWV3cyA9IG1hcC5zdGF0aXN0aWNzID8gKG1hcC5zdGF0aXN0aWNzLm51bVZpZXdzfHwwKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGF0Y2ggPSBbIHsgb3A6ICdyZXBsYWNlJywgcGF0aDogJy9zdGF0aXN0aWNzL251bVZpZXdzJywgdmFsdWU6IHZpZXdzKzEgfSBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5NQVApLnBhdGNoKG1hcC5pZCwgcGF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLm1hcFNlcnZpY2UucGF0Y2gobWFwLmlkLCBwYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCB1cGRhdGVkID0+IHsgbWFwLnN0YXRpc3RpY3MgPSB1cGRhdGVkLnN0YXRpc3RpY3M7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2Uuc2F2ZU1hcCgpIC0gRXJyb3IgdXBkYXRpbmcgdmlldyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY291bnQgZm9yIG1hcCAoJ1wiICsgbWFwSWQgKyBcIicpOiBcIiArIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMDAsIG1hcCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2xvYWQgdGhlIG1hcCBpbnRvIHRoZSB2aWV3ZXJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRNYXBGcm9tT2JqKG1hcCk7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKG1hcCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UubG9hZE1hcCgpIC0gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlRoZSByZXF1ZXN0ZWQgbWFwIGNvdWxkIG5vdCBiZSBsb2FkZWQgYmVjYXVzZSBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgbWFwICgnXCIgKyBtYXBJZCArXG4gICAgICAgICAgICAgICAgICAgIFwiJykgY291bGQgbm90IGJlIGxvYWRlZCBiZWNhdXNlIG9mIHRoZSBmb2xsb3dpbmcgZXJyb3Iocyk6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgbWFwIGZyb20gaXRzIGRlc2NyaXB0b3IgYXMgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXAgbWFuYWdlZCBieSB0aGlzIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0gbWFwIG9iamVjdFxuICAgICAqL1xuICAgIGxvYWRNYXBGcm9tT2JqIChtYXAgOiBhbnkpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkxvYWRpbmcgTWFwIE9iamVjdFwiKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2cobWFwKTtcblxuICAgICAgICB0aGlzLl9tYXBJZCA9IG1hcC5pZDtcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gbWFwO1xuXG4gICAgICAgIG1hcC5leHRlbnQgPSB0aGlzLmVuc3VyZUV4dGVudChtYXAuZXh0ZW50KTtcblxuICAgICAgICAvL3NldCBleHRlbnQgZnJvbSBsb2FkZWQgbWFwXG4gICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSBtYXAuZXh0ZW50O1xuICAgICAgICB2YXIgZXh0ZW50ID0gbWFwLmV4dGVudDtcblxuICAgICAgICAvL3JlbW92ZSBleGlzdGluZyBsYXllcnNcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZWFjaExheWVyKChsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBbXTtcblxuICAgICAgICAvL3NldCBuZXcgYmFzZSBsYXllclxuICAgICAgICB0aGlzLnNldEJhc2VMYXllcihtYXAuYmFzZUxheWVyKTtcblxuICAgICAgICAvL2FkZCBsYXllcnMgZnJvbSBsb2FkZWQgbWFwXG4gICAgICAgIHRoaXMuYWRkTGF5ZXJzKG1hcC5sYXllcnMpO1xuXG4gICAgICAgIC8vYWRkIGZlYXR1cmVzXG4gICAgICAgIGlmKG1hcC5hbm5vdGF0aW9ucyAmJiBtYXAuYW5ub3RhdGlvbnMuZ2VvSlNPTikge1xuICAgICAgICAgICAgbGV0IGZjID0gbWFwLmFubm90YXRpb25zLmdlb0pTT047XG4gICAgICAgICAgICBpZihmYy5mZWF0dXJlcylcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVzKGZjLmZlYXR1cmVzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVzKFtmY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKFtcbiAgICAgICAgICAgIFtleHRlbnQubWlueSwgZXh0ZW50Lm1pbnhdLFxuICAgICAgICAgICAgW2V4dGVudC5tYXh5LCBleHRlbnQubWF4eF1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbWFwOmxvYWRlZCcsIG1hcCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBleHRlbnRcbiAgICAgKiBAcmV0dXJuIGNvcnJlY3RlZCBvciBkZWZhdWx0IGV4dGVudFxuICAgICAqL1xuICAgIGVuc3VyZUV4dGVudCggZXh0ZW50IDogYW55ICkgOiBhbnkge1xuXG4gICAgICAgIGxldCB3ZXN0ICA9ICFleHRlbnQgfHwgaXNOYU4oZXh0ZW50Lm1pbngpID8gLTE3OS4wIDogZXh0ZW50Lm1pbngqMS4wO1xuICAgICAgICBsZXQgZWFzdCAgPSAhZXh0ZW50IHx8IGlzTmFOKGV4dGVudC5tYXh4KSA/ICAxNzkuMCA6IGV4dGVudC5tYXh4KjEuMDtcbiAgICAgICAgbGV0IHNvdXRoID0gIWV4dGVudCB8fCBpc05hTihleHRlbnQubWlueSkgPyAgLTg5LjAgOiBleHRlbnQubWlueSoxLjA7XG4gICAgICAgIGxldCBub3J0aCA9ICFleHRlbnQgfHwgaXNOYU4oZXh0ZW50Lm1heHkpID8gICA4OS4wIDogZXh0ZW50Lm1heHkqMS4wO1xuXG4gICAgICAgIC8vZW5zdXJlIHgseSBpcyBvcmRlcmVkIGNvcnJlY3RseVxuICAgICAgICBsZXQgdDtcbiAgICAgICAgaWYod2VzdCA+IGVhc3QpIHtcbiAgICAgICAgICAgIHQgPSBNYXRoLm1pbih3ZXN0LCBlYXN0KTtcbiAgICAgICAgICAgIGVhc3QgPSBNYXRoLm1heCh3ZXN0LCBlYXN0KTtcbiAgICAgICAgICAgIHdlc3QgPSB0O1xuICAgICAgICB9XG4gICAgICAgIGlmKHNvdXRoID4gbm9ydGgpIHtcbiAgICAgICAgICAgIHQgPSBNYXRoLm1pbihzb3V0aCwgbm9ydGgpO1xuICAgICAgICAgICAgbm9ydGggPSBNYXRoLm1heChzb3V0aCwgbm9ydGgpO1xuICAgICAgICAgICAgc291dGggPSB0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9wcmV2ZW50IG91dC1vZi1ib3VuZHMgZXh0ZW50c1xuICAgICAgICBpZih3ZXN0IDwgLTE4MC4wKSB3ZXN0ID0gLTE3OS4wO1xuICAgICAgICBpZihlYXN0ID4gMTgwLjApICBlYXN0ID0gIDE3OS4wO1xuICAgICAgICBpZihzb3V0aCA8IC05MC4wKSBzb3V0aCA9IC04OS4wO1xuICAgICAgICBpZihub3J0aCA+IDkwLjApICBub3J0aCA9ICA4OS4wO1xuXG4gICAgICAgIHJldHVybiB7IG1pbnggOiB3ZXN0LCBtaW55IDogc291dGgsIG1heHggOiBlYXN0LCBtYXh5IDogbm9ydGggfTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveU1hcCAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRGVzdHJveWluZyBNYXBcIik7XG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdGFrZSBhbiBleGlzdGluZyBtYXAgdGhhdCBpcyBhbHJlYWR5IHBlcnNpc3RlZCBvbiB0aGVcbiAgICAgKiBzZXJ2ZXIgYW5kIHVubGluayBpdCBoZXJlIGluIHRoZSBjbGllbnQgc28gdGhhdCBpdCB3aWxsIGJlIHNhdmVkXG4gICAgICogYXMgYSBjb21wbGV0ZWx5IG5ldyBtYXAgd2hlbiBtYXBTZXJ2aWNlLnNhdmVNYXAoLi4uKSBpcyBuZXh0IGNhbGxlZFxuICAgICAqL1xuICAgIHNldEFzTmV3TWFwIChtYXBUb1VzZSkge1xuICAgICAgICB0aGlzLl9tYXBJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcERlZiA9IG1hcFRvVXNlIHx8IHRoaXMuaW5pdGlhbGl6ZU1hcERlZmluaXRpb24oKTtcbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgVG9vbCBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgcmVnaXN0ZXJUb29sIChpZCwgdG9vbCkge1xuICAgICAgICB0aGlzLl90b29sc1tpZF0gPSB0b29sO1xuICAgIH1cblxuICAgIHVucmVnaXN0ZXJUb29sIChpZCkge1xuICAgICAgICB0aGlzLl90b29sc1tpZF0gPSBudWxsO1xuICAgIH1cblxuICAgIGVuYWJsZVRvb2wgKGlkLCBmaW5pc2gpIHtcbiAgICAgICAgaWYoIXRoaXMuX3Rvb2xzW2lkXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90b29sc1tpZF0uYWN0aXZhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSgndG9vbDpkaXNhYmxlZCcsIGlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCd0b29sOmVuYWJsZWQnLCBpZCk7XG4gICAgfVxuXG5cbiAgICAvKiAtLS0tLS0tLS0tLSBNSVNDIC0tLS0tLS0tLS0tLSAqL1xuXG4gICAgLy9odHRwczovL2dpdGh1Yi5jb20vZ3NrbGVlL25nU3RvcmFnZVxuICAgIGNhY2hlTWFwICgpIHtcblxuICAgICAgICBpZih0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUuZGlydHkpIHtcbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcFJlc291cmNlQ29udGVudCgpO1xuICAgICAgICAgICAgLy91c2UgZXhwbG9kZWQgbGF5ZXIgaW5mb1xuICAgICAgICAgICAgbWFwLmxheWVycyA9IHRoaXMuX2xheWVyU3RhdGVzLnNsaWNlKDApO1xuICAgICAgICAgICAgLy8gJHNlc3Npb25TdG9yYWdlLm1hcCA9IG1hcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3RvcmVNYXAgKCkge1xuICAgICAgICAvLyBpZigkc2Vzc2lvblN0b3JhZ2UubWFwKSB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIlJlc3RvcmluZyBjYWNoZWQgbWFwXCIpO1xuICAgICAgICAvLyAgICAgbGV0IG1hcCA9ICRzZXNzaW9uU3RvcmFnZS5tYXA7XG4gICAgICAgIC8vICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShtYXApKTtcbiAgICAgICAgLy8gICAgICRzZXNzaW9uU3RvcmFnZS5tYXAgPSBudWxsO1xuICAgICAgICAvLyAgICAgdGhpcy5sb2FkTWFwRnJvbU9iaihtYXApO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbn1cbiJdfQ==