/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as jquery from "jquery";
/** @type {?} */
const jQuery = jquery;
import * as Q from "q";
import { circleMarker, geoJSON, featureGroup, LayerGroup } from 'leaflet';
import { Config, ItemTypes, ServiceFactory, JQueryHttpClient } from 'geoplatform.client';
import LayerFactory from '../layer/factory';
import DefaultBaseLayer from '../layer/baselayer-default';
class Listener {
    constructor() {
        //listeners to be unregistered upon destroy
        this._listeners = {};
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    on(type, listener) {
        if (!this._listeners[type])
            this._listeners[type] = [];
        this._listeners[type].push(listener);
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    off(type, listener) {
        if (!type)
            this._listeners = {};
        if (!this._listeners[type])
            return;
        if (!listener)
            this._listeners[type] = [];
        else {
            /** @type {?} */
            var idx = this._listeners[type].indexOf(listener);
            if (idx >= 0)
                this._listeners[type].splice(idx, 1);
        }
    }
    /**
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    notify(type, ...options) {
        if (!this._listeners[type])
            return;
        /** @type {?} */
        var args = Array.prototype.slice.call(arguments, 1);
        this._listeners[type].forEach(function (l) { l.apply(null, args); });
    }
}
if (false) {
    /** @type {?} */
    Listener.prototype._listeners;
}
export default class MapInstance extends Listener {
    /**
     * @param {?} key
     */
    constructor(key) {
        super();
        this.setHttpClient(new JQueryHttpClient());
        this.setServiceFactory(ServiceFactory);
        //generate random key (see factory below)
        this._key = key || Math.ceil(Math.random() * 9999);
        //registry id of current map if available
        this._mapId = null,
            //definition of map (ie, from server)
            this._mapDef = this.initializeMapDefinition(),
            //primary map instance (ie, leaflet)
            this._mapInstance = null,
            //default map extent (if map doesn't have one for being saved)
            this._defaultExtent = null,
            //current base layer object and leaflet instance
            this._baseLayerDef = null,
            this._baseLayer = null,
            //set definitions of layer states (including layer info) on map
            this._layerStates = [],
            //map layer def ids with leaflet instances
            this._layerCache = {},
            //errors generated by layers loading
            this._layerErrors = [],
            this._layerErrorHandler = function (e) {
                console.log(`MapInstance.defaultLayerErrorHandler() - ${e.id} : ${e.message}`);
            },
            //layer used to store features on map
            this._featureLayer = null,
            this._featureLayerVisible = true,
            //set of registered map tools
            this._tools = [],
            //state management
            this.state = { dirty: false }; // jshint ignore:line
        this._geoJsonLayerOpts = {
            style: function (feature) {
                if (feature.properties.style)
                    return feature.properties.style;
            },
            onEachFeature: function (feature, layer) {
                /** @type {?} */
                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };
                if (~feature.geometry.type.indexOf('Point')) {
                    style.fillOpacity = 0.9;
                }
                /** @type {?} */
                var props = feature.properties = feature.properties || {};
                if (feature.properties.id === undefined || feature.properties.id === null)
                    feature.properties.id = Math.floor(Math.random() * 999999);
                feature.properties.label = props.label || props.title || props.name || "Untitled " + feature.geometry.type + " Feature";
                feature.properties.description = props.description || props.desc || "This feature needs a description!";
                feature.properties.style = props.style || style;
                layer.bindTooltip(props.label);
                /*
                                toggle: setLabelNoHide(bool)
                                it may only exist on markers!
                                */
            },
            pointToLayer: function (feature, latlng) {
                /** @type {?} */
                var style = feature.properties.style || {};
                style.radius = style.radius || 4;
                style.weight = style.weight || 2;
                style.color = style.color || '#03f';
                style.opacity = style.opacity || 0.9;
                style.fillOpacity = style.opacity;
                style.fillColor = style.color;
                return circleMarker(latlng, style);
            }
        };
    }
    /**
     * @return {?}
     */
    dispose() {
        this.destroyMap();
        this.svcCache = null;
        this.serviceFactory = null;
        this.httpClient = null;
        this._key = null;
        this._mapId = null;
        this._mapDef = null;
        this._mapInstance = null;
        this._defaultExtent = null;
        this._baseLayerDef = null;
        this._baseLayer = null;
        this._layerStates = null;
        this._layerCache = null;
        this._layerErrors = null;
        this._featureLayer = null;
        this._featureLayerVisible = true;
        this._tools = null;
        this.state = null;
        this._geoJsonLayerOpts = null;
    }
    /**
     * @return {?}
     */
    getKey() {
        return this._key;
    }
    /**
     * Override default (JQuery-based) map service used by this instance
     * @deprecated use setServiceFactory instead
     * @param {?} mapService - service to use to CRUD map objects
     * @return {?}
     */
    setService(mapService) {
        // this.mapService = mapService;
    }
    /**
     * @param {?} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     * @return {?}
     */
    setServiceFactory(factory) {
        this.svcCache = {}; //wipe out cached services
        this.serviceFactory = factory;
    }
    /**
     * @param {?} httpClient - HttpClient impl to use with the new factory
     * @return {?}
     */
    setHttpClient(httpClient) {
        this.svcCache = {}; //wipe out cached services
        this.httpClient = httpClient;
    }
    /**
     * @param {?} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {?} item service implementation for the requested type
     */
    getService(type) {
        if (!this.svcCache[type])
            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);
        return this.svcCache[type];
    }
    /**
     * @param {?} fn - callback when an error is encountered
     * @return {?}
     */
    setErrorHandler(fn) {
        this._layerErrorHandler = fn;
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerStateIndex(layerId) {
        if (!layerId)
            return -1;
        for (let i = 0; i < this._layerStates.length; ++i) {
            if (this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {
                return i;
            }
        }
        return -1;
        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerState(layerId) {
        /** @type {?} */
        let index = this.getLayerStateIndex(layerId);
        return index >= 0 ? this._layerStates[index] : null;
    }
    /**
     * @return {?}
     */
    initializeMapDefinition() {
        return {
            type: ItemTypes.MAP,
            title: "My New Map",
            label: "My New Map",
            description: "This map needs a description",
            createdBy: null,
            baseLayer: this._baseLayerDef,
            layers: [],
            keywords: [],
            themes: [],
            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']
        };
    }
    /**
     * @param {?=} metadata object
     * @return {?} object definition of the current map suitable for sending to WMVR
     */
    getMapResourceContent(metadata) {
        metadata = metadata || {};
        //map layers
        metadata.layers = this._layerStates.slice(0);
        // ... UAL should support accepting just an id here, so we'll do just that
        metadata.baseLayer = this._baseLayerDef;
        metadata.annotations = this._featureLayer ?
            { title: "Map Features", geoJSON: this._featureLayer.toGeoJSON() } : null;
        /** @type {?} */
        let extent = this._mapInstance.getBounds();
        metadata.extent = {
            minx: extent.getWest(),
            miny: extent.getSouth(),
            maxx: extent.getEast(),
            maxy: extent.getNorth()
        };
        return metadata;
    }
    /**
     * @return {?} Leaflet toolbar
     */
    getDrawControlToolbar() {
        if (!(/** @type {?} */ (this._mapInstance)).drawControl)
            return null;
        /** @type {?} */
        var toolbars = (/** @type {?} */ (this._mapInstance)).drawControl._toolbars;
        /** @type {?} */
        var toolbar = null;
        for (var key in toolbars) {
            if (toolbars.hasOwnProperty(key)) {
                if (toolbars[key]._modes) {
                    toolbar = toolbars[key];
                    break;
                }
            }
        }
        return toolbar;
    }
    /**
     * @param {?} error Leaflet tile load error (.target is layer, .tile is image)
     * @return {?}
     */
    handleLayerError(error) {
        // console.log("MapInstance.handleLayerError() - " +
        //     "Layer's tile failed to load: " + error.tile.src);
        if (!this._layerCache) {
            console.log("Unable to find layer in layer cache. Layer error is " + error);
            return;
        }
        /** @type {?} */
        var layer = error.target;
        for (var id in this._layerCache) {
            if (this._layerCache[id] === layer) {
                this.processLayerError(error, id);
                break;
            }
        }
    }
    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     * @param {?} error
     * @param {?} id
     * @return {?}
     */
    processLayerError(error, id) {
        /** @type {?} */
        var finder = (l) => { return l.id === id || (l.layer && l.layer.id === id); };
        if (!this._layerErrors.find(finder)) {
            /** @type {?} */
            let obj = this.logLayerError(id, "Layer ('" + id + "') failed to completely load. " +
                "It may be inaccessible or misconfigured.");
            /** @type {?} */
            var url = (/** @type {?} */ (error)).tile.src;
            /** @type {?} */
            var params = { id: id };
            url.substring(url.indexOf("?") + 1, url.length).split('&').forEach(function (param) {
                /** @type {?} */
                var p = param.split('=');
                params[p[0]] = p[1];
            });
            /** @type {?} */
            let layerService = this.getService(ItemTypes.LAYER);
            if (layerService) {
                layerService.validate(id, params)
                    .catch(e => {
                    /** @type {?} */
                    var def = this._layerStates.find(finder);
                    if (def) {
                        obj.message = "Layer '" + def.layer.label + "' failed to completely load. " +
                            "Reported cause: " + e.message;
                    }
                    this.notify('layer:error', obj);
                });
            }
        }
    }
    /**
     * @param {?} layerId - identifier of layer generating the error
     * @param {?} errorMsg - message of the error
     * @return {?}
     */
    logLayerError(layerId, errorMsg) {
        /** @type {?} */
        let err = { id: layerId, message: errorMsg };
        this._layerErrors.push(err);
        if (this._layerErrorHandler) {
            this._layerErrorHandler(err);
        }
        return err;
    }
    /**
     * @param {?=} event
     * @param {...?} options
     * @return {?}
     */
    touch(event, ...options) {
        this.state.dirty = true;
        if (event) {
            if (arguments.length > 1) {
                this.notify.apply(this, Array.prototype.slice.call(arguments));
            }
            else
                this.notify(event);
            // console.log("Dirtying map for " + event);
        }
        // else console.log("Dirtying map");
    }
    /**
     * @return {?}
     */
    clean() {
        // console.log("Cleaning map");
        this.state.dirty = false;
    }
    /**
     * @param {?} map
     * @return {?}
     */
    setMap(map) { this._mapInstance = map; }
    /**
     * @return {?} map instance
     */
    getMap() { return this._mapInstance; }
    /**
     * @return {?} definition of map
     */
    getMapDefinition() { return this._mapDef; }
    /**
     * @return {?} identifier of map
     */
    getMapId() { return this._mapId; }
    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param {?} lat number
     * @param {?} lng number
     * @param {?=} zoom number (optional)
     * @return {?}
     */
    setView(lat, lng, zoom) {
        /** @type {?} */
        let z = zoom;
        if (typeof (z) === 'undefined')
            z = this._mapInstance.getZoom();
        this._mapInstance.setView([lat, lng], z);
        this.touch('map:view:changed');
    }
    /**
     * Retrieve the current center of the map
     * @return {?} [lat,lng]
     */
    getView() {
        /** @type {?} */
        var latLng = this._mapInstance.getCenter();
        return [latLng.lat, latLng.lng];
    }
    /**
     * @return {?} integer current zoom level of the map
     */
    getZoom() {
        return this._mapInstance.getZoom();
    }
    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     * @return {?}
     */
    zoomToDefault() {
        if (!this._mapInstance)
            return;
        if (this._defaultExtent) {
            this._mapInstance.fitBounds([
                [this._defaultExtent.miny, this._defaultExtent.minx],
                [this._defaultExtent.maxy, this._defaultExtent.maxx]
            ]);
        }
        else {
            console.log("MapInstance.zoomToDefault() - No default extent specified");
            this._mapInstance.setView([38, -96], 5);
        }
        try {
            this.touch('map:view:changed');
        }
        catch (e) { }
    }
    /**
     * @param {?} extent - either a GP extent object or Leaflet LatLngBounds object
     * @return {?}
     */
    setExtent(extent) {
        if (!extent)
            return;
        if (typeof (extent.minx) !== 'undefined' &&
            typeof (extent.miny) !== 'undefined' &&
            typeof (extent.maxx) !== 'undefined' &&
            typeof (extent.maxy) !== 'undefined') {
            //GP model extent
            this._mapInstance.fitBounds([
                [extent.miny, extent.minx],
                [extent.maxy, extent.maxx]
            ]);
        }
        else if (typeof (extent.getWest) !== 'undefined') {
            //L.LatLngBounds
            this._mapInstance.fitBounds(extent);
        }
        else {
        }
    }
    /**
     * @param {?} layer Leaflet Layer instance or object definition
     * @return {?}
     */
    setBaseLayer(layer) {
        /** @type {?} */
        let promise = null;
        if (!layer) {
            promise = DefaultBaseLayer.get(this.getService(ItemTypes.LAYER));
        }
        else
            promise = Q.resolve(layer);
        promise.then(layer => {
            /** @type {?} */
            let leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                console.log("Warning: MapInstance could not create base " +
                    "layer for '" + layer.id + "'");
                return;
            }
            this._mapInstance.addLayer(leafletLayer);
            (/** @type {?} */ (leafletLayer)).setZIndex(0);
            /** @type {?} */
            let oldBaseLayer = this._baseLayer;
            if (oldBaseLayer) {
                this._mapInstance.removeLayer(oldBaseLayer);
            }
            //remember new base layer
            this._baseLayer = leafletLayer;
            this._baseLayerDef = layer;
            //will notify listeners
            this.touch('baselayer:changed', layer, leafletLayer);
            // this.notify('baselayer:changed', layer, leafletLayer);
        })
            .catch(e => {
            console.log(`MapInstance.setBaseLayer() - Error getting base layer for map : ${e.message}`);
            this.logLayerError(layer.id, "Error setting baselayer on map " +
                "because of the following error(s): " + e.message);
        });
    }
    /**
     * @return {?} array of base layers definitions that can be used
     */
    getBaseLayer() { return this._baseLayerDef; }
    /**
     * @return {?} list of layer states containing layer information
     */
    getLayers() { return this._layerStates; }
    /**
     * @return {?}
     */
    getLayerErrors() { return this._layerErrors; }
    /**
     * @return {?}
     */
    clearLayerErrors() {
        this._layerErrors = [];
        this.notify('layer:error');
    }
    /**
     * @return {?}
     */
    clearOverlays() {
        if (!this._layerCache)
            return;
        for (var i = this._layerStates.length - 1; i >= 0; --i) {
            /** @type {?} */
            var state = this._layerStates[i];
            /** @type {?} */
            var layerInstance = this._layerCache[state.layer.id];
            if (layerInstance) {
                layerInstance.off("layer:error");
                this._layerCache[state.layer.id] = null;
                this._mapInstance.removeLayer(layerInstance);
            }
        }
        this._layerStates = [];
        this.touch('layers:changed');
        //TODO stop listening for layer events
    }
    /**
     * @param {?} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     * @return {?}
     */
    addLayers(layers) {
        if (!this._layerCache) {
            console.log("WARN: attempting to add layers to an empty cache");
            return;
        }
        if (!this._layerCache) {
            console.log("WARN: Attempting to add layers to a map with no layer cache");
            return;
        }
        if (!layers)
            return;
        if (typeof (layers.push) === 'undefined') {
            layers = [layers];
        }
        layers.forEach((obj, index) => {
            /** @type {?} */
            let layer = null;
            /** @type {?} */
            let state = null;
            if (obj.type && obj.type === ItemTypes.LAYER) { //is a layer
                //is a layer
                layer = obj;
            }
            else if (obj.layer) { //is layer state
                //is layer state
                layer = obj.layer; // containing a layer
                state = obj;
            }
            if (!layer) {
                console.log("MapInstance.addLayers() - layer (" + index +
                    ") is not a Layer or a Layer state. Ignoring...");
                return; //layer info is missing, skip it
            }
            //DT-442 prevent adding layer that already exists on map
            if (this._layerCache[layer.id])
                return;
            if (!state) {
                try {
                    /** @type {?} */
                    let layerCopy = JSON.parse(JSON.stringify(layer));
                    state = {
                        opacity: 1,
                        visibility: true,
                        layer: layerCopy
                    };
                }
                catch (e) {
                    throw new Error("Unable to add layer to map because of " + e.message);
                }
            }
            /** @type {?} */
            let z = layers.length - index;
            state.zIndex = z;
            this.addLayerWithState(layer, state);
        });
        this.touch('layers:changed');
    }
    /**
     * @param {?} layer - GeoPlatform Layer instance
     * @param {?} state - GeoPlatform Layer State
     * @return {?}
     */
    addLayerWithState(layer, state) {
        /** @type {?} */
        var leafletLayer = null;
        try {
            if (!layer || !state)
                throw new Error("Invalid argument, missing layer and or state");
            leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                throw new Error("Could not create leaflet layer for GP Layer '" +
                    layer.id + "'");
            }
        }
        catch (e) {
            this.logLayerError(layer.id, "Layer '" + layer.label + "' could not be added to the " +
                "map instance; " + e.message);
        }
        if (!leafletLayer)
            return;
        //cache leaflet object first
        if (this._layerCache)
            this._layerCache[layer.id] = leafletLayer;
        //listen for layer errors so we can inform the user
        // that a layer hasn't been loaded in a useful way
        leafletLayer.on('tileerror', (e) => { this.handleLayerError(e); });
        this._mapInstance.addLayer(leafletLayer);
        if (!isNaN(state.zIndex) && leafletLayer.setZIndex)
            leafletLayer.setZIndex(state.zIndex);
        this._layerStates.push(state);
        this.notify('layer:added', layer, leafletLayer);
        // if layer is initially "off" or...
        // if layer is initially not 100% opaque
        if (!state.visibility || state.opacity < 1) {
            // initialize layer visibility and opacity async, or else
            // some of the layers won't get properly initialized
            setTimeout((layer, state) => {
                this.setLayerVisibility(layer, state.visibility);
                this.setLayerOpacity(layer, state.opacity);
                //TODO notify of change
                //DT-2102 timeout needs to be large enough or else
                // feature layers won't get opacity updated on map load
            }, 2000, leafletLayer, state);
        }
    }
    /**
     * @param {?} from - position of layer being moved
     * @param {?} to - desired position to move layer to
     * @return {?}
     */
    moveLayer(from, to) {
        if (!this._layerCache)
            return;
        if (!this._layerCache)
            return;
        if (isNaN(from))
            return;
        //end of list
        if (isNaN(to))
            to = this._layerStates.length - 1;
        /** @type {?} */
        let copy = this._layerStates.splice(from, 1)[0]; //grab layer being moved
        this._layerStates.splice(to, 0, copy);
        for (let z = 1, i = this._layerStates.length - 1; i >= 0; --i, ++z) {
            /** @type {?} */
            let layerState = this._layerStates[i];
            /** @type {?} */
            let layerInstance = this._layerCache[layerState.layer.id];
            if (layerInstance) {
                layerInstance.setZIndex(z);
                layerState.zIndex = z;
            }
        }
        this.touch('layers:changed', this.getLayers());
    }
    /**
     *
     * @param {?} id
     * @return {?}
     */
    removeLayer(id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            let index = this.getLayerStateIndex(id);
            // console.log("MapInstance.removeLayer(" + id + ")");
            if (index >= 0 && index < this._layerStates.length)
                this._layerStates.splice(index, 1);
            //stop listening for errors
            layerInstance.off("layer:error");
            //remove layer from map
            this._mapInstance.removeLayer(layerInstance);
            //remove layer from cache
            this._layerCache[id] = null;
        }
        this.touch('layers:changed');
    }
    /**
     *
     * @param {?} id
     * @return {?}
     */
    toggleLayerVisibility(id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            let state = this.getLayerState(id);
            state.visibility = !state.visibility;
            if (layerInstance._currentImage) {
                //ESRI Image Service layers have an IMG element
                // that gets modified and replaced every map event (zoom/pan)
                // so we can't just toggle classes like on other layers.
                //Instead, we need to use the ESRI setOpacity method to toggle
                // but need to update layer state as well.
                layerInstance.setOpacity(state.visibility ? 1 : 0);
                state.opacity = layerInstance.getOpacity();
                return;
            }
            this.setLayerVisibility(layerInstance, state.visibility);
        }
    }
    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} visible - flag indicating visibility of layer
     * @return {?}
     */
    setLayerVisibility(layerInstance, visible) {
        if ((/** @type {?} */ (layerInstance)).setVisibility) {
            //using custom method provided in src/layer/module.js
            (/** @type {?} */ (layerInstance)).setVisibility(visible);
        }
        else if ((/** @type {?} */ (layerInstance))._container) {
            /** @type {?} */
            let el = jQuery((/** @type {?} */ (layerInstance))._container);
            // if(visible) el.removeClass("invisible");
            // else el.addClass('invisible');
            el.css({ 'display': visible ? '' : 'none' });
        }
        this.touch('map:layer:changed');
    }
    /**
     *
     * @param {?} id
     * @param {?} opacity
     * @return {?}
     */
    updateLayerOpacity(id, opacity) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        //if layer id is for base layer...
        if (!layerInstance && this._baseLayerDef.id === id) {
            layerInstance = this._baseLayer;
        }
        //adjust rendered leaflet layer
        opacity = this.setLayerOpacity(layerInstance, opacity);
        /** @type {?} */
        let state = this.getLayerState(id);
        if (state)
            state.opacity = opacity;
    }
    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} opacity - value between 0 and 1.0 or 0 and 100
     * @return {?} normalized opacity value between 0 and 1.0
     */
    setLayerOpacity(layerInstance, opacity) {
        if (layerInstance && (/** @type {?} */ (layerInstance)).setOpacity) {
            if (opacity > 1.0)
                opacity = opacity / 100.0;
            (/** @type {?} */ (layerInstance)).setOpacity(opacity);
            this.touch('map:layer:changed');
        }
        return opacity;
    }
    /**
     * @param {?} gpLayer
     * @return {?} Leaflet layer instance representing that layer or null
     */
    getLeafletLayerFor(gpLayer) {
        if (!gpLayer || !this._layerCache)
            return null;
        /** @type {?} */
        let leafletLayer = this._layerCache[gpLayer.id];
        return leafletLayer || null;
    }
    /**
     *
     * @param {?} layerId
     * @return {?}
     */
    toggleGetFeatureInfo(layerId) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[layerId];
        if (layerInstance) {
            if (typeof (layerInstance.enableGetFeatureInfo) !== 'undefined') {
                if (layerInstance.isGetFeatureInfoEnabled()) {
                    layerInstance.disableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).removeClass('selectable-cursor');
                }
                else {
                    layerInstance.enableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).addClass('selectable-cursor');
                }
            }
        }
    }
    /**
     * @return {?} array of features on the map
     */
    getFeatures() {
        if (this._featureLayer) {
            /** @type {?} */
            let geojson = this._featureLayer.toGeoJSON();
            return (/** @type {?} */ (geojson)).features;
        }
        return [];
    }
    /**
     * @param {?} json geojson object or array of geojson objects
     * @return {?}
     */
    addFeatures(json) {
        if (!json)
            return;
        if (typeof (json.push) !== 'undefined') {
            //array of features
            for (var i = 0; i < json.length; ++i)
                this.addFeature(json[i], false);
            this.touch('features:changed');
        }
        else if (json.features) {
            this.addFeatures(json.features);
        }
        else { //single feature
            //single feature
            this.addFeature(json, true);
        }
    }
    /**
     * @param {?} json geojson object
     * @param {?=} fireEvent
     * @return {?}
     */
    addFeature(json, fireEvent) {
        // var type = json.type;
        // var coordinates = json.coordinates;
        if (!this._featureLayer) {
            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);
            this._featureLayer = featureGroup().addTo(this._mapInstance);
        }
        /** @type {?} */
        var opts = jQuery.extend({}, this._geoJsonLayerOpts);
        geoJSON(json, opts).eachLayer((l) => this.addFeatureLayer(l));
        if (typeof (fireEvent) === 'undefined' || fireEvent === true)
            this.touch('features:changed');
        else
            this.touch();
        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));
    }
    /**
     * @param {?} featureJson object defining a GeoJSON feature
     * @return {?}
     */
    updateFeature(featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            (/** @type {?} */ (layer)).feature = featureJson;
            //update style
            layer.setStyle(featureJson.properties.style);
            /** @type {?} */
            var label = featureJson.properties.label ||
                "Untitled " + featureJson.geometry.type + " Feature";
            layer.bindTooltip(label);
            // layer.redraw();
            this.touch("map:feature:changed");
        }
    }
    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param {?} featureJson object defining GeoJSON feature
     * @return {?}
     */
    replaceFeature(featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            //remove existing
            this._featureLayer.removeLayer(layer);
            //add replacement
            geoJSON(featureJson, this._geoJsonLayerOpts)
                .eachLayer((l) => this.addFeatureLayer(l));
            this.touch("map:feature:changed");
        }
    }
    /**
     * @param {?} featureId identifier of feature to focus the map on
     * @return {?}
     */
    focusFeature(featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer) {
            if (typeof (layer.getBounds) !== 'undefined') {
                /** @type {?} */
                let extent = layer.getBounds();
                this._mapInstance.fitBounds(extent);
            }
            else if (typeof ((/** @type {?} */ (layer)).getLatLng) !== 'undefined') {
                /** @type {?} */
                let latLng = (/** @type {?} */ (layer)).getLatLng();
                this._mapInstance.panTo(latLng);
            }
            else {
                console.log("MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng");
            }
        }
        else {
            console.log("MapInstance.focusFeature() - Cannot focus feature because it has no layer");
        }
    }
    /**
     * @param {?} featureId : string
     * @return {?}
     */
    removeFeature(featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer && this._featureLayer) {
            this._featureLayer.removeLayer(layer);
            this.touch('features:changed');
        }
    }
    /**
     *
     * @return {?}
     */
    removeFeatures() {
        if (this._featureLayer) {
            this._featureLayer.clearLayers();
            this.touch("features:changed");
        }
    }
    /**
     *
     * @param {?=} featureId
     * @return {?}
     */
    getFeatureLayer(featureId) {
        //if no feature was specified, return root feature layer
        if (!featureId)
            return this._featureLayer;
        //otherwise, find feature...
        if (!this._featureLayer)
            return null;
        /** @type {?} */
        var features = this._featureLayer.getLayers();
        for (var i = 0; i < features.length; ++i) {
            if ((/** @type {?} */ (features[i])).feature &&
                (/** @type {?} */ (features[i])).feature.properties.id === featureId) {
                return (/** @type {?} */ (features[i]));
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    toggleFeaturesLayer() {
        if (!this._featureLayer)
            return false; //ignore if not rendered yet
        this._featureLayerVisible = !this._featureLayerVisible;
        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);
        return this._featureLayerVisible;
    }
    /**
     * @param {?} feature - Leaflet feature instance
     * @param {?} visibility - flag
     * @return {?}
     */
    setFeatureVisibility(feature, visibility) {
        this.setFeatureLayerVisibility(feature, visibility);
    }
    /**
     * @return {?}
     */
    getFeaturesLayerVisibility() {
        return this._featureLayerVisible;
    }
    /**
     * @param {?} layer
     * @return {?}
     */
    addFeatureLayer(layer) {
        this._addFeatureLayer(layer);
        this.touch("features:changed");
    }
    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {?} layer
     * @return {?}
     */
    _addFeatureLayer(layer) {
        if (!(/** @type {?} */ (layer)).feature && layer instanceof LayerGroup) {
            layer.eachLayer((child) => {
                this._addFeatureLayer(child);
            });
        }
        else {
            this._featureLayer.addLayer(layer);
        }
    }
    /**
     * @param {?} layer
     * @param {?} visibility
     * @return {?}
     */
    setFeatureLayerVisibility(layer, visibility) {
        if (!layer)
            return;
        this._featureLayerVisible = visibility;
        if (layer.getLayers) {
            layer.getLayers().forEach((child) => {
                this.setFeatureLayerVisibility(child, visibility);
            });
        }
        else {
            /** @type {?} */
            let container = layer._container || layer._path;
            if (container)
                container.style.display = visibility ? '' : 'none';
        }
    }
    /**
     * @param {?} metadata
     * @return {?} resolving persisted map
     */
    save(metadata) {
        return this.saveMap(metadata);
    }
    /**
     * @param {?} md object containing metadata properties for map
     * @return {?}
     */
    saveMap(md) {
        /** @type {?} */
        let metadata = md || {};
        /** @type {?} */
        const gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';
        metadata.resourceTypes = metadata.resourceTypes || [];
        if (metadata.resourceTypes.indexOf(gpMapType) < 0)
            metadata.resourceTypes.push(gpMapType);
        /** @type {?} */
        var content = this.getMapResourceContent(metadata);
        //ensure the two name properties line up
        if (content.title && content.title !== content.label) {
            content.label = content.title;
        }
        else if (content.label && !content.title) {
            content.title = content.label;
        }
        // console.log("Updating: " + JSON.stringify(map));
        return this.getService(ItemTypes.MAP)
            .save(content)
            .then(result => {
            //track new map's info so we can update it with next save
            if (!this._mapId)
                this._mapId = result.id;
            this._mapDef = result;
            this._defaultExtent = result.extent;
            this.clean();
            return result;
        })
            .catch(err => {
            console.log("MapCore MapInstance.saveMap() - " +
                "The requested map could not be saved because: " + err.message);
            /** @type {?} */
            let e = new Error("The requested map could not be saved because of the following error(s): " +
                err.message);
            return Q.reject(e);
        });
    }
    /**
     * Retrieve a map's descriptor from the registry
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    fetchMap(mapId) {
        //Having to send cache busting parameter to avoid CORS header cache
        // not sending correct Origin value
        return this.getService(ItemTypes.MAP).get(mapId);
    }
    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    loadMap(mapId) {
        return this.fetchMap(mapId).then(map => {
            if (!map) {
                throw new Error("The requested map ('" + mapId +
                    "') came back null");
            }
            else if (typeof (map) === 'string') {
                throw new Error("The requested map ('" + mapId +
                    "') came back as a string");
            }
            else if (map.message) {
                throw new Error("There was an error loading the requested map ('" +
                    mapId + "'): " + map.message);
            }
            //loading a map by its ID, so we need to increment it's view count
            if ('development' !== Config.env) {
                setTimeout((map) => {
                    /** @type {?} */
                    let views = map.statistics ? (map.statistics.numViews || 0) : 0;
                    /** @type {?} */
                    let patch = [{ op: 'replace', path: '/statistics/numViews', value: views + 1 }];
                    this.getService(ItemTypes.MAP).patch(map.id, patch)
                        // this.mapService.patch(map.id, patch)
                        .then(updated => { map.statistics = updated.statistics; })
                        .catch(e => {
                        console.log("MapInstance.saveMap() - Error updating view " +
                            "count for map ('" + mapId + "'): " + e);
                    });
                }, 1000, map);
            }
            //load the map into the viewer
            this.loadMapFromObj(map);
            return map;
        })
            .catch(err => {
            console.log("MapInstance.loadMap() - " +
                "The requested map could not be loaded because " + err.message);
            /** @type {?} */
            let e = new Error("The requested map ('" + mapId +
                "') could not be loaded because of the following error(s): " +
                err.message);
            return Q.reject(e);
        });
    }
    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param {?} map object
     * @return {?}
     */
    loadMapFromObj(map) {
        // console.log("Loading Map Object");
        // console.log(map);
        this._mapId = map.id;
        this._mapDef = map;
        map.extent = map.extent || {};
        /** @type {?} */
        let west = isNaN(map.extent.minx) ? -179.0 : map.extent.minx * 1.0;
        /** @type {?} */
        let east = isNaN(map.extent.maxx) ? 179.0 : map.extent.maxx * 1.0;
        /** @type {?} */
        let south = isNaN(map.extent.miny) ? -89.0 : map.extent.miny * 1.0;
        /** @type {?} */
        let north = isNaN(map.extent.maxy) ? 89.0 : map.extent.maxy * 1.0;
        /** @type {?} */
        let t;
        if (west > east) {
            t = Math.min(west, east);
            east = map.extent.maxx = Math.max(west, east);
            west = map.extent.minx = t;
        }
        if (south > north) {
            t = Math.min(south, north);
            north = map.extent.maxy = Math.max(south, north);
            south = map.extent.miny = t;
        }
        //prevent out-of-bounds extents
        if (west < -180.0)
            west = -179.0;
        if (east > 180.0)
            east = 179.0;
        if (south < -90.0)
            south = -89.0;
        if (north > 90.0)
            north = 89.0;
        //set extent from loaded map
        this._defaultExtent = map.extent;
        /** @type {?} */
        var extent = map.extent;
        //remove existing layers
        this._mapInstance.eachLayer((l) => {
            this._mapInstance.removeLayer(l);
        });
        this._layerCache = {};
        this._layerStates = [];
        //set new base layer
        this.setBaseLayer(map.baseLayer);
        //add layers from loaded map
        this.addLayers(map.layers);
        //add features
        if (map.annotations && map.annotations.geoJSON) {
            /** @type {?} */
            let fc = map.annotations.geoJSON;
            if (fc.features)
                this.addFeatures(fc.features);
            else
                this.addFeatures([fc]);
        }
        this._mapInstance.fitBounds([
            [extent.miny, extent.minx],
            [extent.maxy, extent.maxx]
        ]);
        this.clean();
        this.notify('map:loaded', map);
    }
    /**
     *
     * @return {?}
     */
    destroyMap() {
        // console.log("Destroying Map");
        this._mapInstance = null;
        this._layerCache = null;
        this._layerStates = null;
        this._featureLayer = null;
    }
    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     * @param {?} mapToUse
     * @return {?}
     */
    setAsNewMap(mapToUse) {
        this._mapId = null;
        this._mapDef = mapToUse || this.initializeMapDefinition();
    }
    /**
     * @param {?} id
     * @param {?} tool
     * @return {?}
     */
    registerTool(id, tool) {
        this._tools[id] = tool;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    unregisterTool(id) {
        this._tools[id] = null;
    }
    /**
     * @param {?} id
     * @param {?} finish
     * @return {?}
     */
    enableTool(id, finish) {
        if (!this._tools[id])
            return false;
        this._tools[id].activate(function () {
            this.notify('tool:disabled', id);
        });
        this.notify('tool:enabled', id);
    }
    /**
     * @return {?}
     */
    cacheMap() {
        if (this.state && this.state.dirty) {
            /** @type {?} */
            var map = this.getMapResourceContent();
            //use exploded layer info
            map.layers = this._layerStates.slice(0);
            // $sessionStorage.map = map;
        }
    }
    /**
     * @return {?}
     */
    restoreMap() {
        // if($sessionStorage.map) {
        //     console.log("Restoring cached map");
        //     let map = $sessionStorage.map;
        //     // console.log(JSON.stringify(map));
        //     $sessionStorage.map = null;
        //     this.loadMapFromObj(map);
        // }
    }
}
if (false) {
    /** @type {?} */
    MapInstance.prototype.svcCache;
    /** @type {?} */
    MapInstance.prototype.serviceFactory;
    /** @type {?} */
    MapInstance.prototype.httpClient;
    /** @type {?} */
    MapInstance.prototype._key;
    /** @type {?} */
    MapInstance.prototype._mapId;
    /** @type {?} */
    MapInstance.prototype._mapDef;
    /** @type {?} */
    MapInstance.prototype._mapInstance;
    /** @type {?} */
    MapInstance.prototype._defaultExtent;
    /** @type {?} */
    MapInstance.prototype._baseLayerDef;
    /** @type {?} */
    MapInstance.prototype._baseLayer;
    /** @type {?} */
    MapInstance.prototype._layerStates;
    /** @type {?} */
    MapInstance.prototype._layerCache;
    /** @type {?} */
    MapInstance.prototype._layerErrors;
    /** @type {?} */
    MapInstance.prototype._layerErrorHandler;
    /** @type {?} */
    MapInstance.prototype._featureLayer;
    /** @type {?} */
    MapInstance.prototype._featureLayerVisible;
    /** @type {?} */
    MapInstance.prototype._tools;
    /** @type {?} */
    MapInstance.prototype.state;
    /** @type {?} */
    MapInstance.prototype._geoJsonLayerOpts;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdGFuY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9nZW9wbGF0Zm9ybS5tYXAvIiwic291cmNlcyI6WyJtYXAvaW5zdGFuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUVBLE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDOztBQUNqQyxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFFdEIsT0FBTyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUM7QUFFdkIsT0FBTyxFQUVILFlBQVksRUFBRSxPQUFPLEVBQ3JCLFlBQVksRUFBZ0IsVUFBVSxFQUN6QyxNQUFNLFNBQVMsQ0FBQztBQUVqQixPQUFPLEVBQ0gsTUFBTSxFQUFFLFNBQVMsRUFDakIsY0FBYyxFQUNkLGdCQUFnQixFQUNuQixNQUFNLG9CQUFvQixDQUFDO0FBRTVCLE9BQU8sWUFBWSxNQUFNLGtCQUFrQixDQUFDO0FBRTVDLE9BQU8sZ0JBQWdCLE1BQU0sNEJBQTRCLENBQUM7QUFHMUQ7SUFJSTs7UUFFSSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztLQUN4Qjs7Ozs7O0lBRUQsRUFBRSxDQUFFLElBQUksRUFBRSxRQUFRO1FBQ2QsSUFBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQy9CLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ3hDOzs7Ozs7SUFFRCxHQUFHLENBQUUsSUFBSSxFQUFFLFFBQVE7UUFDZixJQUFHLENBQUMsSUFBSTtZQUFFLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO1FBQy9CLElBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztZQUFFLE9BQU87UUFDbEMsSUFBRyxDQUFDLFFBQVE7WUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLElB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QUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUMsR0FBRyxDQUFDOztRQUNsRSxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFDLEdBQUcsQ0FBQzs7UUFDbEUsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUMsR0FBRyxDQUFDOztRQUdsRSxJQUFJLENBQUMsQ0FBQztRQUNOLElBQUcsSUFBSSxHQUFHLElBQUksRUFBRTtZQUNaLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN6QixJQUFJLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDOUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztTQUM5QjtRQUNELElBQUcsS0FBSyxHQUFHLEtBQUssRUFBRTtZQUNkLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztZQUMzQixLQUFLLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDakQsS0FBSyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztTQUMvQjs7UUFHRCxJQUFHLElBQUksR0FBRyxDQUFDLEtBQUs7WUFBRSxJQUFJLEdBQUcsQ0FBQyxLQUFL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UTtRQUVKLElBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTs7WUFDL0IsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7O1lBRXZDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7O1NBRTNDO0tBQ0o7Ozs7SUFFRCxVQUFVOzs7Ozs7OztLQVFUO0NBRUoiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0ICogYXMganF1ZXJ5IGZyb20gXCJqcXVlcnlcIjtcbmNvbnN0IGpRdWVyeSA9IGpxdWVyeTtcblxuaW1wb3J0ICogYXMgUSBmcm9tIFwicVwiO1xuaW1wb3J0ICogYXMgZ2VvanNvbiBmcm9tICdnZW9qc29uJztcbmltcG9ydCB7XG4gICAgTWFwLCBMYXllciwgTGF0TG5nLCBMYXRMbmdCb3VuZHMsXG4gICAgY2lyY2xlTWFya2VyLCBnZW9KU09OLFxuICAgIGZlYXR1cmVHcm91cCwgRmVhdHVyZUdyb3VwLCBMYXllckdyb3VwXG59IGZyb20gJ2xlYWZsZXQnO1xuXG5pbXBvcnQge1xuICAgIENvbmZpZywgSXRlbVR5cGVzLFxuICAgIFNlcnZpY2VGYWN0b3J5LCBJdGVtU2VydmljZSwgTWFwU2VydmljZSwgTGF5ZXJTZXJ2aWNlLFxuICAgIEpRdWVyeUh0dHBDbGllbnRcbn0gZnJvbSAnZ2VvcGxhdGZvcm0uY2xpZW50JztcblxuaW1wb3J0IExheWVyRmFjdG9yeSBmcm9tICcuLi9sYXllci9mYWN0b3J5JztcbmltcG9ydCBPU00gZnJvbSBcIi4uL2xheWVyL29zbVwiO1xuaW1wb3J0IERlZmF1bHRCYXNlTGF5ZXIgZnJvbSAnLi4vbGF5ZXIvYmFzZWxheWVyLWRlZmF1bHQnO1xuXG5cbmNsYXNzIExpc3RlbmVyIHtcblxuICAgIF9saXN0ZW5lcnMgOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy9saXN0ZW5lcnMgdG8gYmUgdW5yZWdpc3RlcmVkIHVwb24gZGVzdHJveVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG5cbiAgICBvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSlcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgb2ZmICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZighdHlwZSkgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICAgIGlmKCF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pIHJldHVybjtcbiAgICAgICAgaWYoIWxpc3RlbmVyKSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYoaWR4ID49IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm90aWZ5KHR5cGUsIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xpc3RlbmVyc1t0eXBlXSkgcmV0dXJuO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHsgbC5hcHBseShudWxsLCBhcmdzKTsgfSk7XG4gICAgfVxuXG59XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBJbnN0YW5jZSBleHRlbmRzIExpc3RlbmVyIHtcblxuICAgIHByaXZhdGUgc3ZjQ2FjaGUgICAgICAgIDogYW55O1xuICAgIHByaXZhdGUgc2VydmljZUZhY3RvcnkgIDogYW55O1xuICAgIHByaXZhdGUgaHR0cENsaWVudCAgICAgIDogYW55O1xuICAgIHB1YmxpYyBfa2V5ICAgICAgICAgICAgOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfbWFwSWQgICAgICAgICAgOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfbWFwRGVmICAgICAgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfbWFwSW5zdGFuY2UgICAgOiBNYXA7XG4gICAgcHJpdmF0ZSBfZGVmYXVsdEV4dGVudCAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfYmFzZUxheWVyRGVmICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfYmFzZUxheWVyICAgICAgOiBMYXllcjtcbiAgICBwcml2YXRlIF9sYXllclN0YXRlcyAgICA6IGFueTtcbiAgICBwcml2YXRlIF9sYXllckNhY2hlICAgICA6IGFueTtcbiAgICBwcml2YXRlIF9sYXllckVycm9ycyAgICA6IGFueVtdO1xuICAgIHByaXZhdGUgX2xheWVyRXJyb3JIYW5kbGVyIDogRnVuY3Rpb247XG4gICAgcHJpdmF0ZSBfZmVhdHVyZUxheWVyICAgOiBGZWF0dXJlR3JvdXA7XG4gICAgcHJpdmF0ZSBfZmVhdHVyZUxheWVyVmlzaWJsZSAgOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3Rvb2xzICAgICAgICAgIDogYW55W107XG4gICAgcHJpdmF0ZSBzdGF0ZSAgICAgICAgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfZ2VvSnNvbkxheWVyT3B0cyA6IGFueTtcblxuXG5cblxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuc2V0SHR0cENsaWVudChuZXcgSlF1ZXJ5SHR0cENsaWVudCgpKTtcbiAgICAgICAgdGhpcy5zZXRTZXJ2aWNlRmFjdG9yeShTZXJ2aWNlRmFjdG9yeSk7XG5cbiAgICAgICAgLy9nZW5lcmF0ZSByYW5kb20ga2V5IChzZWUgZmFjdG9yeSBiZWxvdylcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5IHx8IE1hdGguY2VpbChNYXRoLnJhbmRvbSgpKjk5OTkpO1xuXG4gICAgICAgIC8vcmVnaXN0cnkgaWQgb2YgY3VycmVudCBtYXAgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRoaXMuX21hcElkID0gbnVsbCxcblxuICAgICAgICAvL2RlZmluaXRpb24gb2YgbWFwIChpZSwgZnJvbSBzZXJ2ZXIpXG4gICAgICAgIHRoaXMuX21hcERlZiA9IHRoaXMuaW5pdGlhbGl6ZU1hcERlZmluaXRpb24oKSxcblxuICAgICAgICAvL3ByaW1hcnkgbWFwIGluc3RhbmNlIChpZSwgbGVhZmxldClcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UgPSBudWxsLFxuXG4gICAgICAgIC8vZGVmYXVsdCBtYXAgZXh0ZW50IChpZiBtYXAgZG9lc24ndCBoYXZlIG9uZSBmb3IgYmVpbmcgc2F2ZWQpXG4gICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSBudWxsLFxuXG4gICAgICAgIC8vY3VycmVudCBiYXNlIGxheWVyIG9iamVjdCBhbmQgbGVhZmxldCBpbnN0YW5jZVxuICAgICAgICB0aGlzLl9iYXNlTGF5ZXJEZWYgPSBudWxsLFxuICAgICAgICB0aGlzLl9iYXNlTGF5ZXIgPSBudWxsLFxuXG4gICAgICAgIC8vc2V0IGRlZmluaXRpb25zIG9mIGxheWVyIHN0YXRlcyAoaW5jbHVkaW5nIGxheWVyIGluZm8pIG9uIG1hcFxuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IFtdLFxuXG4gICAgICAgIC8vbWFwIGxheWVyIGRlZiBpZHMgd2l0aCBsZWFmbGV0IGluc3RhbmNlc1xuICAgICAgICB0aGlzLl9sYXllckNhY2hlID0ge30sXG5cbiAgICAgICAgLy9lcnJvcnMgZ2VuZXJhdGVkIGJ5IGxheWVycyBsb2FkaW5nXG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JzPSBbXSxcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTWFwSW5zdGFuY2UuZGVmYXVsdExheWVyRXJyb3JIYW5kbGVyKCkgLSAke2UuaWR9IDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9sYXllciB1c2VkIHRvIHN0b3JlIGZlYXR1cmVzIG9uIG1hcFxuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIgPSBudWxsLFxuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlID0gdHJ1ZSxcblxuICAgICAgICAvL3NldCBvZiByZWdpc3RlcmVkIG1hcCB0b29sc1xuICAgICAgICB0aGlzLl90b29scyA9IFtdLFxuXG4gICAgICAgIC8vc3RhdGUgbWFuYWdlbWVudFxuICAgICAgICB0aGlzLnN0YXRlID0geyBkaXJ0eTogZmFsc2UgfTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAgICAgdGhpcy5fZ2VvSnNvbkxheWVyT3B0cyAgPSB7XG4gICAgICAgICAgICBzdHlsZTogZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGlmKGZlYXR1cmUucHJvcGVydGllcy5zdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVhY2hGZWF0dXJlOiBmdW5jdGlvbihmZWF0dXJlLCBsYXllcikge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0geyB3ZWlnaHQ6IDIsIGNvbG9yOiAnIzAzZicsIG9wYWNpdHk6IDAuOSwgcmFkaXVzOiA0LCBmaWxsQ29sb3I6ICcjMDNmJywgZmlsbE9wYWNpdHk6IDAuNSB9O1xuICAgICAgICAgICAgICAgIGlmKH5mZWF0dXJlLmdlb21ldHJ5LnR5cGUuaW5kZXhPZignUG9pbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5maWxsT3BhY2l0eSA9IDAuOTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmZWF0dXJlLnByb3BlcnRpZXMgPSBmZWF0dXJlLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgICAgICAgICAgaWYoZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID09PSB1bmRlZmluZWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOTk5OTk5KTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMubGFiZWwgPSBwcm9wcy5sYWJlbCB8fCBwcm9wcy50aXRsZSB8fCBwcm9wcy5uYW1lIHx8IFwiVW50aXRsZWQgXCIgKyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgKyBcIiBGZWF0dXJlXCI7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uID0gcHJvcHMuZGVzY3JpcHRpb24gfHwgcHJvcHMuZGVzYyB8fCBcIlRoaXMgZmVhdHVyZSBuZWVkcyBhIGRlc2NyaXB0aW9uIVwiO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZSA9IHByb3BzLnN0eWxlIHx8IHN0eWxlO1xuXG4gICAgICAgICAgICAgICAgbGF5ZXIuYmluZFRvb2x0aXAocHJvcHMubGFiZWwpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgdG9nZ2xlOiBzZXRMYWJlbE5vSGlkZShib29sKVxuICAgICAgICAgICAgICAgIGl0IG1heSBvbmx5IGV4aXN0IG9uIG1hcmtlcnMhXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludFRvTGF5ZXI6IGZ1bmN0aW9uIChmZWF0dXJlIDogYW55LCBsYXRsbmcgOiBMYXRMbmcgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gZmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlIHx8IHt9O1xuICAgICAgICAgICAgICAgIHN0eWxlLnJhZGl1cyA9IHN0eWxlLnJhZGl1cyB8fCA0O1xuICAgICAgICAgICAgICAgIHN0eWxlLndlaWdodCA9IHN0eWxlLndlaWdodCB8fCAyO1xuICAgICAgICAgICAgICAgIHN0eWxlLmNvbG9yID0gc3R5bGUuY29sb3IgfHwgJyMwM2YnO1xuICAgICAgICAgICAgICAgIHN0eWxlLm9wYWNpdHkgPSBzdHlsZS5vcGFjaXR5IHx8IDAuOTtcbiAgICAgICAgICAgICAgICBzdHlsZS5maWxsT3BhY2l0eSA9IHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgc3R5bGUuZmlsbENvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpcmNsZU1hcmtlcihsYXRsbmcsIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBkaXNwb3NlICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95TWFwKCk7XG4gICAgICAgIHRoaXMuc3ZjQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZpY2VGYWN0b3J5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fa2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXBEZWYgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9iYXNlTGF5ZXJEZWYgPSBudWxsO1xuICAgICAgICB0aGlzLl9iYXNlTGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllckVycm9ycz0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Rvb2xzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dlb0pzb25MYXllck9wdHMgPSBudWxsO1xuICAgIH1cblxuXG4gICAgZ2V0S2V5ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBkZWZhdWx0IChKUXVlcnktYmFzZWQpIG1hcCBzZXJ2aWNlIHVzZWQgYnkgdGhpcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBtYXBTZXJ2aWNlIC0gc2VydmljZSB0byB1c2UgdG8gQ1JVRCBtYXAgb2JqZWN0c1xuICAgICAqIEBkZXByZWNhdGVkIHVzZSBzZXRTZXJ2aWNlRmFjdG9yeSBpbnN0ZWFkXG4gICAgICovXG4gICAgc2V0U2VydmljZShtYXBTZXJ2aWNlIDogTWFwU2VydmljZSkge1xuICAgICAgICAvLyB0aGlzLm1hcFNlcnZpY2UgPSBtYXBTZXJ2aWNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmYWN0b3J5IC0gR2VvUGxhdGZvcm0gU2VydmljZUZhY3RvcnkgdG8gaW5zdGFudGlhdGUgc2VydmljZXMgZm9yIG1hcHMgYW5kIGxheWVyc1xuICAgICAqL1xuICAgIHNldFNlcnZpY2VGYWN0b3J5KGZhY3RvcnkgOiBhbnkpIHtcbiAgICAgICAgdGhpcy5zdmNDYWNoZSA9IHt9OyAvL3dpcGUgb3V0IGNhY2hlZCBzZXJ2aWNlc1xuICAgICAgICB0aGlzLnNlcnZpY2VGYWN0b3J5ID0gZmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaHR0cENsaWVudCAtIEh0dHBDbGllbnQgaW1wbCB0byB1c2Ugd2l0aCB0aGUgbmV3IGZhY3RvcnlcbiAgICAgKi9cbiAgICBzZXRIdHRwQ2xpZW50KGh0dHBDbGllbnQgOiBhbnkpIHtcbiAgICAgICAgdGhpcy5zdmNDYWNoZSA9IHt9OyAvL3dpcGUgb3V0IGNhY2hlZCBzZXJ2aWNlc1xuICAgICAgICB0aGlzLmh0dHBDbGllbnQgPSBodHRwQ2xpZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gR2VvUGxhdGZvcm0gT2JqZWN0IG1vZGVsIHR5cGUgdG8gc3VwcG9ydCAoXCJNYXBcIiwgXCJMYXllclwiLCBldGMpXG4gICAgICogQHJldHVybiBpdGVtIHNlcnZpY2UgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZXF1ZXN0ZWQgdHlwZVxuICAgICAqL1xuICAgIGdldFNlcnZpY2UodHlwZSA6IHN0cmluZykgOiBJdGVtU2VydmljZSB7XG4gICAgICAgIGlmKCF0aGlzLnN2Y0NhY2hlW3R5cGVdKVxuICAgICAgICAgICAgdGhpcy5zdmNDYWNoZVt0eXBlXSA9IHRoaXMuc2VydmljZUZhY3RvcnkodHlwZSwgQ29uZmlnLnVhbFVybCwgdGhpcy5odHRwQ2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ZjQ2FjaGVbdHlwZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZuIC0gY2FsbGJhY2sgd2hlbiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZFxuICAgICAqL1xuICAgIHNldEVycm9ySGFuZGxlcihmbikge1xuICAgICAgICB0aGlzLl9sYXllckVycm9ySGFuZGxlciA9IGZuO1xuICAgIH1cblxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldExheWVyU3RhdGVJbmRleCAobGF5ZXJJZCkge1xuICAgICAgICBpZighbGF5ZXJJZCkgcmV0dXJuIC0xO1xuICAgICAgICBmb3IobGV0IGk9MDsgaTx0aGlzLl9sYXllclN0YXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYodGhpcy5fbGF5ZXJTdGF0ZXNbaV0ubGF5ZXIgJiYgbGF5ZXJJZCA9PT0gdGhpcy5fbGF5ZXJTdGF0ZXNbaV0ubGF5ZXIuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLl9sYXllclN0YXRlcy5pbmRleE9mT2JqKGxheWVySWQsIChpZCwgc3RhdGUpID0+IHN0YXRlLmxheWVyLmlkID09PSBpZCApO1xuICAgIH1cblxuICAgIGdldExheWVyU3RhdGUgKGxheWVySWQpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRMYXllclN0YXRlSW5kZXgobGF5ZXJJZCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdGhpcy5fbGF5ZXJTdGF0ZXNbaW5kZXhdIDogbnVsbDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICBpbml0aWFsaXplTWFwRGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IEl0ZW1UeXBlcy5NQVAsXG4gICAgICAgICAgICB0aXRsZTogXCJNeSBOZXcgTWFwXCIsXG4gICAgICAgICAgICBsYWJlbDogXCJNeSBOZXcgTWFwXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGlzIG1hcCBuZWVkcyBhIGRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBjcmVhdGVkQnk6IG51bGwsXG4gICAgICAgICAgICBiYXNlTGF5ZXI6IHRoaXMuX2Jhc2VMYXllckRlZixcbiAgICAgICAgICAgIGxheWVyczogW10sXG4gICAgICAgICAgICBrZXl3b3JkczogW10sXG4gICAgICAgICAgICB0aGVtZXM6IFtdLFxuICAgICAgICAgICAgcmVzb3VyY2VUeXBlczogWydodHRwOi8vd3d3Lmdlb3BsYXRmb3JtLmdvdi9vbnQvb3Blbm1hcC9HZW9wbGF0Zm9ybU1hcCddXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEByZXR1cm4gb2JqZWN0IGRlZmluaXRpb24gb2YgdGhlIGN1cnJlbnQgbWFwIHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIFdNVlJcbiAgICAgKi9cbiAgICBnZXRNYXBSZXNvdXJjZUNvbnRlbnQobWV0YWRhdGEgPzogYW55KSB7XG5cbiAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YSB8fCB7fTtcblxuICAgICAgICAvL21hcCBsYXllcnNcbiAgICAgICAgbWV0YWRhdGEubGF5ZXJzID0gdGhpcy5fbGF5ZXJTdGF0ZXMuc2xpY2UoMCk7XG4gICAgICAgIC8vIC4uLiBVQUwgc2hvdWxkIHN1cHBvcnQgYWNjZXB0aW5nIGp1c3QgYW4gaWQgaGVyZSwgc28gd2UnbGwgZG8ganVzdCB0aGF0XG4gICAgICAgIG1ldGFkYXRhLmJhc2VMYXllciA9IHRoaXMuX2Jhc2VMYXllckRlZjtcblxuICAgICAgICBtZXRhZGF0YS5hbm5vdGF0aW9ucyA9IHRoaXMuX2ZlYXR1cmVMYXllciA/XG4gICAgICAgICAgICB7IHRpdGxlOiBcIk1hcCBGZWF0dXJlc1wiLCBnZW9KU09OOiB0aGlzLl9mZWF0dXJlTGF5ZXIudG9HZW9KU09OKCkgfSA6IG51bGw7XG5cbiAgICAgICAgLy9nZW9ncmFwaGljIGV4dGVudFxuICAgICAgICBsZXQgZXh0ZW50ID0gdGhpcy5fbWFwSW5zdGFuY2UuZ2V0Qm91bmRzKCk7XG4gICAgICAgIG1ldGFkYXRhLmV4dGVudCA9IHtcbiAgICAgICAgICAgIG1pbng6IGV4dGVudC5nZXRXZXN0KCksXG4gICAgICAgICAgICBtaW55OiBleHRlbnQuZ2V0U291dGgoKSxcbiAgICAgICAgICAgIG1heHg6IGV4dGVudC5nZXRFYXN0KCksXG4gICAgICAgICAgICBtYXh5OiBleHRlbnQuZ2V0Tm9ydGgoKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIExlYWZsZXQgdG9vbGJhclxuICAgICAqL1xuICAgIGdldERyYXdDb250cm9sVG9vbGJhcigpIHtcbiAgICAgICAgaWYoISh0aGlzLl9tYXBJbnN0YW5jZSBhcyBhbnkpLmRyYXdDb250cm9sKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHRvb2xiYXJzID0gKHRoaXMuX21hcEluc3RhbmNlIGFzIGFueSkuZHJhd0NvbnRyb2wuX3Rvb2xiYXJzO1xuICAgICAgICB2YXIgdG9vbGJhciA9IG51bGw7XG4gICAgICAgIGZvcih2YXIga2V5IGluIHRvb2xiYXJzKSB7XG4gICAgICAgICAgICBpZih0b29sYmFycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYodG9vbGJhcnNba2V5XS5fbW9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJhciA9IHRvb2xiYXJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9vbGJhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXJyb3IgTGVhZmxldCB0aWxlIGxvYWQgZXJyb3IgKC50YXJnZXQgaXMgbGF5ZXIsIC50aWxlIGlzIGltYWdlKVxuICAgICAqL1xuICAgIGhhbmRsZUxheWVyRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5oYW5kbGVMYXllckVycm9yKCkgLSBcIiArXG4gICAgICAgIC8vICAgICBcIkxheWVyJ3MgdGlsZSBmYWlsZWQgdG8gbG9hZDogXCIgKyBlcnJvci50aWxlLnNyYyk7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuYWJsZSB0byBmaW5kIGxheWVyIGluIGxheWVyIGNhY2hlLiBMYXllciBlcnJvciBpcyBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGF5ZXIgPSBlcnJvci50YXJnZXQ7XG4gICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5fbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgaWYodGhpcy5fbGF5ZXJDYWNoZVtpZF0gPT09IGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGF5ZXJFcnJvcihlcnJvciwgaWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBMZWFmbGV0IHRpbGUgbG9hZCBlcnJvciBhbmQgdGhlIHJlc3BvbnNpYmxlIGxheWVyIGlkLFxuICAgICAqIFRyeSB0byBpc29sYXRlIHRoZSBjYXVzZSBvZiB0aGUgZXJyb3IgdXNpbmcgdGhlIHByb3h5XG4gICAgICogYW5kIG5vdGlmeSBsaXN0ZW5lcnMgdGhhdCBhbiBlcnJvciBoYXMgb2NjdXJyZWRcbiAgICAgKi9cbiAgICBwcm9jZXNzTGF5ZXJFcnJvcihlcnJvciA6IEVycm9yLCBpZCA6IHN0cmluZykge1xuXG4gICAgICAgIHZhciBmaW5kZXIgPSAobCkgPT4geyByZXR1cm4gbC5pZCA9PT0gaWQgfHwgKGwubGF5ZXIgJiYgbC5sYXllci5pZCA9PT0gaWQpOyB9O1xuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckVycm9ycy5maW5kKGZpbmRlcikpIHtcblxuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMubG9nTGF5ZXJFcnJvcihpZCwgXCJMYXllciAoJ1wiICsgaWQgKyBcIicpIGZhaWxlZCB0byBjb21wbGV0ZWx5IGxvYWQuIFwiICtcbiAgICAgICAgICAgICAgICBcIkl0IG1heSBiZSBpbmFjY2Vzc2libGUgb3IgbWlzY29uZmlndXJlZC5cIik7XG5cbiAgICAgICAgICAgIHZhciB1cmwgPSAoZXJyb3IgYXMgYW55KS50aWxlLnNyYztcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7aWQ6aWR9O1xuICAgICAgICAgICAgdXJsLnN1YnN0cmluZyh1cmwuaW5kZXhPZihcIj9cIikrMSwgdXJsLmxlbmd0aCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwYXJhbS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgIHBhcmFtc1twWzBdXSA9IHBbMV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGV0IGxheWVyU2VydmljZSA9IHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTEFZRVIpO1xuICAgICAgICAgICAgaWYobGF5ZXJTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJTZXJ2aWNlLnZhbGlkYXRlKGlkLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gdGhpcy5fbGF5ZXJTdGF0ZXMuZmluZChmaW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZihkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5tZXNzYWdlID0gXCJMYXllciAnXCIgKyBkZWYubGF5ZXIubGFiZWwgKyBcIicgZmFpbGVkIHRvIGNvbXBsZXRlbHkgbG9hZC4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlJlcG9ydGVkIGNhdXNlOiBcIiArIGUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeSgnbGF5ZXI6ZXJyb3InLCBvYmopO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxheWVySWQgLSBpZGVudGlmaWVyIG9mIGxheWVyIGdlbmVyYXRpbmcgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIGVycm9yTXNnIC0gbWVzc2FnZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBsb2dMYXllckVycm9yKGxheWVySWQsIGVycm9yTXNnKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UubG9nTGF5ZXJFcnJvcigpIC0gbGF5ZXIgXCIgICsgaWQgK1xuICAgICAgICAvLyAgICAgXCIgZ2VuZXJhdGVkIGVycm9yICdcIiArIGVycm9yTXNnICsgXCInXCIpO1xuICAgICAgICBsZXQgZXJyID0geyBpZDogbGF5ZXJJZCwgbWVzc2FnZTogZXJyb3JNc2cgfTtcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICBpZih0aGlzLl9sYXllckVycm9ySGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJFcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIC8qIC0tIFN0YXRlIE1hbmFnZW1lbnQgb2YgaW50ZXJuYWwgbW9kZWwgLS0gKi9cblxuICAgIHRvdWNoIChldmVudCA/OiBhbnksIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmKGV2ZW50KSB7XG4gICAgICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5LmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoZXZlbnQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJEaXJ0eWluZyBtYXAgZm9yIFwiICsgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgY29uc29sZS5sb2coXCJEaXJ0eWluZyBtYXBcIik7XG4gICAgfVxuICAgIGNsZWFuKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkNsZWFuaW5nIG1hcFwiKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgTWFwIG1hbmlwdWxhdGlvbiBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgc2V0TWFwIChtYXAgOiBNYXApIHsgdGhpcy5fbWFwSW5zdGFuY2UgPSBtYXA7IH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gIG1hcCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldE1hcCAoKSA6IE1hcCB7IHJldHVybiB0aGlzLl9tYXBJbnN0YW5jZTsgfVxuXG4gICAgLyoqIEByZXR1cm4gZGVmaW5pdGlvbiBvZiBtYXAgKi9cbiAgICBnZXRNYXBEZWZpbml0aW9uICgpIDogYW55IHsgcmV0dXJuIHRoaXMuX21hcERlZjsgfVxuXG4gICAgLyoqIEByZXR1cm4gaWRlbnRpZmllciBvZiBtYXAgKi9cbiAgICBnZXRNYXBJZCAoKSA6IHN0cmluZyB7IHJldHVybiB0aGlzLl9tYXBJZDsgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbWFwIG9uIHRoZSBzcGVjaWZpZWQgbGF0L2xuZyBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIGxhdCBudW1iZXJcbiAgICAgKiBAcGFyYW0gbG5nIG51bWJlclxuICAgICAqIEBwYXJhbSB6b29tIG51bWJlciAob3B0aW9uYWwpXG4gICAgICovXG4gICAgc2V0VmlldyAobGF0IDogbnVtYmVyLCBsbmcgOiBudW1iZXIsIHpvb20gPzogbnVtYmVyKSB7XG4gICAgICAgIGxldCB6ID0gem9vbTtcbiAgICAgICAgaWYodHlwZW9mKHopID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHogPSB0aGlzLl9tYXBJbnN0YW5jZS5nZXRab29tKCk7XG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnNldFZpZXcoW2xhdCxsbmddLCB6KTtcbiAgICAgICAgdGhpcy50b3VjaCgnbWFwOnZpZXc6Y2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGNlbnRlciBvZiB0aGUgbWFwXG4gICAgICogQHJldHVybiBbbGF0LGxuZ11cbiAgICAgKi9cbiAgICBnZXRWaWV3ICgpIDogbnVtYmVyW10ge1xuICAgICAgICB2YXIgbGF0TG5nID0gdGhpcy5fbWFwSW5zdGFuY2UuZ2V0Q2VudGVyKCk7XG4gICAgICAgIHJldHVybiBbbGF0TG5nLmxhdCwgbGF0TG5nLmxuZ107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBpbnRlZ2VyIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwXG4gICAgICovXG4gICAgZ2V0Wm9vbSAoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBJbnN0YW5jZS5nZXRab29tKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0byB0aGUgbWFwJ3MgZGVmYXVsdCBleHRlbnRcbiAgICAgKiBJZiB0aGUgbWFwIGlzIHNhdmVkLCB0aGlzIHdpbGwgYmUgdGhlIHNhdmVkIHZpZXdwb3J0XG4gICAgICogb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIENPTlVTXG4gICAgICovXG4gICAgem9vbVRvRGVmYXVsdCAoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9tYXBJbnN0YW5jZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLl9kZWZhdWx0RXh0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoW1xuICAgICAgICAgICAgICAgIFt0aGlzLl9kZWZhdWx0RXh0ZW50Lm1pbnksIHRoaXMuX2RlZmF1bHRFeHRlbnQubWlueF0sXG4gICAgICAgICAgICAgICAgW3RoaXMuX2RlZmF1bHRFeHRlbnQubWF4eSwgdGhpcy5fZGVmYXVsdEV4dGVudC5tYXh4XVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLnpvb21Ub0RlZmF1bHQoKSAtIE5vIGRlZmF1bHQgZXh0ZW50IHNwZWNpZmllZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnNldFZpZXcoWzM4LCAtOTZdLCA1KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnbWFwOnZpZXc6Y2hhbmdlZCcpO1xuICAgICAgICB9IGNhdGNoKGUpIHsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBleHRlbnQgLSBlaXRoZXIgYSBHUCBleHRlbnQgb2JqZWN0IG9yIExlYWZsZXQgTGF0TG5nQm91bmRzIG9iamVjdFxuICAgICAqL1xuICAgIHNldEV4dGVudChleHRlbnQgOiBMYXRMbmdCb3VuZHN8YW55KSB7XG4gICAgICAgIGlmKCFleHRlbnQpIHJldHVybjtcbiAgICAgICAgaWYoIHR5cGVvZihleHRlbnQubWlueCkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YoZXh0ZW50Lm1pbnkpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mKGV4dGVudC5tYXh4KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZihleHRlbnQubWF4eSkgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgLy9HUCBtb2RlbCBleHRlbnRcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhbXG4gICAgICAgICAgICAgICAgW2V4dGVudC5taW55LCBleHRlbnQubWlueF0sXG4gICAgICAgICAgICAgICAgW2V4dGVudC5tYXh5LCBleHRlbnQubWF4eF1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYodHlwZW9mKGV4dGVudC5nZXRXZXN0KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vTC5MYXRMbmdCb3VuZHNcbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhleHRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgTGF5ZXIgb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxheWVyIExlYWZsZXQgTGF5ZXIgaW5zdGFuY2Ugb3Igb2JqZWN0IGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBzZXRCYXNlTGF5ZXIgKGxheWVyIDogYW55KSB7XG5cbiAgICAgICAgbGV0IHByb21pc2UgPSBudWxsO1xuICAgICAgICBpZighbGF5ZXIpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBEZWZhdWx0QmFzZUxheWVyLmdldCh0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLkxBWUVSKSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcHJvbWlzZSA9IFEucmVzb2x2ZShsYXllcik7XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKCBsYXllciA9PiB7XG5cbiAgICAgICAgICAgIGxldCBsZWFmbGV0TGF5ZXIgPSBMYXllckZhY3RvcnkuY3JlYXRlKGxheWVyKTtcbiAgICAgICAgICAgIGlmKCFsZWFmbGV0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmc6IE1hcEluc3RhbmNlIGNvdWxkIG5vdCBjcmVhdGUgYmFzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwibGF5ZXIgZm9yICdcIiArIGxheWVyLmlkICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuYWRkTGF5ZXIobGVhZmxldExheWVyKTtcblxuICAgICAgICAgICAgKGxlYWZsZXRMYXllciBhcyBhbnkpLnNldFpJbmRleCgwKTsgIC8vc2V0IGF0IGJvdHRvbVxuXG4gICAgICAgICAgICBsZXQgb2xkQmFzZUxheWVyID0gdGhpcy5fYmFzZUxheWVyO1xuICAgICAgICAgICAgaWYob2xkQmFzZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIob2xkQmFzZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9yZW1lbWJlciBuZXcgYmFzZSBsYXllclxuICAgICAgICAgICAgdGhpcy5fYmFzZUxheWVyID0gbGVhZmxldExheWVyO1xuICAgICAgICAgICAgdGhpcy5fYmFzZUxheWVyRGVmID0gbGF5ZXI7XG5cbiAgICAgICAgICAgIC8vd2lsbCBub3RpZnkgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdiYXNlbGF5ZXI6Y2hhbmdlZCcsIGxheWVyLCBsZWFmbGV0TGF5ZXIpO1xuICAgICAgICAgICAgLy8gdGhpcy5ub3RpZnkoJ2Jhc2VsYXllcjpjaGFuZ2VkJywgbGF5ZXIsIGxlYWZsZXRMYXllcik7XG5cbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE1hcEluc3RhbmNlLnNldEJhc2VMYXllcigpIC0gRXJyb3IgZ2V0dGluZyBiYXNlIGxheWVyIGZvciBtYXAgOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIHRoaXMubG9nTGF5ZXJFcnJvciggbGF5ZXIuaWQsIFwiRXJyb3Igc2V0dGluZyBiYXNlbGF5ZXIgb24gbWFwIFwiICtcbiAgICAgICAgICAgICAgICBcImJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcihzKTogXCIgKyBlLm1lc3NhZ2UgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBhcnJheSBvZiBiYXNlIGxheWVycyBkZWZpbml0aW9ucyB0aGF0IGNhbiBiZSB1c2VkXG4gICAgICovXG4gICAgLy8gZ2V0QmFzZUxheWVyT3B0aW9ucyAoKSB7XG4gICAgLy8gICAgIHJldHVybiB0aGlzLl9iYXNlTGF5ZXJPcHRpb25zO1xuICAgIC8vIH0sXG5cbiAgICBnZXRCYXNlTGF5ZXIgKCkgOiBhbnkgeyByZXR1cm4gdGhpcy5fYmFzZUxheWVyRGVmOyB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGxpc3Qgb2YgbGF5ZXIgc3RhdGVzIGNvbnRhaW5pbmcgbGF5ZXIgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBnZXRMYXllcnMgKCkgOiBhbnlbXSB7IHJldHVybiB0aGlzLl9sYXllclN0YXRlczsgfVxuXG4gICAgZ2V0TGF5ZXJFcnJvcnMgKCkgOiBhbnlbXSB7IHJldHVybiB0aGlzLl9sYXllckVycm9yczsgfVxuXG4gICAgY2xlYXJMYXllckVycm9ycyAoKSB7XG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMubm90aWZ5KCdsYXllcjplcnJvcicpO1xuICAgIH1cblxuICAgIGNsZWFyT3ZlcmxheXMgKCkge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICBmb3IodmFyIGk9dGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fbGF5ZXJTdGF0ZXNbaV07XG4gICAgICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbc3RhdGUubGF5ZXIuaWRdO1xuICAgICAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2Uub2ZmKFwibGF5ZXI6ZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZVtzdGF0ZS5sYXllci5pZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnJlbW92ZUxheWVyKGxheWVySW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gW107XG4gICAgICAgIHRoaXMudG91Y2goJ2xheWVyczpjaGFuZ2VkJyk7XG5cbiAgICAgICAgLy9UT0RPIHN0b3AgbGlzdGVuaW5nIGZvciBsYXllciBldmVudHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0gbGlzdCBvZiBsYXllcnMgKE5PVEU6IG5vdCB3cmFwcGVkIGJ5IGxheWVyIHN0YXRlcywgdGhpcyBtZXRob2QgYXBwbGllcyB0aGF0KVxuICAgICAqL1xuICAgIGFkZExheWVycyAobGF5ZXJzIDogYW55fGFueVtdICkge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBhdHRlbXB0aW5nIHRvIGFkZCBsYXllcnMgdG8gYW4gZW1wdHkgY2FjaGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBBdHRlbXB0aW5nIHRvIGFkZCBsYXllcnMgdG8gYSBtYXAgd2l0aCBubyBsYXllciBjYWNoZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFsYXllcnMpIHJldHVybjtcbiAgICAgICAgaWYodHlwZW9mKGxheWVycy5wdXNoKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxheWVycyA9IFtsYXllcnNdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5ZXJzLmZvckVhY2goIChvYmosaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgbGV0IGxheWVyID0gbnVsbCwgc3RhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZihvYmoudHlwZSAmJiBvYmoudHlwZT09PUl0ZW1UeXBlcy5MQVlFUikgeyAvL2lzIGEgbGF5ZXJcbiAgICAgICAgICAgICAgICBsYXllciA9IG9iajtcbiAgICAgICAgICAgIH0gZWxzZSBpZihvYmoubGF5ZXIpIHsgIC8vaXMgbGF5ZXIgc3RhdGVcbiAgICAgICAgICAgICAgICBsYXllciA9IG9iai5sYXllcjsgIC8vIGNvbnRhaW5pbmcgYSBsYXllclxuICAgICAgICAgICAgICAgIHN0YXRlID0gb2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmFkZExheWVycygpIC0gbGF5ZXIgKFwiICsgaW5kZXggK1xuICAgICAgICAgICAgICAgICAgICBcIikgaXMgbm90IGEgTGF5ZXIgb3IgYSBMYXllciBzdGF0ZS4gSWdub3JpbmcuLi5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgLy9sYXllciBpbmZvIGlzIG1pc3NpbmcsIHNraXAgaXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9EVC00NDIgcHJldmVudCBhZGRpbmcgbGF5ZXIgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiBtYXBcbiAgICAgICAgICAgIGlmKHRoaXMuX2xheWVyQ2FjaGVbbGF5ZXIuaWRdKSByZXR1cm47XG5cbiAgICAgICAgICAgIGlmKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd3JhcHBlZCBpbiB0cnl7fWNhdGNoIGJlY2F1c2UgbGF5ZXIgbWF5IGNvbnRhaW4gY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgZXJyb3Igd2hlbiB1c2VkIGJ5IEpTT04gbWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5ZXJDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsYXllcikpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IGxheWVyQ29weVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYWRkIGxheWVyIHRvIG1hcCBiZWNhdXNlIG9mIFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB6ID0gbGF5ZXJzLmxlbmd0aCAtIGluZGV4O1xuICAgICAgICAgICAgc3RhdGUuekluZGV4ID0gejtcblxuICAgICAgICAgICAgdGhpcy5hZGRMYXllcldpdGhTdGF0ZShsYXllciwgc3RhdGUpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudG91Y2goJ2xheWVyczpjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxheWVyIC0gR2VvUGxhdGZvcm0gTGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBHZW9QbGF0Zm9ybSBMYXllciBTdGF0ZVxuICAgICAqL1xuICAgIGFkZExheWVyV2l0aFN0YXRlKGxheWVyLCBzdGF0ZSkge1xuXG4gICAgICAgIHZhciBsZWFmbGV0TGF5ZXIgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYoIWxheWVyIHx8ICFzdGF0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50LCBtaXNzaW5nIGxheWVyIGFuZCBvciBzdGF0ZVwiKTtcblxuICAgICAgICAgICAgbGVhZmxldExheWVyID0gTGF5ZXJGYWN0b3J5LmNyZWF0ZShsYXllcik7XG4gICAgICAgICAgICBpZighbGVhZmxldExheWVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNyZWF0ZSBsZWFmbGV0IGxheWVyIGZvciBHUCBMYXllciAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBsYXllci5pZCArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nTGF5ZXJFcnJvciggbGF5ZXIuaWQsXG4gICAgICAgICAgICAgICAgXCJMYXllciAnXCIgKyBsYXllci5sYWJlbCArIFwiJyBjb3VsZCBub3QgYmUgYWRkZWQgdG8gdGhlIFwiICtcbiAgICAgICAgICAgICAgICBcIm1hcCBpbnN0YW5jZTsgXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWxlYWZsZXRMYXllcikgcmV0dXJuO1xuXG4gICAgICAgIC8vY2FjaGUgbGVhZmxldCBvYmplY3QgZmlyc3RcbiAgICAgICAgaWYodGhpcy5fbGF5ZXJDYWNoZSkgdGhpcy5fbGF5ZXJDYWNoZVtsYXllci5pZF0gPSBsZWFmbGV0TGF5ZXI7XG5cbiAgICAgICAgLy9saXN0ZW4gZm9yIGxheWVyIGVycm9ycyBzbyB3ZSBjYW4gaW5mb3JtIHRoZSB1c2VyXG4gICAgICAgIC8vIHRoYXQgYSBsYXllciBoYXNuJ3QgYmVlbiBsb2FkZWQgaW4gYSB1c2VmdWwgd2F5XG4gICAgICAgIGxlYWZsZXRMYXllci5vbigndGlsZWVycm9yJywgKGUpID0+IHsgdGhpcy5oYW5kbGVMYXllckVycm9yKGUpOyB9KTtcblxuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5hZGRMYXllcihsZWFmbGV0TGF5ZXIpO1xuXG4gICAgICAgIGlmKCAhaXNOYU4oc3RhdGUuekluZGV4KSAmJiBsZWFmbGV0TGF5ZXIuc2V0WkluZGV4IClcbiAgICAgICAgICAgIGxlYWZsZXRMYXllci5zZXRaSW5kZXgoc3RhdGUuekluZGV4KTtcblxuICAgICAgICB0aGlzLl9sYXllclN0YXRlcy5wdXNoKHN0YXRlKTtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnbGF5ZXI6YWRkZWQnLCBsYXllciwgbGVhZmxldExheWVyKTtcblxuXG4gICAgICAgIC8vIGlmIGxheWVyIGlzIGluaXRpYWxseSBcIm9mZlwiIG9yLi4uXG4gICAgICAgIC8vIGlmIGxheWVyIGlzIGluaXRpYWxseSBub3QgMTAwJSBvcGFxdWVcbiAgICAgICAgaWYoIXN0YXRlLnZpc2liaWxpdHkgfHwgc3RhdGUub3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgbGF5ZXIgdmlzaWJpbGl0eSBhbmQgb3BhY2l0eSBhc3luYywgb3IgZWxzZVxuICAgICAgICAgICAgLy8gc29tZSBvZiB0aGUgbGF5ZXJzIHdvbid0IGdldCBwcm9wZXJseSBpbml0aWFsaXplZFxuICAgICAgICAgICAgc2V0VGltZW91dCggKGxheWVyLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF5ZXJWaXNpYmlsaXR5KGxheWVyLCBzdGF0ZS52aXNpYmlsaXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExheWVyT3BhY2l0eShsYXllciwgc3RhdGUub3BhY2l0eSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPIG5vdGlmeSBvZiBjaGFuZ2VcblxuICAgICAgICAgICAgICAgIC8vRFQtMjEwMiB0aW1lb3V0IG5lZWRzIHRvIGJlIGxhcmdlIGVub3VnaCBvciBlbHNlXG4gICAgICAgICAgICAgICAgLy8gZmVhdHVyZSBsYXllcnMgd29uJ3QgZ2V0IG9wYWNpdHkgdXBkYXRlZCBvbiBtYXAgbG9hZFxuICAgICAgICAgICAgfSwgMjAwMCwgbGVhZmxldExheWVyLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZnJvbSAtIHBvc2l0aW9uIG9mIGxheWVyIGJlaW5nIG1vdmVkXG4gICAgICogQHBhcmFtIHRvIC0gZGVzaXJlZCBwb3NpdGlvbiB0byBtb3ZlIGxheWVyIHRvXG4gICAgICovXG4gICAgbW92ZUxheWVyIChmcm9tIDogbnVtYmVyLCB0byA6IG51bWJlcikge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG5cbiAgICAgICAgaWYoaXNOYU4oZnJvbSkpIHJldHVybjtcblxuICAgICAgICAvL2VuZCBvZiBsaXN0XG4gICAgICAgIGlmKGlzTmFOKHRvKSkgdG8gPSB0aGlzLl9sYXllclN0YXRlcy5sZW5ndGgtMTtcblxuICAgICAgICBsZXQgY29weSA9IHRoaXMuX2xheWVyU3RhdGVzLnNwbGljZShmcm9tLCAxKVswXTsgICAgLy9ncmFiIGxheWVyIGJlaW5nIG1vdmVkXG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzLnNwbGljZSh0bywgMCwgY29weSk7XG5cbiAgICAgICAgZm9yKGxldCB6PTEsIGk9dGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoLTE7IGk+PTA7IC0taSwrK3opIHtcbiAgICAgICAgICAgIGxldCBsYXllclN0YXRlID0gdGhpcy5fbGF5ZXJTdGF0ZXNbaV07XG4gICAgICAgICAgICBsZXQgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbIGxheWVyU3RhdGUubGF5ZXIuaWQgXTtcbiAgICAgICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLnNldFpJbmRleCh6KTtcbiAgICAgICAgICAgICAgICBsYXllclN0YXRlLnpJbmRleCA9IHo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoKCdsYXllcnM6Y2hhbmdlZCcsIHRoaXMuZ2V0TGF5ZXJzKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlTGF5ZXIgKGlkKSB7XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW2lkXTtcbiAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBsYXllciBmcm9tIHRyYWNrZWQgZGVmcyBhcnJheVxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRMYXllclN0YXRlSW5kZXgoaWQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5yZW1vdmVMYXllcihcIiArIGlkICsgXCIpXCIpO1xuICAgICAgICAgICAgaWYoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclN0YXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAvL3N0b3AgbGlzdGVuaW5nIGZvciBlcnJvcnNcbiAgICAgICAgICAgIGxheWVySW5zdGFuY2Uub2ZmKFwibGF5ZXI6ZXJyb3JcIik7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGxheWVyIGZyb20gbWFwXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihsYXllckluc3RhbmNlKTtcblxuICAgICAgICAgICAgLy9yZW1vdmUgbGF5ZXIgZnJvbSBjYWNoZVxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZVtpZF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2goJ2xheWVyczpjaGFuZ2VkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVMYXllclZpc2liaWxpdHkgKGlkKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtpZF07XG4gICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZShpZCk7XG4gICAgICAgICAgICBzdGF0ZS52aXNpYmlsaXR5ID0gIXN0YXRlLnZpc2liaWxpdHk7XG5cbiAgICAgICAgICAgIGlmKGxheWVySW5zdGFuY2UuX2N1cnJlbnRJbWFnZSkge1xuICAgICAgICAgICAgICAgIC8vRVNSSSBJbWFnZSBTZXJ2aWNlIGxheWVycyBoYXZlIGFuIElNRyBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBnZXRzIG1vZGlmaWVkIGFuZCByZXBsYWNlZCBldmVyeSBtYXAgZXZlbnQgKHpvb20vcGFuKVxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbid0IGp1c3QgdG9nZ2xlIGNsYXNzZXMgbGlrZSBvbiBvdGhlciBsYXllcnMuXG4gICAgICAgICAgICAgICAgLy9JbnN0ZWFkLCB3ZSBuZWVkIHRvIHVzZSB0aGUgRVNSSSBzZXRPcGFjaXR5IG1ldGhvZCB0byB0b2dnbGVcbiAgICAgICAgICAgICAgICAvLyBidXQgbmVlZCB0byB1cGRhdGUgbGF5ZXIgc3RhdGUgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLnNldE9wYWNpdHkoc3RhdGUudmlzaWJpbGl0eSA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGFjaXR5ID0gbGF5ZXJJbnN0YW5jZS5nZXRPcGFjaXR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldExheWVyVmlzaWJpbGl0eShsYXllckluc3RhbmNlLCBzdGF0ZS52aXNpYmlsaXR5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGU6IHRoaXMgZG9lcyBub3QgdXBkYXRlIGxheWVyIGRlZmluaXRpb24gc3RhdGUuIFVzZVxuICAgICAqIE1hcEluc3RhbmNlLnRvZ2dsZUxheWVyVmlzaWJpbGl0eSB0byBkbyB0aGF0IGFuZCBhZGp1c3RcbiAgICAgKiByZW5kZXJlZCBsYXllcidzIHZpc2liaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXJJbnN0YW5jZSAtIGxlYWZsZXQgbGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIGZsYWcgaW5kaWNhdGluZyB2aXNpYmlsaXR5IG9mIGxheWVyXG4gICAgICovXG4gICAgc2V0TGF5ZXJWaXNpYmlsaXR5IChsYXllckluc3RhbmNlIDogTGF5ZXIsIHZpc2libGUgOiBib29sZWFuKSB7XG5cbiAgICAgICAgaWYoKGxheWVySW5zdGFuY2UgYXMgYW55KS5zZXRWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgICAvL3VzaW5nIGN1c3RvbSBtZXRob2QgcHJvdmlkZWQgaW4gc3JjL2xheWVyL21vZHVsZS5qc1xuICAgICAgICAgICAgKGxheWVySW5zdGFuY2UgYXMgYW55KS5zZXRWaXNpYmlsaXR5KHZpc2libGUpO1xuXG4gICAgICAgIH0gZWxzZSBpZigobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCB1c2luZyBqcXVlcnkgb24gZG9tIGRpcmVjdGx5XG4gICAgICAgICAgICBsZXQgZWwgPSBqUXVlcnkoKGxheWVySW5zdGFuY2UgYXMgYW55KS5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIGlmKHZpc2libGUpIGVsLnJlbW92ZUNsYXNzKFwiaW52aXNpYmxlXCIpO1xuICAgICAgICAgICAgLy8gZWxzZSBlbC5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgICAgICAgICBlbC5jc3MoeydkaXNwbGF5JzogdmlzaWJsZSA/ICcnIDogJ25vbmUnfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoKCdtYXA6bGF5ZXI6Y2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTGF5ZXJPcGFjaXR5IChpZCA6IHN0cmluZywgb3BhY2l0eSA6IG51bWJlcikge1xuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtpZF07XG5cbiAgICAgICAgLy9pZiBsYXllciBpZCBpcyBmb3IgYmFzZSBsYXllci4uLlxuICAgICAgICBpZighbGF5ZXJJbnN0YW5jZSAmJiB0aGlzLl9iYXNlTGF5ZXJEZWYuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICBsYXllckluc3RhbmNlID0gdGhpcy5fYmFzZUxheWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hZGp1c3QgcmVuZGVyZWQgbGVhZmxldCBsYXllclxuICAgICAgICBvcGFjaXR5ID0gdGhpcy5zZXRMYXllck9wYWNpdHkobGF5ZXJJbnN0YW5jZSwgb3BhY2l0eSk7XG5cbiAgICAgICAgLy8gaWYgb3ZlcmxheSBsYXllciwgdXBkYXRlIHN0YXRlIHZhbHVlXG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZShpZCk7XG4gICAgICAgIGlmKHN0YXRlKSBzdGF0ZS5vcGFjaXR5ID0gb3BhY2l0eTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGRvZXMgbm90IHVwZGF0ZSB0aGUgYXNzb2NpYXRlZCBMYXllciBEZWZpbml0aW9uXG4gICAgICogc3RhdGUgdmFsdWUgZm9yIG9wYWNpdHkuIFVzZSBNYXBJbnN0YW5jZS51cGRhdGVMYXllck9wYWNpdHkoKSB0b1xuICAgICAqIGJvdGggdXBkYXRlIHN0YXRlIGFuZCBhZGp1c3QgcmVuZGVyZWQgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF5ZXJJbnN0YW5jZSAtIGxlYWZsZXQgbGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gb3BhY2l0eSAtIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4wIG9yIDAgYW5kIDEwMFxuICAgICAqIEByZXR1cm4gbm9ybWFsaXplZCBvcGFjaXR5IHZhbHVlIGJldHdlZW4gMCBhbmQgMS4wXG4gICAgICovXG4gICAgc2V0TGF5ZXJPcGFjaXR5IChsYXllckluc3RhbmNlIDogTGF5ZXIsIG9wYWNpdHkgOiBudW1iZXIpIDogbnVtYmVyIHtcbiAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSAmJiAobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLnNldE9wYWNpdHkpIHtcbiAgICAgICAgICAgIGlmKG9wYWNpdHkgPiAxLjApIG9wYWNpdHkgPSBvcGFjaXR5IC8gMTAwLjA7XG4gICAgICAgICAgICAobGF5ZXJJbnN0YW5jZSBhcyBhbnkpLnNldE9wYWNpdHkob3BhY2l0eSk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKCdtYXA6bGF5ZXI6Y2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGFjaXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBHZW9QbGF0Zm9ybSBMYXllciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4gTGVhZmxldCBsYXllciBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhhdCBsYXllciBvciBudWxsXG4gICAgICovXG4gICAgZ2V0TGVhZmxldExheWVyRm9yIChncExheWVyIDogYW55KSA6IExheWVyIHtcbiAgICAgICAgaWYoIWdwTGF5ZXIgfHwgIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGVhZmxldExheWVyID0gdGhpcy5fbGF5ZXJDYWNoZVtncExheWVyLmlkXTtcbiAgICAgICAgcmV0dXJuIGxlYWZsZXRMYXllciB8fCBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlR2V0RmVhdHVyZUluZm8gKGxheWVySWQgOiBzdHJpbmcpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW2xheWVySWRdO1xuICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZih0eXBlb2YobGF5ZXJJbnN0YW5jZS5lbmFibGVHZXRGZWF0dXJlSW5mbykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYobGF5ZXJJbnN0YW5jZS5pc0dldEZlYXR1cmVJbmZvRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySW5zdGFuY2UuZGlzYWJsZUdldEZlYXR1cmVJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSgodGhpcy5fbWFwSW5zdGFuY2UgYXMgYW55KS5fY29udGFpbmVyKS5yZW1vdmVDbGFzcygnc2VsZWN0YWJsZS1jdXJzb3InKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLmVuYWJsZUdldEZlYXR1cmVJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSgodGhpcy5fbWFwSW5zdGFuY2UgYXMgYW55KS5fY29udGFpbmVyKS5hZGRDbGFzcygnc2VsZWN0YWJsZS1jdXJzb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgIEZlYXR1cmUgb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBhcnJheSBvZiBmZWF0dXJlcyBvbiB0aGUgbWFwXG4gICAgICovXG4gICAgZ2V0RmVhdHVyZXMgKCkgOiBhbnlbXSB7XG4gICAgICAgIGlmKHRoaXMuX2ZlYXR1cmVMYXllcikge1xuICAgICAgICAgICAgbGV0IGdlb2pzb24gPSB0aGlzLl9mZWF0dXJlTGF5ZXIudG9HZW9KU09OKCk7XG4gICAgICAgICAgICByZXR1cm4gKGdlb2pzb24gYXMgYW55KS5mZWF0dXJlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGpzb24gZ2VvanNvbiBvYmplY3Qgb3IgYXJyYXkgb2YgZ2VvanNvbiBvYmplY3RzXG4gICAgICovXG4gICAgYWRkRmVhdHVyZXMgKGpzb24gOiBhbnkpIHtcblxuICAgICAgICBpZighanNvbikgcmV0dXJuO1xuXG4gICAgICAgIGlmKHR5cGVvZihqc29uLnB1c2gpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy9hcnJheSBvZiBmZWF0dXJlc1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8anNvbi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoanNvbltpXSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnZmVhdHVyZXM6Y2hhbmdlZCcpO1xuXG4gICAgICAgIH0gZWxzZSBpZihqc29uLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVzKGpzb24uZmVhdHVyZXMpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vc2luZ2xlIGZlYXR1cmVcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZShqc29uLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGpzb24gZ2VvanNvbiBvYmplY3RcbiAgICAgKi9cbiAgICBhZGRGZWF0dXJlIChqc29uIDogYW55LCBmaXJlRXZlbnQgPzogYm9vbGVhbikge1xuICAgICAgICAvLyB2YXIgdHlwZSA9IGpzb24udHlwZTtcbiAgICAgICAgLy8gdmFyIGNvb3JkaW5hdGVzID0ganNvbi5jb29yZGluYXRlcztcblxuICAgICAgICBpZighdGhpcy5fZmVhdHVyZUxheWVyKSB7XG5cbiAgICAgICAgICAgIC8vIF9mZWF0dXJlTGF5ZXIgPSBnZW9KU09OKFtdLCBfZ2VvSnNvbkxheWVyT3B0cykuYWRkVG8oX21hcEluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllciA9IGZlYXR1cmVHcm91cCgpLmFkZFRvKHRoaXMuX21hcEluc3RhbmNlKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gX2ZlYXR1cmVMYXllci5hZGREYXRhKGpzb24pO1xuICAgICAgICB2YXIgb3B0cyA9IGpRdWVyeS5leHRlbmQoe30sIHRoaXMuX2dlb0pzb25MYXllck9wdHMpO1xuICAgICAgICBnZW9KU09OKGpzb24sIG9wdHMpLmVhY2hMYXllcigobCk9PnRoaXMuYWRkRmVhdHVyZUxheWVyKGwpKTtcblxuICAgICAgICBpZih0eXBlb2YoZmlyZUV2ZW50KSA9PT0gJ3VuZGVmaW5lZCcgfHwgZmlyZUV2ZW50ID09PSB0cnVlKVxuICAgICAgICAgICAgdGhpcy50b3VjaCgnZmVhdHVyZXM6Y2hhbmdlZCcpO1xuICAgICAgICBlbHNlIHRoaXMudG91Y2goKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShfZmVhdHVyZUxheWVyLnRvR2VvSlNPTigpKSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUpzb24gb2JqZWN0IGRlZmluaW5nIGEgR2VvSlNPTiBmZWF0dXJlXG4gICAgICovXG4gICAgdXBkYXRlRmVhdHVyZSAoZmVhdHVyZUpzb24gOiBhbnkpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRGZWF0dXJlTGF5ZXIoZmVhdHVyZUpzb24ucHJvcGVydGllcy5pZCk7XG4gICAgICAgIGlmKGxheWVyKSB7XG5cbiAgICAgICAgICAgIChsYXllciBhcyBhbnkpLmZlYXR1cmUgPSBmZWF0dXJlSnNvbjtcblxuICAgICAgICAgICAgLy91cGRhdGUgc3R5bGVcbiAgICAgICAgICAgIGxheWVyLnNldFN0eWxlKGZlYXR1cmVKc29uLnByb3BlcnRpZXMuc3R5bGUpO1xuXG4gICAgICAgICAgICAvL3JlYmluZCBsYWJlbCBpbiBjYXNlIHRoYXQgY2hhbmdlZFxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZmVhdHVyZUpzb24ucHJvcGVydGllcy5sYWJlbCB8fFxuICAgICAgICAgICAgICAgIFwiVW50aXRsZWQgXCIgKyBmZWF0dXJlSnNvbi5nZW9tZXRyeS50eXBlICsgXCIgRmVhdHVyZVwiO1xuICAgICAgICAgICAgbGF5ZXIuYmluZFRvb2x0aXAobGFiZWwpO1xuXG4gICAgICAgICAgICAvLyBsYXllci5yZWRyYXcoKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goXCJtYXA6ZmVhdHVyZTpjaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhbiBleGlzdGluZyBMLlBhdGgtYmFzZWQgbGF5ZXIgd2l0aCBvbmUgdXNpbmdcbiAgICAgKiB0aGUgc3VwcGxpZWQgRmVhdHVyZSBHZW9KU09OIG9iamVjdC4gIFJlbW92ZXMgdGhlIGV4aXN0aW5nXG4gICAgICogbGF5ZXIgYW5kIGFkZHMgYSBuZXcgb25lIGNyZWF0ZWQgZnJvbSB0aGUgR2VvSlNPTi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmZWF0dXJlSnNvbiBvYmplY3QgZGVmaW5pbmcgR2VvSlNPTiBmZWF0dXJlXG4gICAgICovXG4gICAgcmVwbGFjZUZlYXR1cmUgKGZlYXR1cmVKc29uIDogYW55KSB7XG5cbiAgICAgICAgLy9maW5kIGV4aXN0aW5nIGxheWVyIGZvciB0aGlzIGZlYXR1cmVcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRGZWF0dXJlTGF5ZXIoZmVhdHVyZUpzb24ucHJvcGVydGllcy5pZCk7XG4gICAgICAgIGlmKGxheWVyKSB7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXG4gICAgICAgICAgICAvL2FkZCByZXBsYWNlbWVudFxuICAgICAgICAgICAgZ2VvSlNPTihmZWF0dXJlSnNvbiwgdGhpcy5fZ2VvSnNvbkxheWVyT3B0cylcbiAgICAgICAgICAgICAgICAuZWFjaExheWVyKChsKT0+dGhpcy5hZGRGZWF0dXJlTGF5ZXIobCkpO1xuXG4gICAgICAgICAgICB0aGlzLnRvdWNoKFwibWFwOmZlYXR1cmU6Y2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmZWF0dXJlSWQgaWRlbnRpZmllciBvZiBmZWF0dXJlIHRvIGZvY3VzIHRoZSBtYXAgb25cbiAgICAgKi9cbiAgICBmb2N1c0ZlYXR1cmUgKGZlYXR1cmVJZCA6IHN0cmluZykge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldEZlYXR1cmVMYXllcihmZWF0dXJlSWQpO1xuICAgICAgICBpZihsYXllcikge1xuICAgICAgICAgICAgaWYoIHR5cGVvZihsYXllci5nZXRCb3VuZHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBleHRlbnQgPSBsYXllci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoZXh0ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YoIChsYXllciBhcyBhbnkpLmdldExhdExuZykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhdExuZyA9IChsYXllciBhcyBhbnkpLmdldExhdExuZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnBhblRvKGxhdExuZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UuZm9jdXNGZWF0dXJlKCkgLSBDYW5ub3QgZm9jdXMgZmVhdHVyZSBiZWNhdXNlIGl0IGhhcyBubyBib3VuZHMgb3IgbGF0L2xuZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UuZm9jdXNGZWF0dXJlKCkgLSBDYW5ub3QgZm9jdXMgZmVhdHVyZSBiZWNhdXNlIGl0IGhhcyBubyBsYXllclwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmZWF0dXJlSWQgOiBzdHJpbmdcbiAgICAgKi9cbiAgICByZW1vdmVGZWF0dXJlIChmZWF0dXJlSWQpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRGZWF0dXJlTGF5ZXIoZmVhdHVyZUlkKTtcbiAgICAgICAgaWYobGF5ZXIgJiYgdGhpcy5fZmVhdHVyZUxheWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnZmVhdHVyZXM6Y2hhbmdlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVGZWF0dXJlcyAoKSB7XG4gICAgICAgIGlmKHRoaXMuX2ZlYXR1cmVMYXllcikge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKFwiZmVhdHVyZXM6Y2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0RmVhdHVyZUxheWVyICggZmVhdHVyZUlkID86IHN0cmluZyApIDogRmVhdHVyZUdyb3VwIHtcbiAgICAgICAgLy9pZiBubyBmZWF0dXJlIHdhcyBzcGVjaWZpZWQsIHJldHVybiByb290IGZlYXR1cmUgbGF5ZXJcbiAgICAgICAgaWYoIWZlYXR1cmVJZCkgcmV0dXJuIHRoaXMuX2ZlYXR1cmVMYXllcjtcblxuICAgICAgICAvL290aGVyd2lzZSwgZmluZCBmZWF0dXJlLi4uXG4gICAgICAgIGlmKCF0aGlzLl9mZWF0dXJlTGF5ZXIpIHJldHVybiBudWxsO1xuICAgICAgICBcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5fZmVhdHVyZUxheWVyLmdldExheWVycygpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxmZWF0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYoIChmZWF0dXJlc1tpXSBhcyBhbnkpLmZlYXR1cmUgJiZcbiAgICAgICAgICAgICAgICAoZmVhdHVyZXNbaV0gYXMgYW55KS5mZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IGZlYXR1cmVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmVhdHVyZXNbaV0gYXMgYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0b2dnbGVGZWF0dXJlc0xheWVyICgpIHtcbiAgICAgICAgaWYoIXRoaXMuX2ZlYXR1cmVMYXllcikgcmV0dXJuIGZhbHNlOyAgICAvL2lnbm9yZSBpZiBub3QgcmVuZGVyZWQgeWV0XG5cbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSA9ICF0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlO1xuICAgICAgICB0aGlzLnNldEZlYXR1cmVMYXllclZpc2liaWxpdHkodGhpcy5fZmVhdHVyZUxheWVyLCB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICBmZWF0dXJlIC0gTGVhZmxldCBmZWF0dXJlIGluc3RhbmNlXG4gICAgICogQHBhcmFtICB2aXNpYmlsaXR5IC0gZmxhZ1xuICAgICAqL1xuICAgIHNldEZlYXR1cmVWaXNpYmlsaXR5IChmZWF0dXJlLCB2aXNpYmlsaXR5IDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLnNldEZlYXR1cmVMYXllclZpc2liaWxpdHkoZmVhdHVyZSwgdmlzaWJpbGl0eSk7XG4gICAgfVxuXG4gICAgZ2V0RmVhdHVyZXNMYXllclZpc2liaWxpdHkgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZTtcbiAgICB9XG5cblxuICAgIC8qXG4gICAgICogbWV0aG9kIGZvciBhZGRpbmcgZmVhdHVyZSBsYXllcnMgdG8gdGhlIG1hcFxuICAgICAqIHdoZW4gdGhlc2UgbGF5ZXJzIG1heSBiZSBsYXllciBncm91cHMuXG4gICAgICogZmluZHMgbGVhZiBub2RlIGxheWVycyBhbmQgYWRkcyB0aGVtIHRvIHRoZVxuICAgICAqIG1hcCdzIGZlYXR1cmUgZ3JvdXBcbiAgICAgKi9cbiAgICBhZGRGZWF0dXJlTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgdGhpcy5fYWRkRmVhdHVyZUxheWVyKGxheWVyKTtcbiAgICAgICAgdGhpcy50b3VjaChcImZlYXR1cmVzOmNoYW5nZWRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kLCB1c2UgJ2FkZEZlYXR1cmVMYXllcicgaW5zdGVhZFxuICAgICAqIEBwYXJhbSBsYXllclxuICAgICAqL1xuICAgIF9hZGRGZWF0dXJlTGF5ZXIobGF5ZXIgOiBMYXllcikge1xuICAgICAgICBpZighKGxheWVyIGFzIGFueSkuZmVhdHVyZSAmJiBsYXllciBpbnN0YW5jZW9mIExheWVyR3JvdXApIHtcbiAgICAgICAgICAgIGxheWVyLmVhY2hMYXllciggKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRmVhdHVyZUxheWVyKGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLmFkZExheWVyKGxheWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy90b2dnbGUgdmlzaWJpbGl0eSBvZiBwYXJlbnQgZmVhdHVyZSBsYXllclxuICAgIHNldEZlYXR1cmVMYXllclZpc2liaWxpdHkobGF5ZXIsIHZpc2liaWxpdHkpIHtcbiAgICAgICAgaWYoIWxheWVyKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSB2aXNpYmlsaXR5O1xuXG4gICAgICAgIGlmKGxheWVyLmdldExheWVycykge1xuICAgICAgICAgICAgbGF5ZXIuZ2V0TGF5ZXJzKCkuZm9yRWFjaCggKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KGNoaWxkLCB2aXNpYmlsaXR5KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gbGF5ZXIuX2NvbnRhaW5lciB8fCBsYXllci5fcGF0aDtcbiAgICAgICAgICAgIGlmKGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9IHZpc2liaWxpdHkgPyAnJyA6ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgTWFwIGxpZmVjeWNsZSBvcGVyYXRpb25zXG4gICAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAgICogQHJldHVybiByZXNvbHZpbmcgcGVyc2lzdGVkIG1hcFxuICAgICAqL1xuICAgIHNhdmUgKG1ldGFkYXRhIDogYW55KSA6IFByb21pc2U8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVNYXAobWV0YWRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZCBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciBtYXBcbiAgICAgKi9cbiAgICBzYXZlTWFwIChtZCA6IGFueSkgOiBQcm9taXNlPGFueT4ge1xuXG4gICAgICAgIGxldCBtZXRhZGF0YSA9IG1kIHx8IHt9O1xuXG4gICAgICAgIC8vYWRkIEdlb1BsYXRmb3JtTWFwIHJlc291cmNlIHR5cGUgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICBjb25zdCBncE1hcFR5cGUgPSAnaHR0cDovL3d3dy5nZW9wbGF0Zm9ybS5nb3Yvb250L29wZW5tYXAvR2VvcGxhdGZvcm1NYXAnO1xuICAgICAgICBtZXRhZGF0YS5yZXNvdXJjZVR5cGVzID0gbWV0YWRhdGEucmVzb3VyY2VUeXBlcyB8fCBbXTtcbiAgICAgICAgaWYobWV0YWRhdGEucmVzb3VyY2VUeXBlcy5pbmRleE9mKGdwTWFwVHlwZSkgPCAwKVxuICAgICAgICAgICAgbWV0YWRhdGEucmVzb3VyY2VUeXBlcy5wdXNoKGdwTWFwVHlwZSk7XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldE1hcFJlc291cmNlQ29udGVudChtZXRhZGF0YSk7XG5cbiAgICAgICAgLy9lbnN1cmUgdGhlIHR3byBuYW1lIHByb3BlcnRpZXMgbGluZSB1cFxuICAgICAgICBpZihjb250ZW50LnRpdGxlICYmIGNvbnRlbnQudGl0bGUgIT09IGNvbnRlbnQubGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnQubGFiZWwgPSBjb250ZW50LnRpdGxlO1xuICAgICAgICB9IGVsc2UgaWYoY29udGVudC5sYWJlbCAmJiAhY29udGVudC50aXRsZSkge1xuICAgICAgICAgICAgY29udGVudC50aXRsZSA9IGNvbnRlbnQubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlVwZGF0aW5nOiBcIiArIEpTT04uc3RyaW5naWZ5KG1hcCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5NQVApXG4gICAgICAgIC5zYXZlKGNvbnRlbnQpXG4gICAgICAgIC50aGVuKCByZXN1bHQgPT4ge1xuXG4gICAgICAgICAgICAvL3RyYWNrIG5ldyBtYXAncyBpbmZvIHNvIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCBuZXh0IHNhdmVcbiAgICAgICAgICAgIGlmKCF0aGlzLl9tYXBJZClcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJZCA9IHJlc3VsdC5pZDtcblxuICAgICAgICAgICAgdGhpcy5fbWFwRGVmID0gcmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEV4dGVudCA9IHJlc3VsdC5leHRlbnQ7XG4gICAgICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyPT57XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcENvcmUgTWFwSW5zdGFuY2Uuc2F2ZU1hcCgpIC0gXCIgK1xuICAgICAgICAgICAgICAgIFwiVGhlIHJlcXVlc3RlZCBtYXAgY291bGQgbm90IGJlIHNhdmVkIGJlY2F1c2U6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJUaGUgcmVxdWVzdGVkIG1hcCBjb3VsZCBub3QgYmUgc2F2ZWQgYmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGVycm9yKHMpOiBcIiArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFEucmVqZWN0KGUpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWFwJ3MgZGVzY3JpcHRvciBmcm9tIHRoZSByZWdpc3RyeVxuICAgICAqIEBwYXJhbSBtYXBJZCBpZGVudGlmaWVyIG9mIG1hcFxuICAgICAqIEByZXR1cm4gcmVzb2x2aW5nIHRoZSBtYXAgb2JqZWN0XG4gICAgICovXG4gICAgZmV0Y2hNYXAgKG1hcElkIDogc3RyaW5nKSA6IFByb21pc2U8YW55PiB7XG4gICAgICAgIC8vSGF2aW5nIHRvIHNlbmQgY2FjaGUgYnVzdGluZyBwYXJhbWV0ZXIgdG8gYXZvaWQgQ09SUyBoZWFkZXIgY2FjaGVcbiAgICAgICAgLy8gbm90IHNlbmRpbmcgY29ycmVjdCBPcmlnaW4gdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTUFQKS5nZXQobWFwSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWFwJ3MgZGVzY3JpcHRvciBhbmQgbG9hZCBpdCBhcyB0aGVcbiAgICAgKiBjdXJyZW50IG1hcCBtYW5hZ2VkIGJ5IHRoaXMgc2VydmljZVxuICAgICAqIEBwYXJhbSBtYXBJZCBpZGVudGlmaWVyIG9mIG1hcFxuICAgICAqIEByZXR1cm4gcmVzb2x2aW5nIHRoZSBtYXAgb2JqZWN0XG4gICAgICovXG4gICAgbG9hZE1hcCAobWFwSWQgOiBzdHJpbmcpIDogUHJvbWlzZTxhbnk+IHtcblxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE1hcChtYXBJZCkudGhlbihtYXAgPT4ge1xuXG4gICAgICAgICAgICBpZighbWFwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArIG1hcElkICtcbiAgICAgICAgICAgICAgICAgICAgXCInKSBjYW1lIGJhY2sgbnVsbFwiKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihtYXApID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgbWFwICgnXCIgKyBtYXBJZCArXG4gICAgICAgICAgICAgICAgICAgIFwiJykgY2FtZSBiYWNrIGFzIGEgc3RyaW5nXCIpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYobWFwLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSB3YXMgYW4gZXJyb3IgbG9hZGluZyB0aGUgcmVxdWVzdGVkIG1hcCAoJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgbWFwSWQgKyBcIicpOiBcIiArIG1hcC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvL2xvYWRpbmcgYSBtYXAgYnkgaXRzIElELCBzbyB3ZSBuZWVkIHRvIGluY3JlbWVudCBpdCdzIHZpZXcgY291bnRcbiAgICAgICAgICAgIGlmKCdkZXZlbG9wbWVudCcgIT09IENvbmZpZy5lbnYpIHtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIChtYXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgdmlldyBjb3VudFxuICAgICAgICAgICAgICAgICAgICBsZXQgdmlld3MgPSBtYXAuc3RhdGlzdGljcyA/IChtYXAuc3RhdGlzdGljcy5udW1WaWV3c3x8MCkgOiAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0Y2ggPSBbIHsgb3A6ICdyZXBsYWNlJywgcGF0aDogJy9zdGF0aXN0aWNzL251bVZpZXdzJywgdmFsdWU6IHZpZXdzKzEgfSBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLk1BUCkucGF0Y2gobWFwLmlkLCBwYXRjaClcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5tYXBTZXJ2aWNlLnBhdGNoKG1hcC5pZCwgcGF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCB1cGRhdGVkID0+IHsgbWFwLnN0YXRpc3RpY3MgPSB1cGRhdGVkLnN0YXRpc3RpY3M7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCggZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLnNhdmVNYXAoKSAtIEVycm9yIHVwZGF0aW5nIHZpZXcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY291bnQgZm9yIG1hcCAoJ1wiICsgbWFwSWQgKyBcIicpOiBcIiArIGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAxMDAwLCBtYXApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbG9hZCB0aGUgbWFwIGludG8gdGhlIHZpZXdlclxuICAgICAgICAgICAgdGhpcy5sb2FkTWFwRnJvbU9iaihtYXApO1xuXG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goIGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmxvYWRNYXAoKSAtIFwiICtcbiAgICAgICAgICAgICAgICBcIlRoZSByZXF1ZXN0ZWQgbWFwIGNvdWxkIG5vdCBiZSBsb2FkZWQgYmVjYXVzZSBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArIG1hcElkICtcbiAgICAgICAgICAgICAgICBcIicpIGNvdWxkIG5vdCBiZSBsb2FkZWQgYmVjYXVzZSBvZiB0aGUgZm9sbG93aW5nIGVycm9yKHMpOiBcIiArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFEucmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgbWFwIGZyb20gaXRzIGRlc2NyaXB0b3IgYXMgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXAgbWFuYWdlZCBieSB0aGlzIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0gbWFwIG9iamVjdFxuICAgICAqL1xuICAgIGxvYWRNYXBGcm9tT2JqIChtYXAgOiBhbnkpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkxvYWRpbmcgTWFwIE9iamVjdFwiKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2cobWFwKTtcblxuICAgICAgICB0aGlzLl9tYXBJZCA9IG1hcC5pZDtcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gbWFwO1xuXG4gICAgICAgIG1hcC5leHRlbnQgPSBtYXAuZXh0ZW50IHx8IHt9O1xuICAgICAgICBsZXQgd2VzdCA9ICBpc05hTihtYXAuZXh0ZW50Lm1pbngpID8gLTE3OS4wIDogbWFwLmV4dGVudC5taW54KjEuMDtcbiAgICAgICAgbGV0IGVhc3QgPSAgaXNOYU4obWFwLmV4dGVudC5tYXh4KSA/ICAxNzkuMCA6IG1hcC5leHRlbnQubWF4eCoxLjA7XG4gICAgICAgIGxldCBzb3V0aCA9IGlzTmFOKG1hcC5leHRlbnQubWlueSkgPyAgLTg5LjAgOiBtYXAuZXh0ZW50Lm1pbnkqMS4wO1xuICAgICAgICBsZXQgbm9ydGggPSBpc05hTihtYXAuZXh0ZW50Lm1heHkpID8gICA4OS4wIDogbWFwLmV4dGVudC5tYXh5KjEuMDtcblxuICAgICAgICAvL2Vuc3VyZSB4LHkgaXMgb3JkZXJlZCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGlmKHdlc3QgPiBlYXN0KSB7XG4gICAgICAgICAgICB0ID0gTWF0aC5taW4od2VzdCwgZWFzdCk7XG4gICAgICAgICAgICBlYXN0ID0gbWFwLmV4dGVudC5tYXh4ID0gTWF0aC5tYXgod2VzdCwgZWFzdCk7XG4gICAgICAgICAgICB3ZXN0ID0gbWFwLmV4dGVudC5taW54ID0gdDtcbiAgICAgICAgfVxuICAgICAgICBpZihzb3V0aCA+IG5vcnRoKSB7XG4gICAgICAgICAgICB0ID0gTWF0aC5taW4oc291dGgsIG5vcnRoKTtcbiAgICAgICAgICAgIG5vcnRoID0gbWFwLmV4dGVudC5tYXh5ID0gTWF0aC5tYXgoc291dGgsIG5vcnRoKTtcbiAgICAgICAgICAgIHNvdXRoID0gbWFwLmV4dGVudC5taW55ID0gdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcHJldmVudCBvdXQtb2YtYm91bmRzIGV4dGVudHNcbiAgICAgICAgaWYod2VzdCA8IC0xODAuMCkgd2VzdCA9IC0xNzkuMDtcbiAgICAgICAgaWYoZWFzdCA+IDE4MC4wKSAgZWFzdCA9ICAxNzkuMDtcbiAgICAgICAgaWYoc291dGggPCAtOTAuMCkgc291dGggPSAtODkuMDtcbiAgICAgICAgaWYobm9ydGggPiA5MC4wKSAgbm9ydGggPSAgODkuMDtcblxuICAgICAgICAvL3NldCBleHRlbnQgZnJvbSBsb2FkZWQgbWFwXG4gICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSBtYXAuZXh0ZW50O1xuICAgICAgICB2YXIgZXh0ZW50ID0gbWFwLmV4dGVudDtcblxuICAgICAgICAvL3JlbW92ZSBleGlzdGluZyBsYXllcnNcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZWFjaExheWVyKChsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBbXTtcblxuICAgICAgICAvL3NldCBuZXcgYmFzZSBsYXllclxuICAgICAgICB0aGlzLnNldEJhc2VMYXllcihtYXAuYmFzZUxheWVyKTtcblxuICAgICAgICAvL2FkZCBsYXllcnMgZnJvbSBsb2FkZWQgbWFwXG4gICAgICAgIHRoaXMuYWRkTGF5ZXJzKG1hcC5sYXllcnMpO1xuXG4gICAgICAgIC8vYWRkIGZlYXR1cmVzXG4gICAgICAgIGlmKG1hcC5hbm5vdGF0aW9ucyAmJiBtYXAuYW5ub3RhdGlvbnMuZ2VvSlNPTikge1xuICAgICAgICAgICAgbGV0IGZjID0gbWFwLmFubm90YXRpb25zLmdlb0pTT047XG4gICAgICAgICAgICBpZihmYy5mZWF0dXJlcylcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVzKGZjLmZlYXR1cmVzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVzKFtmY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKFtcbiAgICAgICAgICAgIFtleHRlbnQubWlueSwgZXh0ZW50Lm1pbnhdLFxuICAgICAgICAgICAgW2V4dGVudC5tYXh5LCBleHRlbnQubWF4eF1cbiAgICAgICAgXSk7XG5cbiAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbWFwOmxvYWRlZCcsIG1hcCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveU1hcCAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRGVzdHJveWluZyBNYXBcIik7XG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHRha2UgYW4gZXhpc3RpbmcgbWFwIHRoYXQgaXMgYWxyZWFkeSBwZXJzaXN0ZWQgb24gdGhlXG4gICAgICogc2VydmVyIGFuZCB1bmxpbmsgaXQgaGVyZSBpbiB0aGUgY2xpZW50IHNvIHRoYXQgaXQgd2lsbCBiZSBzYXZlZFxuICAgICAqIGFzIGEgY29tcGxldGVseSBuZXcgbWFwIHdoZW4gbWFwU2VydmljZS5zYXZlTWFwKC4uLikgaXMgbmV4dCBjYWxsZWRcbiAgICAgKi9cbiAgICBzZXRBc05ld01hcCAobWFwVG9Vc2UpIHtcbiAgICAgICAgdGhpcy5fbWFwSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYXBEZWYgPSBtYXBUb1VzZSB8fCB0aGlzLmluaXRpYWxpemVNYXBEZWZpbml0aW9uKCk7XG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIFRvb2wgb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIHJlZ2lzdGVyVG9vbCAoaWQsIHRvb2wpIHtcbiAgICAgICAgdGhpcy5fdG9vbHNbaWRdID0gdG9vbDtcbiAgICB9XG5cbiAgICB1bnJlZ2lzdGVyVG9vbCAoaWQpIHtcbiAgICAgICAgdGhpcy5fdG9vbHNbaWRdID0gbnVsbDtcbiAgICB9XG5cbiAgICBlbmFibGVUb29sIChpZCwgZmluaXNoKSB7XG4gICAgICAgIGlmKCF0aGlzLl90b29sc1tpZF0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdG9vbHNbaWRdLmFjdGl2YXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ3Rvb2w6ZGlzYWJsZWQnLCBpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vdGlmeSgndG9vbDplbmFibGVkJywgaWQpO1xuICAgIH1cblxuXG4gICAgLyogLS0tLS0tLS0tLS0gTUlTQyAtLS0tLS0tLS0tLS0gKi9cblxuICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL2dza2xlZS9uZ1N0b3JhZ2VcbiAgICBjYWNoZU1hcCAoKSB7XG5cbiAgICAgICAgaWYodGhpcy5zdGF0ZSAmJiB0aGlzLnN0YXRlLmRpcnR5KSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXBSZXNvdXJjZUNvbnRlbnQoKTtcbiAgICAgICAgICAgIC8vdXNlIGV4cGxvZGVkIGxheWVyIGluZm9cbiAgICAgICAgICAgIG1hcC5sYXllcnMgPSB0aGlzLl9sYXllclN0YXRlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIC8vICRzZXNzaW9uU3RvcmFnZS5tYXAgPSBtYXA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXN0b3JlTWFwICgpIHtcbiAgICAgICAgLy8gaWYoJHNlc3Npb25TdG9yYWdlLm1hcCkge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJSZXN0b3JpbmcgY2FjaGVkIG1hcFwiKTtcbiAgICAgICAgLy8gICAgIGxldCBtYXAgPSAkc2Vzc2lvblN0b3JhZ2UubWFwO1xuICAgICAgICAvLyAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkobWFwKSk7XG4gICAgICAgIC8vICAgICAkc2Vzc2lvblN0b3JhZ2UubWFwID0gbnVsbDtcbiAgICAgICAgLy8gICAgIHRoaXMubG9hZE1hcEZyb21PYmoobWFwKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG59XG4iXX0=