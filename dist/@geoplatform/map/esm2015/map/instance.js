/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as jquery from "jquery";
/** @type {?} */
const jQuery = jquery;
import * as Q from "q";
import { circleMarker, geoJSON, featureGroup, LayerGroup } from 'leaflet';
import { Config, ItemTypes, ServiceFactory, JQueryHttpClient } from 'geoplatform.client';
import LayerFactory from '../layer/factory';
import DefaultBaseLayer from '../layer/baselayer-default';
class Listener {
    constructor() {
        //listeners to be unregistered upon destroy
        this._listeners = {};
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    on(type, listener) {
        if (!this._listeners[type])
            this._listeners[type] = [];
        this._listeners[type].push(listener);
    }
    /**
     * @param {?} type
     * @param {?} listener
     * @return {?}
     */
    off(type, listener) {
        if (!type)
            this._listeners = {};
        if (!this._listeners[type])
            return;
        if (!listener)
            this._listeners[type] = [];
        else {
            /** @type {?} */
            var idx = this._listeners[type].indexOf(listener);
            if (idx >= 0)
                this._listeners[type].splice(idx, 1);
        }
    }
    /**
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    notify(type, ...options) {
        if (!this._listeners[type])
            return;
        /** @type {?} */
        var args = Array.prototype.slice.call(arguments, 1);
        this._listeners[type].forEach(function (l) { l.apply(null, args); });
    }
}
if (false) {
    /** @type {?} */
    Listener.prototype._listeners;
}
export default class MapInstance extends Listener {
    /**
     * @param {?} key
     */
    constructor(key) {
        super();
        this.setHttpClient(new JQueryHttpClient());
        this.setServiceFactory(ServiceFactory);
        //generate random key (see factory below)
        this._key = key || Math.ceil(Math.random() * 9999);
        //registry id of current map if available
        this._mapId = null,
            //definition of map (ie, from server)
            this._mapDef = this.initializeMapDefinition(),
            //primary map instance (ie, leaflet)
            this._mapInstance = null,
            //default map extent (if map doesn't have one for being saved)
            this._defaultExtent = null,
            //current base layer object and leaflet instance
            this._baseLayerDef = null,
            this._baseLayer = null,
            //set definitions of layer states (including layer info) on map
            this._layerStates = [],
            //map layer def ids with leaflet instances
            this._layerCache = {},
            //errors generated by layers loading
            this._layerErrors = [],
            this._layerErrorHandler = function (e) {
                console.log(`MapInstance.defaultLayerErrorHandler() - ${e.id} : ${e.message}`);
            },
            //layer used to store features on map
            this._featureLayer = null,
            this._featureLayerVisible = true,
            //set of registered map tools
            this._tools = [],
            //state management
            this.state = { dirty: false }; // jshint ignore:line
        this._geoJsonLayerOpts = {
            style: function (feature) {
                if (feature.properties.style)
                    return feature.properties.style;
            },
            onEachFeature: function (feature, layer) {
                /** @type {?} */
                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };
                if (~feature.geometry.type.indexOf('Point')) {
                    style.fillOpacity = 0.9;
                }
                /** @type {?} */
                var props = feature.properties = feature.properties || {};
                if (feature.properties.id === undefined || feature.properties.id === null)
                    feature.properties.id = Math.floor(Math.random() * 999999);
                feature.properties.label = props.label || props.title || props.name || "Untitled " + feature.geometry.type + " Feature";
                feature.properties.description = props.description || props.desc || "This feature needs a description!";
                feature.properties.style = props.style || style;
                layer.bindTooltip(props.label);
                /*
                                toggle: setLabelNoHide(bool)
                                it may only exist on markers!
                                */
            },
            pointToLayer: function (feature, latlng) {
                /** @type {?} */
                var style = feature.properties.style || {};
                style.radius = style.radius || 4;
                style.weight = style.weight || 2;
                style.color = style.color || '#03f';
                style.opacity = style.opacity || 0.9;
                style.fillOpacity = style.opacity;
                style.fillColor = style.color;
                return circleMarker(latlng, style);
            }
        };
    }
    /**
     * @return {?}
     */
    dispose() {
        this.destroyMap();
        this.svcCache = null;
        this.serviceFactory = null;
        this.httpClient = null;
        this._key = null;
        this._mapId = null;
        this._mapDef = null;
        this._mapInstance = null;
        this._defaultExtent = null;
        this._baseLayerDef = null;
        this._baseLayer = null;
        this._layerStates = null;
        this._layerCache = null;
        this._layerErrors = null;
        this._featureLayer = null;
        this._featureLayerVisible = true;
        this._tools = null;
        this.state = null;
        this._geoJsonLayerOpts = null;
    }
    /**
     * @return {?}
     */
    getKey() {
        return this._key;
    }
    /**
     * Override default (JQuery-based) map service used by this instance
     * @deprecated use setServiceFactory instead
     * @param {?} mapService - service to use to CRUD map objects
     * @return {?}
     */
    setService(mapService) {
        // this.mapService = mapService;
    }
    /**
     * @param {?} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     * @return {?}
     */
    setServiceFactory(factory) {
        this.svcCache = {}; //wipe out cached services
        this.serviceFactory = factory;
    }
    /**
     * @param {?} httpClient - HttpClient impl to use with the new factory
     * @return {?}
     */
    setHttpClient(httpClient) {
        this.svcCache = {}; //wipe out cached services
        this.httpClient = httpClient;
    }
    /**
     * @param {?} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {?} item service implementation for the requested type
     */
    getService(type) {
        if (!this.svcCache[type])
            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);
        return this.svcCache[type];
    }
    /**
     * @param {?} fn - callback when an error is encountered
     * @return {?}
     */
    setErrorHandler(fn) {
        this._layerErrorHandler = fn;
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerStateIndex(layerId) {
        if (!layerId)
            return -1;
        for (let i = 0; i < this._layerStates.length; ++i) {
            if (this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {
                return i;
            }
        }
        return -1;
        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );
    }
    /**
     * @param {?} layerId
     * @return {?}
     */
    getLayerState(layerId) {
        /** @type {?} */
        let index = this.getLayerStateIndex(layerId);
        return index >= 0 ? this._layerStates[index] : null;
    }
    /**
     * @return {?}
     */
    initializeMapDefinition() {
        return {
            type: ItemTypes.MAP,
            title: "My New Map",
            label: "My New Map",
            description: "This map needs a description",
            createdBy: null,
            baseLayer: this._baseLayerDef,
            layers: [],
            keywords: [],
            themes: [],
            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']
        };
    }
    /**
     * @param {?=} metadata object
     * @return {?} object definition of the current map suitable for sending to WMVR
     */
    getMapResourceContent(metadata) {
        metadata = metadata || {};
        //map layers
        metadata.layers = this._layerStates.slice(0);
        // ... UAL should support accepting just an id here, so we'll do just that
        metadata.baseLayer = this._baseLayerDef;
        metadata.annotations = this._featureLayer ?
            { title: "Map Features", geoJSON: this._featureLayer.toGeoJSON() } : null;
        /** @type {?} */
        let extent = this._mapInstance.getBounds();
        metadata.extent = {
            minx: extent.getWest(),
            miny: extent.getSouth(),
            maxx: extent.getEast(),
            maxy: extent.getNorth()
        };
        return metadata;
    }
    /**
     * @return {?} Leaflet toolbar
     */
    getDrawControlToolbar() {
        if (!(/** @type {?} */ (this._mapInstance)).drawControl)
            return null;
        /** @type {?} */
        var toolbars = (/** @type {?} */ (this._mapInstance)).drawControl._toolbars;
        /** @type {?} */
        var toolbar = null;
        for (var key in toolbars) {
            if (toolbars.hasOwnProperty(key)) {
                if (toolbars[key]._modes) {
                    toolbar = toolbars[key];
                    break;
                }
            }
        }
        return toolbar;
    }
    /**
     * @param {?} error Leaflet tile load error (.target is layer, .tile is image)
     * @return {?}
     */
    handleLayerError(error) {
        // console.log("MapInstance.handleLayerError() - " +
        //     "Layer's tile failed to load: " + error.tile.src);
        if (!this._layerCache) {
            console.log("Unable to find layer in layer cache. Layer error is " + error);
            return;
        }
        /** @type {?} */
        var layer = error.target;
        for (var id in this._layerCache) {
            if (this._layerCache[id] === layer) {
                this.processLayerError(error, id);
                break;
            }
        }
    }
    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     * @param {?} error
     * @param {?} id
     * @return {?}
     */
    processLayerError(error, id) {
        /** @type {?} */
        var finder = (l) => { return l.id === id || (l.layer && l.layer.id === id); };
        if (!this._layerErrors.find(finder)) {
            /** @type {?} */
            let obj = this.logLayerError(id, "Layer ('" + id + "') failed to completely load. " +
                "It may be inaccessible or misconfigured.");
            /** @type {?} */
            var url = (/** @type {?} */ (error)).tile.src;
            /** @type {?} */
            var params = { id: id };
            url.substring(url.indexOf("?") + 1, url.length).split('&').forEach(function (param) {
                /** @type {?} */
                var p = param.split('=');
                params[p[0]] = p[1];
            });
            /** @type {?} */
            let layerService = this.getService(ItemTypes.LAYER);
            if (layerService) {
                layerService.validate(id, params)
                    .catch(e => {
                    /** @type {?} */
                    var def = this._layerStates.find(finder);
                    if (def) {
                        obj.message = "Layer '" + def.layer.label + "' failed to completely load. " +
                            "Reported cause: " + e.message;
                    }
                    this.notify('layer:error', obj);
                });
            }
        }
    }
    /**
     * @param {?} layerId - identifier of layer generating the error
     * @param {?} errorMsg - message of the error
     * @return {?}
     */
    logLayerError(layerId, errorMsg) {
        /** @type {?} */
        let err = { id: layerId, message: errorMsg };
        this._layerErrors.push(err);
        if (this._layerErrorHandler) {
            this._layerErrorHandler(err);
        }
        return err;
    }
    /**
     * @param {?=} event
     * @param {...?} options
     * @return {?}
     */
    touch(event, ...options) {
        this.state.dirty = true;
        if (event) {
            if (arguments.length > 1) {
                this.notify.apply(this, Array.prototype.slice.call(arguments));
            }
            else
                this.notify(event);
            // console.log("Dirtying map for " + event);
        }
        // else console.log("Dirtying map");
    }
    /**
     * @return {?}
     */
    clean() {
        // console.log("Cleaning map");
        this.state.dirty = false;
    }
    /**
     * @param {?} map
     * @return {?}
     */
    setMap(map) { this._mapInstance = map; }
    /**
     * @return {?} map instance
     */
    getMap() { return this._mapInstance; }
    /**
     * @return {?} definition of map
     */
    getMapDefinition() { return this._mapDef; }
    /**
     * @return {?} identifier of map
     */
    getMapId() { return this._mapId; }
    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param {?} lat number
     * @param {?} lng number
     * @param {?=} zoom number (optional)
     * @return {?}
     */
    setView(lat, lng, zoom) {
        /** @type {?} */
        let z = zoom;
        if (typeof (z) === 'undefined')
            z = this._mapInstance.getZoom();
        this._mapInstance.setView([lat, lng], z);
        this.touch('map:view:changed');
    }
    /**
     * Retrieve the current center of the map
     * @return {?} [lat,lng]
     */
    getView() {
        /** @type {?} */
        var latLng = this._mapInstance.getCenter();
        return [latLng.lat, latLng.lng];
    }
    /**
     * @return {?} integer current zoom level of the map
     */
    getZoom() {
        return this._mapInstance.getZoom();
    }
    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     * @return {?}
     */
    zoomToDefault() {
        if (!this._mapInstance)
            return;
        if (this._defaultExtent) {
            this._mapInstance.fitBounds([
                [this._defaultExtent.miny, this._defaultExtent.minx],
                [this._defaultExtent.maxy, this._defaultExtent.maxx]
            ]);
        }
        else {
            console.log("MapInstance.zoomToDefault() - No default extent specified");
            this._mapInstance.setView([38, -96], 5);
        }
        try {
            this.touch('map:view:changed');
        }
        catch (e) { }
    }
    /**
     * @param {?} extent - either a GP extent object or Leaflet LatLngBounds object
     * @return {?}
     */
    setExtent(extent) {
        if (!extent)
            return;
        if (typeof (extent.minx) !== 'undefined' &&
            typeof (extent.miny) !== 'undefined' &&
            typeof (extent.maxx) !== 'undefined' &&
            typeof (extent.maxy) !== 'undefined') {
            //GP model extent
            this._mapInstance.fitBounds([
                [extent.miny, extent.minx],
                [extent.maxy, extent.maxx]
            ]);
        }
        else if (typeof (extent.getWest) !== 'undefined') {
            //L.LatLngBounds
            this._mapInstance.fitBounds(extent);
        }
        else {
        }
    }
    /**
     * @param {?} layer Leaflet Layer instance or object definition
     * @return {?}
     */
    setBaseLayer(layer) {
        /** @type {?} */
        let promise = null;
        if (!layer) {
            promise = DefaultBaseLayer.get(this.getService(ItemTypes.LAYER));
        }
        else
            promise = Q.resolve(layer);
        promise.then(layer => {
            /** @type {?} */
            let leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                console.log("Warning: MapInstance could not create base " +
                    "layer for '" + layer.id + "'");
                return;
            }
            this._mapInstance.addLayer(leafletLayer);
            (/** @type {?} */ (leafletLayer)).setZIndex(0);
            /** @type {?} */
            let oldBaseLayer = this._baseLayer;
            if (oldBaseLayer) {
                this._mapInstance.removeLayer(oldBaseLayer);
            }
            //remember new base layer
            this._baseLayer = leafletLayer;
            this._baseLayerDef = layer;
            //will notify listeners
            this.touch('baselayer:changed', layer, leafletLayer);
            // this.notify('baselayer:changed', layer, leafletLayer);
        })
            .catch(e => {
            console.log(`MapInstance.setBaseLayer() - Error getting base layer for map : ${e.message}`);
            this.logLayerError(layer.id, "Error setting baselayer on map " +
                "because of the following error(s): " + e.message);
        });
    }
    /**
     * @return {?} array of base layers definitions that can be used
     */
    getBaseLayer() { return this._baseLayerDef; }
    /**
     * @return {?} list of layer states containing layer information
     */
    getLayers() { return this._layerStates; }
    /**
     * @return {?}
     */
    getLayerErrors() { return this._layerErrors; }
    /**
     * @return {?}
     */
    clearLayerErrors() {
        this._layerErrors = [];
        this.notify('layer:error');
    }
    /**
     * @return {?}
     */
    clearOverlays() {
        if (!this._layerCache)
            return;
        for (var i = this._layerStates.length - 1; i >= 0; --i) {
            /** @type {?} */
            var state = this._layerStates[i];
            /** @type {?} */
            var layerInstance = this._layerCache[state.layer.id];
            if (layerInstance) {
                layerInstance.off("layer:error");
                this._layerCache[state.layer.id] = null;
                this._mapInstance.removeLayer(layerInstance);
            }
        }
        this._layerStates = [];
        this.touch('layers:changed');
        //TODO stop listening for layer events
    }
    /**
     * @param {?} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     * @return {?}
     */
    addLayers(layers) {
        if (!this._layerCache) {
            console.log("WARN: attempting to add layers to an empty cache");
            return;
        }
        if (!this._layerCache) {
            console.log("WARN: Attempting to add layers to a map with no layer cache");
            return;
        }
        if (!layers)
            return;
        if (typeof (layers.push) === 'undefined') {
            layers = [layers];
        }
        layers.forEach((obj, index) => {
            /** @type {?} */
            let layer = null;
            /** @type {?} */
            let state = null;
            if (obj.type && obj.type === ItemTypes.LAYER) { //is a layer
                //is a layer
                layer = obj;
            }
            else if (obj.layer) { //is layer state
                //is layer state
                layer = obj.layer; // containing a layer
                state = obj;
            }
            if (!layer) {
                console.log("MapInstance.addLayers() - layer (" + index +
                    ") is not a Layer or a Layer state. Ignoring...");
                return; //layer info is missing, skip it
            }
            //DT-442 prevent adding layer that already exists on map
            if (this._layerCache[layer.id])
                return;
            if (!state) {
                try {
                    /** @type {?} */
                    let layerCopy = JSON.parse(JSON.stringify(layer));
                    state = {
                        opacity: 1,
                        visibility: true,
                        layer: layerCopy
                    };
                }
                catch (e) {
                    throw new Error("Unable to add layer to map because of " + e.message);
                }
            }
            /** @type {?} */
            let z = layers.length - index;
            state.zIndex = z;
            this.addLayerWithState(layer, state);
        });
        this.touch('layers:changed');
    }
    /**
     * @param {?} layer - GeoPlatform Layer instance
     * @param {?} state - GeoPlatform Layer State
     * @return {?}
     */
    addLayerWithState(layer, state) {
        /** @type {?} */
        var leafletLayer = null;
        try {
            if (!layer || !state)
                throw new Error("Invalid argument, missing layer and or state");
            leafletLayer = LayerFactory.create(layer);
            if (!leafletLayer) {
                throw new Error("Could not create leaflet layer for GP Layer '" +
                    layer.id + "'");
            }
        }
        catch (e) {
            this.logLayerError(layer.id, "Layer '" + layer.label + "' could not be added to the " +
                "map instance; " + e.message);
        }
        if (!leafletLayer)
            return;
        //cache leaflet object first
        if (this._layerCache)
            this._layerCache[layer.id] = leafletLayer;
        //listen for layer errors so we can inform the user
        // that a layer hasn't been loaded in a useful way
        leafletLayer.on('tileerror', (e) => { this.handleLayerError(e); });
        this._mapInstance.addLayer(leafletLayer);
        if (!isNaN(state.zIndex) && leafletLayer.setZIndex)
            leafletLayer.setZIndex(state.zIndex);
        this._layerStates.push(state);
        this.notify('layer:added', layer, leafletLayer);
        // if layer is initially "off" or...
        // if layer is initially not 100% opaque
        if (!state.visibility || state.opacity < 1) {
            // initialize layer visibility and opacity async, or else
            // some of the layers won't get properly initialized
            setTimeout((layer, state) => {
                this.setLayerVisibility(layer, state.visibility);
                this.setLayerOpacity(layer, state.opacity);
                //TODO notify of change
                //DT-2102 timeout needs to be large enough or else
                // feature layers won't get opacity updated on map load
            }, 2000, leafletLayer, state);
        }
    }
    /**
     * @param {?} from - position of layer being moved
     * @param {?} to - desired position to move layer to
     * @return {?}
     */
    moveLayer(from, to) {
        if (!this._layerCache)
            return;
        if (!this._layerCache)
            return;
        if (isNaN(from))
            return;
        //end of list
        if (isNaN(to))
            to = this._layerStates.length - 1;
        /** @type {?} */
        let copy = this._layerStates.splice(from, 1)[0]; //grab layer being moved
        this._layerStates.splice(to, 0, copy);
        for (let z = 1, i = this._layerStates.length - 1; i >= 0; --i, ++z) {
            /** @type {?} */
            let layerState = this._layerStates[i];
            /** @type {?} */
            let layerInstance = this._layerCache[layerState.layer.id];
            if (layerInstance) {
                layerInstance.setZIndex(z);
                layerState.zIndex = z;
            }
        }
        this.touch('layers:changed', this.getLayers());
    }
    /**
     *
     * @param {?} id
     * @return {?}
     */
    removeLayer(id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            let index = this.getLayerStateIndex(id);
            // console.log("MapInstance.removeLayer(" + id + ")");
            if (index >= 0 && index < this._layerStates.length)
                this._layerStates.splice(index, 1);
            //stop listening for errors
            layerInstance.off("layer:error");
            //remove layer from map
            this._mapInstance.removeLayer(layerInstance);
            //remove layer from cache
            this._layerCache[id] = null;
        }
        this.touch('layers:changed');
    }
    /**
     *
     * @param {?} id
     * @return {?}
     */
    toggleLayerVisibility(id) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        if (layerInstance) {
            /** @type {?} */
            let state = this.getLayerState(id);
            state.visibility = !state.visibility;
            if (layerInstance._currentImage) {
                //ESRI Image Service layers have an IMG element
                // that gets modified and replaced every map event (zoom/pan)
                // so we can't just toggle classes like on other layers.
                //Instead, we need to use the ESRI setOpacity method to toggle
                // but need to update layer state as well.
                layerInstance.setOpacity(state.visibility ? 1 : 0);
                state.opacity = layerInstance.getOpacity();
                return;
            }
            this.setLayerVisibility(layerInstance, state.visibility);
        }
    }
    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} visible - flag indicating visibility of layer
     * @return {?}
     */
    setLayerVisibility(layerInstance, visible) {
        if ((/** @type {?} */ (layerInstance)).setVisibility) {
            //using custom method provided in src/layer/module.js
            (/** @type {?} */ (layerInstance)).setVisibility(visible);
        }
        else if ((/** @type {?} */ (layerInstance))._container) {
            /** @type {?} */
            let el = jQuery((/** @type {?} */ (layerInstance))._container);
            // if(visible) el.removeClass("invisible");
            // else el.addClass('invisible');
            el.css({ 'display': visible ? '' : 'none' });
        }
        this.touch('map:layer:changed');
    }
    /**
     *
     * @param {?} id
     * @param {?} opacity
     * @return {?}
     */
    updateLayerOpacity(id, opacity) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[id];
        //if layer id is for base layer...
        if (!layerInstance && this._baseLayerDef.id === id) {
            layerInstance = this._baseLayer;
        }
        //adjust rendered leaflet layer
        opacity = this.setLayerOpacity(layerInstance, opacity);
        /** @type {?} */
        let state = this.getLayerState(id);
        if (state)
            state.opacity = opacity;
    }
    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {?} layerInstance - leaflet layer instance
     * @param {?} opacity - value between 0 and 1.0 or 0 and 100
     * @return {?} normalized opacity value between 0 and 1.0
     */
    setLayerOpacity(layerInstance, opacity) {
        if (layerInstance && (/** @type {?} */ (layerInstance)).setOpacity) {
            if (opacity > 1.0)
                opacity = opacity / 100.0;
            (/** @type {?} */ (layerInstance)).setOpacity(opacity);
            this.touch('map:layer:changed');
        }
        return opacity;
    }
    /**
     * @param {?} gpLayer
     * @return {?} Leaflet layer instance representing that layer or null
     */
    getLeafletLayerFor(gpLayer) {
        if (!gpLayer || !this._layerCache)
            return null;
        /** @type {?} */
        let leafletLayer = this._layerCache[gpLayer.id];
        return leafletLayer || null;
    }
    /**
     *
     * @param {?} layerId
     * @return {?}
     */
    toggleGetFeatureInfo(layerId) {
        if (!this._layerCache)
            return;
        /** @type {?} */
        var layerInstance = this._layerCache[layerId];
        if (layerInstance) {
            if (typeof (layerInstance.enableGetFeatureInfo) !== 'undefined') {
                if (layerInstance.isGetFeatureInfoEnabled()) {
                    layerInstance.disableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).removeClass('selectable-cursor');
                }
                else {
                    layerInstance.enableGetFeatureInfo();
                    jQuery((/** @type {?} */ (this._mapInstance))._container).addClass('selectable-cursor');
                }
            }
        }
    }
    /**
     * @return {?} array of features on the map
     */
    getFeatures() {
        if (this._featureLayer) {
            /** @type {?} */
            let geojson = this._featureLayer.toGeoJSON();
            return (/** @type {?} */ (geojson)).features;
        }
        return [];
    }
    /**
     * @param {?} json geojson object or array of geojson objects
     * @return {?}
     */
    addFeatures(json) {
        if (!json)
            return;
        if (typeof (json.push) !== 'undefined') {
            //array of features
            for (var i = 0; i < json.length; ++i)
                this.addFeature(json[i], false);
            this.touch('features:changed');
        }
        else if (json.features) {
            this.addFeatures(json.features);
        }
        else { //single feature
            //single feature
            this.addFeature(json, true);
        }
    }
    /**
     * @param {?} json geojson object
     * @param {?=} fireEvent
     * @return {?}
     */
    addFeature(json, fireEvent) {
        // var type = json.type;
        // var coordinates = json.coordinates;
        if (!this._featureLayer) {
            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);
            this._featureLayer = featureGroup().addTo(this._mapInstance);
        }
        /** @type {?} */
        var opts = jQuery.extend({}, this._geoJsonLayerOpts);
        geoJSON(json, opts).eachLayer((l) => this.addFeatureLayer(l));
        if (typeof (fireEvent) === 'undefined' || fireEvent === true)
            this.touch('features:changed');
        else
            this.touch();
        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));
    }
    /**
     * @param {?} featureJson object defining a GeoJSON feature
     * @return {?}
     */
    updateFeature(featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            (/** @type {?} */ (layer)).feature = featureJson;
            //update style
            layer.setStyle(featureJson.properties.style);
            /** @type {?} */
            var label = featureJson.properties.label ||
                "Untitled " + featureJson.geometry.type + " Feature";
            layer.bindTooltip(label);
            // layer.redraw();
            this.touch("map:feature:changed");
        }
    }
    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param {?} featureJson object defining GeoJSON feature
     * @return {?}
     */
    replaceFeature(featureJson) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if (layer) {
            //remove existing
            this._featureLayer.removeLayer(layer);
            //add replacement
            geoJSON(featureJson, this._geoJsonLayerOpts)
                .eachLayer((l) => this.addFeatureLayer(l));
            this.touch("map:feature:changed");
        }
    }
    /**
     * @param {?} featureId identifier of feature to focus the map on
     * @return {?}
     */
    focusFeature(featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer) {
            if (typeof (layer.getBounds) !== 'undefined') {
                /** @type {?} */
                let extent = layer.getBounds();
                this._mapInstance.fitBounds(extent);
            }
            else if (typeof ((/** @type {?} */ (layer)).getLatLng) !== 'undefined') {
                /** @type {?} */
                let latLng = (/** @type {?} */ (layer)).getLatLng();
                this._mapInstance.panTo(latLng);
            }
            else {
                console.log("MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng");
            }
        }
        else {
            console.log("MapInstance.focusFeature() - Cannot focus feature because it has no layer");
        }
    }
    /**
     * @param {?} featureId : string
     * @return {?}
     */
    removeFeature(featureId) {
        /** @type {?} */
        var layer = this.getFeatureLayer(featureId);
        if (layer && this._featureLayer) {
            this._featureLayer.removeLayer(layer);
            this.touch('features:changed');
        }
    }
    /**
     *
     * @return {?}
     */
    removeFeatures() {
        if (this._featureLayer) {
            this._featureLayer.clearLayers();
            this.touch("features:changed");
        }
    }
    /**
     *
     * @param {?=} featureId
     * @return {?}
     */
    getFeatureLayer(featureId) {
        //if no feature was specified, return root feature layer
        if (!featureId)
            return this._featureLayer;
        //otherwise, find feature...
        if (!this._featureLayer)
            return null;
        /** @type {?} */
        var features = this._featureLayer.getLayers();
        for (var i = 0; i < features.length; ++i) {
            if ((/** @type {?} */ (features[i])).feature &&
                (/** @type {?} */ (features[i])).feature.properties.id === featureId) {
                return (/** @type {?} */ (features[i]));
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    toggleFeaturesLayer() {
        if (!this._featureLayer)
            return false; //ignore if not rendered yet
        this._featureLayerVisible = !this._featureLayerVisible;
        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);
        return this._featureLayerVisible;
    }
    /**
     * @param {?} feature - Leaflet feature instance
     * @param {?} visibility - flag
     * @return {?}
     */
    setFeatureVisibility(feature, visibility) {
        this.setFeatureLayerVisibility(feature, visibility);
    }
    /**
     * @return {?}
     */
    getFeaturesLayerVisibility() {
        return this._featureLayerVisible;
    }
    /**
     * @param {?} layer
     * @return {?}
     */
    addFeatureLayer(layer) {
        this._addFeatureLayer(layer);
        this.touch("features:changed");
    }
    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {?} layer
     * @return {?}
     */
    _addFeatureLayer(layer) {
        if (!(/** @type {?} */ (layer)).feature && layer instanceof LayerGroup) {
            layer.eachLayer((child) => {
                this._addFeatureLayer(child);
            });
        }
        else {
            this._featureLayer.addLayer(layer);
        }
    }
    /**
     * @param {?} layer
     * @param {?} visibility
     * @return {?}
     */
    setFeatureLayerVisibility(layer, visibility) {
        if (!layer)
            return;
        this._featureLayerVisible = visibility;
        if (layer.getLayers) {
            layer.getLayers().forEach((child) => {
                this.setFeatureLayerVisibility(child, visibility);
            });
        }
        else {
            /** @type {?} */
            let container = layer._container || layer._path;
            if (container)
                container.style.display = visibility ? '' : 'none';
        }
    }
    /**
     * @param {?} metadata
     * @return {?} resolving persisted map
     */
    save(metadata) {
        return this.saveMap(metadata);
    }
    /**
     * @param {?} md object containing metadata properties for map
     * @return {?}
     */
    saveMap(md) {
        /** @type {?} */
        let metadata = md || {};
        /** @type {?} */
        const gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';
        metadata.resourceTypes = metadata.resourceTypes || [];
        if (metadata.resourceTypes.indexOf(gpMapType) < 0)
            metadata.resourceTypes.push(gpMapType);
        /** @type {?} */
        var content = this.getMapResourceContent(metadata);
        //ensure the two name properties line up
        if (content.title && content.title !== content.label) {
            content.label = content.title;
        }
        else if (content.label && !content.title) {
            content.title = content.label;
        }
        // console.log("Updating: " + JSON.stringify(map));
        return this.getService(ItemTypes.MAP)
            .save(content)
            .then(result => {
            //track new map's info so we can update it with next save
            if (!this._mapId)
                this._mapId = result.id;
            this._mapDef = result;
            this._defaultExtent = result.extent;
            this.clean();
            return result;
        })
            .catch(err => {
            console.log("MapCore MapInstance.saveMap() - " +
                "The requested map could not be saved because: " + err.message);
            /** @type {?} */
            let e = new Error("The requested map could not be saved because of the following error(s): " +
                err.message);
            return Q.reject(e);
        });
    }
    /**
     * Retrieve a map's descriptor from the registry
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    fetchMap(mapId) {
        //Having to send cache busting parameter to avoid CORS header cache
        // not sending correct Origin value
        return this.getService(ItemTypes.MAP).get(mapId);
    }
    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {?} mapId identifier of map
     * @return {?} resolving the map object
     */
    loadMap(mapId) {
        return this.fetchMap(mapId).then(map => {
            if (!map) {
                throw new Error("The requested map ('" + mapId +
                    "') came back null");
            }
            else if (typeof (map) === 'string') {
                throw new Error("The requested map ('" + mapId +
                    "') came back as a string");
            }
            else if (map.message) {
                throw new Error("There was an error loading the requested map ('" +
                    mapId + "'): " + map.message);
            }
            //loading a map by its ID, so we need to increment it's view count
            if ('development' !== Config.env) {
                setTimeout((map) => {
                    /** @type {?} */
                    let views = map.statistics ? (map.statistics.numViews || 0) : 0;
                    /** @type {?} */
                    let patch = [{ op: 'replace', path: '/statistics/numViews', value: views + 1 }];
                    this.getService(ItemTypes.MAP).patch(map.id, patch)
                        // this.mapService.patch(map.id, patch)
                        .then(updated => { map.statistics = updated.statistics; })
                        .catch(e => {
                        console.log("MapInstance.saveMap() - Error updating view " +
                            "count for map ('" + mapId + "'): " + e);
                    });
                }, 1000, map);
            }
            //load the map into the viewer
            this.loadMapFromObj(map);
            return map;
        })
            .catch(err => {
            console.log("MapInstance.loadMap() - " +
                "The requested map could not be loaded because " + err.message);
            /** @type {?} */
            let e = new Error("The requested map ('" + mapId +
                "') could not be loaded because of the following error(s): " +
                err.message);
            return Q.reject(e);
        });
    }
    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param {?} map object
     * @return {?}
     */
    loadMapFromObj(map) {
        // console.log("Loading Map Object");
        // console.log(map);
        this._mapId = map.id;
        this._mapDef = map;
        map.extent = map.extent || {};
        /** @type {?} */
        let west = isNaN(map.extent.minx) ? -179.0 : map.extent.minx * 1.0;
        /** @type {?} */
        let east = isNaN(map.extent.maxx) ? 179.0 : map.extent.maxx * 1.0;
        /** @type {?} */
        let south = isNaN(map.extent.miny) ? -89.0 : map.extent.miny * 1.0;
        /** @type {?} */
        let north = isNaN(map.extent.maxy) ? 89.0 : map.extent.maxy * 1.0;
        /** @type {?} */
        let t;
        if (west > east) {
            t = Math.min(west, east);
            east = map.extent.maxx = Math.max(west, east);
            west = map.extent.minx = t;
        }
        if (south > north) {
            t = Math.min(south, north);
            north = map.extent.maxy = Math.max(south, north);
            south = map.extent.miny = t;
        }
        //prevent out-of-bounds extents
        if (west < -180.0)
            west = -179.0;
        if (east > 180.0)
            east = 179.0;
        if (south < -90.0)
            south = -89.0;
        if (north > 90.0)
            north = 89.0;
        //set extent from loaded map
        this._defaultExtent = map.extent;
        /** @type {?} */
        var extent = map.extent;
        //remove existing layers
        this._mapInstance.eachLayer((l) => {
            this._mapInstance.removeLayer(l);
        });
        this._layerCache = {};
        this._layerStates = [];
        //set new base layer
        this.setBaseLayer(map.baseLayer);
        //add layers from loaded map
        this.addLayers(map.layers);
        //add features
        if (map.annotations && map.annotations.geoJSON) {
            /** @type {?} */
            let fc = map.annotations.geoJSON;
            if (fc.features)
                this.addFeatures(fc.features);
            else
                this.addFeatures([fc]);
        }
        this._mapInstance.fitBounds([
            [extent.miny, extent.minx],
            [extent.maxy, extent.maxx]
        ]);
        this.clean();
        this.notify('map:loaded', map);
    }
    /**
     *
     * @return {?}
     */
    destroyMap() {
        // console.log("Destroying Map");
        this._mapInstance = null;
        this._layerCache = null;
        this._layerStates = null;
        this._featureLayer = null;
    }
    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     * @param {?} mapToUse
     * @return {?}
     */
    setAsNewMap(mapToUse) {
        this._mapId = null;
        this._mapDef = mapToUse || this.initializeMapDefinition();
    }
    /**
     * @param {?} id
     * @param {?} tool
     * @return {?}
     */
    registerTool(id, tool) {
        this._tools[id] = tool;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    unregisterTool(id) {
        this._tools[id] = null;
    }
    /**
     * @param {?} id
     * @param {?} finish
     * @return {?}
     */
    enableTool(id, finish) {
        if (!this._tools[id])
            return false;
        this._tools[id].activate(function () {
            this.notify('tool:disabled', id);
        });
        this.notify('tool:enabled', id);
    }
    /**
     * @return {?}
     */
    cacheMap() {
        if (this.state && this.state.dirty) {
            /** @type {?} */
            var map = this.getMapResourceContent();
            //use exploded layer info
            map.layers = this._layerStates.slice(0);
            // $sessionStorage.map = map;
        }
    }
    /**
     * @return {?}
     */
    restoreMap() {
        // if($sessionStorage.map) {
        //     console.log("Restoring cached map");
        //     let map = $sessionStorage.map;
        //     // console.log(JSON.stringify(map));
        //     $sessionStorage.map = null;
        //     this.loadMapFromObj(map);
        // }
    }
}
if (false) {
    /** @type {?} */
    MapInstance.prototype.svcCache;
    /** @type {?} */
    MapInstance.prototype.serviceFactory;
    /** @type {?} */
    MapInstance.prototype.httpClient;
    /** @type {?} */
    MapInstance.prototype._key;
    /** @type {?} */
    MapInstance.prototype._mapId;
    /** @type {?} */
    MapInstance.prototype._mapDef;
    /** @type {?} */
    MapInstance.prototype._mapInstance;
    /** @type {?} */
    MapInstance.prototype._defaultExtent;
    /** @type {?} */
    MapInstance.prototype._baseLayerDef;
    /** @type {?} */
    MapInstance.prototype._baseLayer;
    /** @type {?} */
    MapInstance.prototype._layerStates;
    /** @type {?} */
    MapInstance.prototype._layerCache;
    /** @type {?} */
    MapInstance.prototype._layerErrors;
    /** @type {?} */
    MapInstance.prototype._layerErrorHandler;
    /** @type {?} */
    MapInstance.prototype._featureLayer;
    /** @type {?} */
    MapInstance.prototype._featureLayerVisible;
    /** @type {?} */
    MapInstance.prototype._tools;
    /** @type {?} */
    MapInstance.prototype.state;
    /** @type {?} */
    MapInstance.prototype._geoJsonLayerOpts;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5zdGFuY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZ2VvcGxhdGZvcm0vbWFwLyIsInNvdXJjZXMiOlsibWFwL2luc3RhbmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxPQUFPLEtBQUssTUFBTSxNQUFNLFFBQVEsQ0FBQzs7QUFDakMsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBRXRCLE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDO0FBRXZCLE9BQU8sRUFFSCxZQUFZLEVBQUUsT0FBTyxFQUNyQixZQUFZLEVBQWdCLFVBQVUsRUFDekMsTUFBTSxTQUFTLENBQUM7QUFFakIsT0FBTyxFQUNILE1BQU0sRUFBRSxTQUFTLEVBQ2pCLGNBQWMsRUFDZCxnQkFBZ0IsRUFDbkIsTUFBTSxvQkFBb0IsQ0FBQztBQUU1QixPQUFPLFlBQVksTUFBTSxrQkFBa0IsQ0FBQztBQUU1QyxPQUFPLGdCQUFnQixNQUFNLDRCQUE0QixDQUFDO0FBRzFEO0lBSUk7O1FBRUksSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7S0FDeEI7Ozs7OztJQUVELEVBQUUsQ0FBRSxJQUFJLEVBQUUsUUFBUTtRQUNkLElBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztZQUNyQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMvQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUN4Qzs7Ozs7O0lBRUQsR0FBRyxDQUFFLElBQUksRUFBRSxRQUFRO1FBQ2YsSUFBRyxDQUFDLElBQUk7WUFBRSxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUMvQixJQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7WUFBRSxPQUFPO1FBQ2xDLElBQUcsQ0FBQyxRQUFRO1lBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJ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QUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFDLEdBQUcsQ0FBQzs7UUFDbEUsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksR0FBQyxHQUFHLENBQUM7O1FBQ2xFLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFDLEdBQUcsQ0FBQzs7UUFHbEUsSUFBSSxDQUFDLENBQUM7UUFDTixJQUFHLElBQUksR0FBRyxJQUFJLEVBQUU7WUFDWixDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDekIsSUFBSSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzlDLElBQUksR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7U0FDOUI7UUFDRCxJQUFHLEtBQUssR0FBRyxLQUFLLEVBQUU7WUFDZCxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDM0IsS0FBSyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ2pELEtBQUssR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7U0FDL0I7O1FBR0QsSUFBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLO1lBQUUsSUFBSSxHQUFHLENBQUMsS0FB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QVE7UUFFSixJQUFHLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUU7O1lBQy9CLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDOztZQUV2QyxHQUFHLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDOztTQUUzQztLQUNKOzs7O0lBRUQsVUFBVTs7Ozs7Ozs7S0FRVDtDQUVKIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbmltcG9ydCAqIGFzIGpxdWVyeSBmcm9tIFwianF1ZXJ5XCI7XG5jb25zdCBqUXVlcnkgPSBqcXVlcnk7XG5cbmltcG9ydCAqIGFzIFEgZnJvbSBcInFcIjtcbmltcG9ydCAqIGFzIGdlb2pzb24gZnJvbSAnZ2VvanNvbic7XG5pbXBvcnQge1xuICAgIE1hcCwgTGF5ZXIsIExhdExuZywgTGF0TG5nQm91bmRzLFxuICAgIGNpcmNsZU1hcmtlciwgZ2VvSlNPTixcbiAgICBmZWF0dXJlR3JvdXAsIEZlYXR1cmVHcm91cCwgTGF5ZXJHcm91cFxufSBmcm9tICdsZWFmbGV0JztcblxuaW1wb3J0IHtcbiAgICBDb25maWcsIEl0ZW1UeXBlcyxcbiAgICBTZXJ2aWNlRmFjdG9yeSwgSXRlbVNlcnZpY2UsIE1hcFNlcnZpY2UsIExheWVyU2VydmljZSxcbiAgICBKUXVlcnlIdHRwQ2xpZW50XG59IGZyb20gJ2dlb3BsYXRmb3JtLmNsaWVudCc7XG5cbmltcG9ydCBMYXllckZhY3RvcnkgZnJvbSAnLi4vbGF5ZXIvZmFjdG9yeSc7XG5pbXBvcnQgT1NNIGZyb20gXCIuLi9sYXllci9vc21cIjtcbmltcG9ydCBEZWZhdWx0QmFzZUxheWVyIGZyb20gJy4uL2xheWVyL2Jhc2VsYXllci1kZWZhdWx0JztcblxuXG5jbGFzcyBMaXN0ZW5lciB7XG5cbiAgICBfbGlzdGVuZXJzIDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vbGlzdGVuZXJzIHRvIGJlIHVucmVnaXN0ZXJlZCB1cG9uIGRlc3Ryb3lcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuXG4gICAgb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmKCF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIG9mZiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYoIXR5cGUpIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICBpZighdGhpcy5fbGlzdGVuZXJzW3R5cGVdKSByZXR1cm47XG4gICAgICAgIGlmKCFsaXN0ZW5lcikgdGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmKGlkeCA+PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5vdGlmeSh0eXBlLCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGlmKCF0aGlzLl9saXN0ZW5lcnNbdHlwZV0pIHJldHVybjtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbihsKSB7IGwuYXBwbHkobnVsbCwgYXJncyk7IH0pO1xuICAgIH1cblxufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwSW5zdGFuY2UgZXh0ZW5kcyBMaXN0ZW5lciB7XG5cbiAgICBwcml2YXRlIHN2Y0NhY2hlICAgICAgICA6IGFueTtcbiAgICBwcml2YXRlIHNlcnZpY2VGYWN0b3J5ICA6IGFueTtcbiAgICBwcml2YXRlIGh0dHBDbGllbnQgICAgICA6IGFueTtcbiAgICBwdWJsaWMgX2tleSAgICAgICAgICAgIDogc3RyaW5nO1xuICAgIHByaXZhdGUgX21hcElkICAgICAgICAgIDogc3RyaW5nO1xuICAgIHByaXZhdGUgX21hcERlZiAgICAgICAgIDogYW55O1xuICAgIHByaXZhdGUgX21hcEluc3RhbmNlICAgIDogTWFwO1xuICAgIHByaXZhdGUgX2RlZmF1bHRFeHRlbnQgIDogYW55O1xuICAgIHByaXZhdGUgX2Jhc2VMYXllckRlZiAgIDogYW55O1xuICAgIHByaXZhdGUgX2Jhc2VMYXllciAgICAgIDogTGF5ZXI7XG4gICAgcHJpdmF0ZSBfbGF5ZXJTdGF0ZXMgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfbGF5ZXJDYWNoZSAgICAgOiBhbnk7XG4gICAgcHJpdmF0ZSBfbGF5ZXJFcnJvcnMgICAgOiBhbnlbXTtcbiAgICBwcml2YXRlIF9sYXllckVycm9ySGFuZGxlciA6IEZ1bmN0aW9uO1xuICAgIHByaXZhdGUgX2ZlYXR1cmVMYXllciAgIDogRmVhdHVyZUdyb3VwO1xuICAgIHByaXZhdGUgX2ZlYXR1cmVMYXllclZpc2libGUgIDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF90b29scyAgICAgICAgICA6IGFueVtdO1xuICAgIHByaXZhdGUgc3RhdGUgICAgICAgICAgIDogYW55O1xuICAgIHByaXZhdGUgX2dlb0pzb25MYXllck9wdHMgOiBhbnk7XG5cblxuXG5cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnNldEh0dHBDbGllbnQobmV3IEpRdWVyeUh0dHBDbGllbnQoKSk7XG4gICAgICAgIHRoaXMuc2V0U2VydmljZUZhY3RvcnkoU2VydmljZUZhY3RvcnkpO1xuXG4gICAgICAgIC8vZ2VuZXJhdGUgcmFuZG9tIGtleSAoc2VlIGZhY3RvcnkgYmVsb3cpXG4gICAgICAgIHRoaXMuX2tleSA9IGtleSB8fCBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSo5OTk5KTtcblxuICAgICAgICAvL3JlZ2lzdHJ5IGlkIG9mIGN1cnJlbnQgbWFwIGlmIGF2YWlsYWJsZVxuICAgICAgICB0aGlzLl9tYXBJZCA9IG51bGwsXG5cbiAgICAgICAgLy9kZWZpbml0aW9uIG9mIG1hcCAoaWUsIGZyb20gc2VydmVyKVxuICAgICAgICB0aGlzLl9tYXBEZWYgPSB0aGlzLmluaXRpYWxpemVNYXBEZWZpbml0aW9uKCksXG5cbiAgICAgICAgLy9wcmltYXJ5IG1hcCBpbnN0YW5jZSAoaWUsIGxlYWZsZXQpXG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlID0gbnVsbCxcblxuICAgICAgICAvL2RlZmF1bHQgbWFwIGV4dGVudCAoaWYgbWFwIGRvZXNuJ3QgaGF2ZSBvbmUgZm9yIGJlaW5nIHNhdmVkKVxuICAgICAgICB0aGlzLl9kZWZhdWx0RXh0ZW50ID0gbnVsbCxcblxuICAgICAgICAvL2N1cnJlbnQgYmFzZSBsYXllciBvYmplY3QgYW5kIGxlYWZsZXQgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyRGVmID0gbnVsbCxcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyID0gbnVsbCxcblxuICAgICAgICAvL3NldCBkZWZpbml0aW9ucyBvZiBsYXllciBzdGF0ZXMgKGluY2x1ZGluZyBsYXllciBpbmZvKSBvbiBtYXBcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBbXSxcblxuICAgICAgICAvL21hcCBsYXllciBkZWYgaWRzIHdpdGggbGVhZmxldCBpbnN0YW5jZXNcbiAgICAgICAgdGhpcy5fbGF5ZXJDYWNoZSA9IHt9LFxuXG4gICAgICAgIC8vZXJyb3JzIGdlbmVyYXRlZCBieSBsYXllcnMgbG9hZGluZ1xuICAgICAgICB0aGlzLl9sYXllckVycm9ycz0gW10sXG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE1hcEluc3RhbmNlLmRlZmF1bHRMYXllckVycm9ySGFuZGxlcigpIC0gJHtlLmlkfSA6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vbGF5ZXIgdXNlZCB0byBzdG9yZSBmZWF0dXJlcyBvbiBtYXBcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyID0gbnVsbCxcbiAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSA9IHRydWUsXG5cbiAgICAgICAgLy9zZXQgb2YgcmVnaXN0ZXJlZCBtYXAgdG9vbHNcbiAgICAgICAgdGhpcy5fdG9vbHMgPSBbXSxcblxuICAgICAgICAvL3N0YXRlIG1hbmFnZW1lbnRcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHsgZGlydHk6IGZhbHNlIH07IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICAgIHRoaXMuX2dlb0pzb25MYXllck9wdHMgID0ge1xuICAgICAgICAgICAgc3R5bGU6IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZihmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FYWNoRmVhdHVyZTogZnVuY3Rpb24oZmVhdHVyZSwgbGF5ZXIpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHsgd2VpZ2h0OiAyLCBjb2xvcjogJyMwM2YnLCBvcGFjaXR5OiAwLjksIHJhZGl1czogNCwgZmlsbENvbG9yOiAnIzAzZicsIGZpbGxPcGFjaXR5OiAwLjUgfTtcbiAgICAgICAgICAgICAgICBpZih+ZmVhdHVyZS5nZW9tZXRyeS50eXBlLmluZGV4T2YoJ1BvaW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZmlsbE9wYWNpdHkgPSAwLjk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmVhdHVyZS5wcm9wZXJ0aWVzID0gZmVhdHVyZS5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmKGZlYXR1cmUucHJvcGVydGllcy5pZCA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmUucHJvcGVydGllcy5pZCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjk5OTk5OSk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLmxhYmVsID0gcHJvcHMubGFiZWwgfHwgcHJvcHMudGl0bGUgfHwgcHJvcHMubmFtZSB8fCBcIlVudGl0bGVkIFwiICsgZmVhdHVyZS5nZW9tZXRyeS50eXBlICsgXCIgRmVhdHVyZVwiO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbiA9IHByb3BzLmRlc2NyaXB0aW9uIHx8IHByb3BzLmRlc2MgfHwgXCJUaGlzIGZlYXR1cmUgbmVlZHMgYSBkZXNjcmlwdGlvbiFcIjtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGUgPSBwcm9wcy5zdHlsZSB8fCBzdHlsZTtcblxuICAgICAgICAgICAgICAgIGxheWVyLmJpbmRUb29sdGlwKHByb3BzLmxhYmVsKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIHRvZ2dsZTogc2V0TGFiZWxOb0hpZGUoYm9vbClcbiAgICAgICAgICAgICAgICBpdCBtYXkgb25seSBleGlzdCBvbiBtYXJrZXJzIVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9pbnRUb0xheWVyOiBmdW5jdGlvbiAoZmVhdHVyZSA6IGFueSwgbGF0bG5nIDogTGF0TG5nICkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGZlYXR1cmUucHJvcGVydGllcy5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgICAgICBzdHlsZS5yYWRpdXMgPSBzdHlsZS5yYWRpdXMgfHwgNDtcbiAgICAgICAgICAgICAgICBzdHlsZS53ZWlnaHQgPSBzdHlsZS53ZWlnaHQgfHwgMjtcbiAgICAgICAgICAgICAgICBzdHlsZS5jb2xvciA9IHN0eWxlLmNvbG9yIHx8ICcjMDNmJztcbiAgICAgICAgICAgICAgICBzdHlsZS5vcGFjaXR5ID0gc3R5bGUub3BhY2l0eSB8fCAwLjk7XG4gICAgICAgICAgICAgICAgc3R5bGUuZmlsbE9wYWNpdHkgPSBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIHN0eWxlLmZpbGxDb2xvciA9IHN0eWxlLmNvbG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaXJjbGVNYXJrZXIobGF0bG5nLCBzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZGlzcG9zZSAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveU1hcCgpO1xuICAgICAgICB0aGlzLnN2Y0NhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlRmFjdG9yeSA9IG51bGw7XG4gICAgICAgIHRoaXMuaHR0cENsaWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2tleSA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWZhdWx0RXh0ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyRGVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllckNhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvcnM9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl90b29scyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9nZW9Kc29uTGF5ZXJPcHRzID0gbnVsbDtcbiAgICB9XG5cblxuICAgIGdldEtleSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZGVmYXVsdCAoSlF1ZXJ5LWJhc2VkKSBtYXAgc2VydmljZSB1c2VkIGJ5IHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gbWFwU2VydmljZSAtIHNlcnZpY2UgdG8gdXNlIHRvIENSVUQgbWFwIG9iamVjdHNcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2Ugc2V0U2VydmljZUZhY3RvcnkgaW5zdGVhZFxuICAgICAqL1xuICAgIHNldFNlcnZpY2UobWFwU2VydmljZSA6IE1hcFNlcnZpY2UpIHtcbiAgICAgICAgLy8gdGhpcy5tYXBTZXJ2aWNlID0gbWFwU2VydmljZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmFjdG9yeSAtIEdlb1BsYXRmb3JtIFNlcnZpY2VGYWN0b3J5IHRvIGluc3RhbnRpYXRlIHNlcnZpY2VzIGZvciBtYXBzIGFuZCBsYXllcnNcbiAgICAgKi9cbiAgICBzZXRTZXJ2aWNlRmFjdG9yeShmYWN0b3J5IDogYW55KSB7XG4gICAgICAgIHRoaXMuc3ZjQ2FjaGUgPSB7fTsgLy93aXBlIG91dCBjYWNoZWQgc2VydmljZXNcbiAgICAgICAgdGhpcy5zZXJ2aWNlRmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGh0dHBDbGllbnQgLSBIdHRwQ2xpZW50IGltcGwgdG8gdXNlIHdpdGggdGhlIG5ldyBmYWN0b3J5XG4gICAgICovXG4gICAgc2V0SHR0cENsaWVudChodHRwQ2xpZW50IDogYW55KSB7XG4gICAgICAgIHRoaXMuc3ZjQ2FjaGUgPSB7fTsgLy93aXBlIG91dCBjYWNoZWQgc2VydmljZXNcbiAgICAgICAgdGhpcy5odHRwQ2xpZW50ID0gaHR0cENsaWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdHlwZSAtIEdlb1BsYXRmb3JtIE9iamVjdCBtb2RlbCB0eXBlIHRvIHN1cHBvcnQgKFwiTWFwXCIsIFwiTGF5ZXJcIiwgZXRjKVxuICAgICAqIEByZXR1cm4gaXRlbSBzZXJ2aWNlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgcmVxdWVzdGVkIHR5cGVcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlKHR5cGUgOiBzdHJpbmcpIDogSXRlbVNlcnZpY2Uge1xuICAgICAgICBpZighdGhpcy5zdmNDYWNoZVt0eXBlXSlcbiAgICAgICAgICAgIHRoaXMuc3ZjQ2FjaGVbdHlwZV0gPSB0aGlzLnNlcnZpY2VGYWN0b3J5KHR5cGUsIENvbmZpZy51YWxVcmwsIHRoaXMuaHR0cENsaWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN2Y0NhY2hlW3R5cGVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbiAtIGNhbGxiYWNrIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWRcbiAgICAgKi9cbiAgICBzZXRFcnJvckhhbmRsZXIoZm4pIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJFcnJvckhhbmRsZXIgPSBmbjtcbiAgICB9XG5cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBnZXRMYXllclN0YXRlSW5kZXggKGxheWVySWQpIHtcbiAgICAgICAgaWYoIWxheWVySWQpIHJldHVybiAtMTtcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8dGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuX2xheWVyU3RhdGVzW2ldLmxheWVyICYmIGxheWVySWQgPT09IHRoaXMuX2xheWVyU3RhdGVzW2ldLmxheWVyLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5fbGF5ZXJTdGF0ZXMuaW5kZXhPZk9iaihsYXllcklkLCAoaWQsIHN0YXRlKSA9PiBzdGF0ZS5sYXllci5pZCA9PT0gaWQgKTtcbiAgICB9XG5cbiAgICBnZXRMYXllclN0YXRlIChsYXllcklkKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZUluZGV4KGxheWVySWQpO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IHRoaXMuX2xheWVyU3RhdGVzW2luZGV4XSA6IG51bGw7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgaW5pdGlhbGl6ZU1hcERlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBJdGVtVHlwZXMuTUFQLFxuICAgICAgICAgICAgdGl0bGU6IFwiTXkgTmV3IE1hcFwiLFxuICAgICAgICAgICAgbGFiZWw6IFwiTXkgTmV3IE1hcFwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhpcyBtYXAgbmVlZHMgYSBkZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgY3JlYXRlZEJ5OiBudWxsLFxuICAgICAgICAgICAgYmFzZUxheWVyOiB0aGlzLl9iYXNlTGF5ZXJEZWYsXG4gICAgICAgICAgICBsYXllcnM6IFtdLFxuICAgICAgICAgICAga2V5d29yZHM6IFtdLFxuICAgICAgICAgICAgdGhlbWVzOiBbXSxcbiAgICAgICAgICAgIHJlc291cmNlVHlwZXM6IFsnaHR0cDovL3d3dy5nZW9wbGF0Zm9ybS5nb3Yvb250L29wZW5tYXAvR2VvcGxhdGZvcm1NYXAnXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIG9iamVjdCBkZWZpbml0aW9uIG9mIHRoZSBjdXJyZW50IG1hcCBzdWl0YWJsZSBmb3Igc2VuZGluZyB0byBXTVZSXG4gICAgICovXG4gICAgZ2V0TWFwUmVzb3VyY2VDb250ZW50KG1ldGFkYXRhID86IGFueSkge1xuXG4gICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGEgfHwge307XG5cbiAgICAgICAgLy9tYXAgbGF5ZXJzXG4gICAgICAgIG1ldGFkYXRhLmxheWVycyA9IHRoaXMuX2xheWVyU3RhdGVzLnNsaWNlKDApO1xuICAgICAgICAvLyAuLi4gVUFMIHNob3VsZCBzdXBwb3J0IGFjY2VwdGluZyBqdXN0IGFuIGlkIGhlcmUsIHNvIHdlJ2xsIGRvIGp1c3QgdGhhdFxuICAgICAgICBtZXRhZGF0YS5iYXNlTGF5ZXIgPSB0aGlzLl9iYXNlTGF5ZXJEZWY7XG5cbiAgICAgICAgbWV0YWRhdGEuYW5ub3RhdGlvbnMgPSB0aGlzLl9mZWF0dXJlTGF5ZXIgP1xuICAgICAgICAgICAgeyB0aXRsZTogXCJNYXAgRmVhdHVyZXNcIiwgZ2VvSlNPTjogdGhpcy5fZmVhdHVyZUxheWVyLnRvR2VvSlNPTigpIH0gOiBudWxsO1xuXG4gICAgICAgIC8vZ2VvZ3JhcGhpYyBleHRlbnRcbiAgICAgICAgbGV0IGV4dGVudCA9IHRoaXMuX21hcEluc3RhbmNlLmdldEJvdW5kcygpO1xuICAgICAgICBtZXRhZGF0YS5leHRlbnQgPSB7XG4gICAgICAgICAgICBtaW54OiBleHRlbnQuZ2V0V2VzdCgpLFxuICAgICAgICAgICAgbWlueTogZXh0ZW50LmdldFNvdXRoKCksXG4gICAgICAgICAgICBtYXh4OiBleHRlbnQuZ2V0RWFzdCgpLFxuICAgICAgICAgICAgbWF4eTogZXh0ZW50LmdldE5vcnRoKClcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBMZWFmbGV0IHRvb2xiYXJcbiAgICAgKi9cbiAgICBnZXREcmF3Q29udHJvbFRvb2xiYXIoKSB7XG4gICAgICAgIGlmKCEodGhpcy5fbWFwSW5zdGFuY2UgYXMgYW55KS5kcmF3Q29udHJvbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciB0b29sYmFycyA9ICh0aGlzLl9tYXBJbnN0YW5jZSBhcyBhbnkpLmRyYXdDb250cm9sLl90b29sYmFycztcbiAgICAgICAgdmFyIHRvb2xiYXIgPSBudWxsO1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0b29sYmFycykge1xuICAgICAgICAgICAgaWYodG9vbGJhcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmKHRvb2xiYXJzW2tleV0uX21vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXIgPSB0b29sYmFyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvb2xiYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGVycm9yIExlYWZsZXQgdGlsZSBsb2FkIGVycm9yICgudGFyZ2V0IGlzIGxheWVyLCAudGlsZSBpcyBpbWFnZSlcbiAgICAgKi9cbiAgICBoYW5kbGVMYXllckVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UuaGFuZGxlTGF5ZXJFcnJvcigpIC0gXCIgK1xuICAgICAgICAvLyAgICAgXCJMYXllcidzIHRpbGUgZmFpbGVkIHRvIGxvYWQ6IFwiICsgZXJyb3IudGlsZS5zcmMpO1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmFibGUgdG8gZmluZCBsYXllciBpbiBsYXllciBjYWNoZS4gTGF5ZXIgZXJyb3IgaXMgXCIgKyBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxheWVyID0gZXJyb3IudGFyZ2V0O1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuX2xheWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuX2xheWVyQ2FjaGVbaWRdID09PSBsYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xheWVyRXJyb3IoZXJyb3IsIGlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgTGVhZmxldCB0aWxlIGxvYWQgZXJyb3IgYW5kIHRoZSByZXNwb25zaWJsZSBsYXllciBpZCxcbiAgICAgKiBUcnkgdG8gaXNvbGF0ZSB0aGUgY2F1c2Ugb2YgdGhlIGVycm9yIHVzaW5nIHRoZSBwcm94eVxuICAgICAqIGFuZCBub3RpZnkgbGlzdGVuZXJzIHRoYXQgYW4gZXJyb3IgaGFzIG9jY3VycmVkXG4gICAgICovXG4gICAgcHJvY2Vzc0xheWVyRXJyb3IoZXJyb3IgOiBFcnJvciwgaWQgOiBzdHJpbmcpIHtcblxuICAgICAgICB2YXIgZmluZGVyID0gKGwpID0+IHsgcmV0dXJuIGwuaWQgPT09IGlkIHx8IChsLmxheWVyICYmIGwubGF5ZXIuaWQgPT09IGlkKTsgfTtcblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJFcnJvcnMuZmluZChmaW5kZXIpKSB7XG5cbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLmxvZ0xheWVyRXJyb3IoaWQsIFwiTGF5ZXIgKCdcIiArIGlkICsgXCInKSBmYWlsZWQgdG8gY29tcGxldGVseSBsb2FkLiBcIiArXG4gICAgICAgICAgICAgICAgXCJJdCBtYXkgYmUgaW5hY2Nlc3NpYmxlIG9yIG1pc2NvbmZpZ3VyZWQuXCIpO1xuXG4gICAgICAgICAgICB2YXIgdXJsID0gKGVycm9yIGFzIGFueSkudGlsZS5zcmM7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge2lkOmlkfTtcbiAgICAgICAgICAgIHVybC5zdWJzdHJpbmcodXJsLmluZGV4T2YoXCI/XCIpKzEsIHVybC5sZW5ndGgpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcGFyYW0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICBwYXJhbXNbcFswXV0gPSBwWzFdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxldCBsYXllclNlcnZpY2UgPSB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLkxBWUVSKTtcbiAgICAgICAgICAgIGlmKGxheWVyU2VydmljZSkge1xuICAgICAgICAgICAgICAgIGxheWVyU2VydmljZS52YWxpZGF0ZShpZCwgcGFyYW1zKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2xheWVyU3RhdGVzLmZpbmQoZmluZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoubWVzc2FnZSA9IFwiTGF5ZXIgJ1wiICsgZGVmLmxheWVyLmxhYmVsICsgXCInIGZhaWxlZCB0byBjb21wbGV0ZWx5IGxvYWQuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJSZXBvcnRlZCBjYXVzZTogXCIgKyBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ2xheWVyOmVycm9yJywgb2JqKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsYXllcklkIC0gaWRlbnRpZmllciBvZiBsYXllciBnZW5lcmF0aW5nIHRoZSBlcnJvclxuICAgICAqIEBwYXJhbSBlcnJvck1zZyAtIG1lc3NhZ2Ugb2YgdGhlIGVycm9yXG4gICAgICovXG4gICAgbG9nTGF5ZXJFcnJvcihsYXllcklkLCBlcnJvck1zZykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmxvZ0xheWVyRXJyb3IoKSAtIGxheWVyIFwiICArIGlkICtcbiAgICAgICAgLy8gICAgIFwiIGdlbmVyYXRlZCBlcnJvciAnXCIgKyBlcnJvck1zZyArIFwiJ1wiKTtcbiAgICAgICAgbGV0IGVyciA9IHsgaWQ6IGxheWVySWQsIG1lc3NhZ2U6IGVycm9yTXNnIH07XG4gICAgICAgIHRoaXMuX2xheWVyRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgaWYodGhpcy5fbGF5ZXJFcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyRXJyb3JIYW5kbGVyKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICAvKiAtLSBTdGF0ZSBNYW5hZ2VtZW50IG9mIGludGVybmFsIG1vZGVsIC0tICovXG5cbiAgICB0b3VjaCAoZXZlbnQgPzogYW55LCAuLi5vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZGlydHkgPSB0cnVlO1xuICAgICAgICBpZihldmVudCkge1xuICAgICAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KGV2ZW50KTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRGlydHlpbmcgbWFwIGZvciBcIiArIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGNvbnNvbGUubG9nKFwiRGlydHlpbmcgbWFwXCIpO1xuICAgIH1cbiAgICBjbGVhbigpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJDbGVhbmluZyBtYXBcIik7XG4gICAgICAgIHRoaXMuc3RhdGUuZGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIE1hcCBtYW5pcHVsYXRpb24gb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIHNldE1hcCAobWFwIDogTWFwKSB7IHRoaXMuX21hcEluc3RhbmNlID0gbWFwOyB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuICBtYXAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRNYXAgKCkgOiBNYXAgeyByZXR1cm4gdGhpcy5fbWFwSW5zdGFuY2U7IH1cblxuICAgIC8qKiBAcmV0dXJuIGRlZmluaXRpb24gb2YgbWFwICovXG4gICAgZ2V0TWFwRGVmaW5pdGlvbiAoKSA6IGFueSB7IHJldHVybiB0aGlzLl9tYXBEZWY7IH1cblxuICAgIC8qKiBAcmV0dXJuIGlkZW50aWZpZXIgb2YgbWFwICovXG4gICAgZ2V0TWFwSWQgKCkgOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fbWFwSWQ7IH1cblxuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIG1hcCBvbiB0aGUgc3BlY2lmaWVkIGxhdC9sbmcgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSBsYXQgbnVtYmVyXG4gICAgICogQHBhcmFtIGxuZyBudW1iZXJcbiAgICAgKiBAcGFyYW0gem9vbSBudW1iZXIgKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIHNldFZpZXcgKGxhdCA6IG51bWJlciwgbG5nIDogbnVtYmVyLCB6b29tID86IG51bWJlcikge1xuICAgICAgICBsZXQgeiA9IHpvb207XG4gICAgICAgIGlmKHR5cGVvZih6KSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB6ID0gdGhpcy5fbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5zZXRWaWV3KFtsYXQsbG5nXSwgeik7XG4gICAgICAgIHRoaXMudG91Y2goJ21hcDp2aWV3OmNoYW5nZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBjZW50ZXIgb2YgdGhlIG1hcFxuICAgICAqIEByZXR1cm4gW2xhdCxsbmddXG4gICAgICovXG4gICAgZ2V0VmlldyAoKSA6IG51bWJlcltdIHtcbiAgICAgICAgdmFyIGxhdExuZyA9IHRoaXMuX21hcEluc3RhbmNlLmdldENlbnRlcigpO1xuICAgICAgICByZXR1cm4gW2xhdExuZy5sYXQsIGxhdExuZy5sbmddO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gaW50ZWdlciBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcFxuICAgICAqL1xuICAgIGdldFpvb20gKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwSW5zdGFuY2UuZ2V0Wm9vbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFpvb20gdG8gdGhlIG1hcCdzIGRlZmF1bHQgZXh0ZW50XG4gICAgICogSWYgdGhlIG1hcCBpcyBzYXZlZCwgdGhpcyB3aWxsIGJlIHRoZSBzYXZlZCB2aWV3cG9ydFxuICAgICAqIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBDT05VU1xuICAgICAqL1xuICAgIHpvb21Ub0RlZmF1bHQgKCkge1xuICAgICAgICBpZighdGhpcy5fbWFwSW5zdGFuY2UpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5fZGVmYXVsdEV4dGVudCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKFtcbiAgICAgICAgICAgICAgICBbdGhpcy5fZGVmYXVsdEV4dGVudC5taW55LCB0aGlzLl9kZWZhdWx0RXh0ZW50Lm1pbnhdLFxuICAgICAgICAgICAgICAgIFt0aGlzLl9kZWZhdWx0RXh0ZW50Lm1heHksIHRoaXMuX2RlZmF1bHRFeHRlbnQubWF4eF1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS56b29tVG9EZWZhdWx0KCkgLSBObyBkZWZhdWx0IGV4dGVudCBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5zZXRWaWV3KFszOCwgLTk2XSwgNSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ21hcDp2aWV3OmNoYW5nZWQnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7IH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXh0ZW50IC0gZWl0aGVyIGEgR1AgZXh0ZW50IG9iamVjdCBvciBMZWFmbGV0IExhdExuZ0JvdW5kcyBvYmplY3RcbiAgICAgKi9cbiAgICBzZXRFeHRlbnQoZXh0ZW50IDogTGF0TG5nQm91bmRzfGFueSkge1xuICAgICAgICBpZighZXh0ZW50KSByZXR1cm47XG4gICAgICAgIGlmKCB0eXBlb2YoZXh0ZW50Lm1pbngpICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mKGV4dGVudC5taW55KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZihleHRlbnQubWF4eCkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YoZXh0ZW50Lm1heHkpICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgIC8vR1AgbW9kZWwgZXh0ZW50XG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoW1xuICAgICAgICAgICAgICAgIFtleHRlbnQubWlueSwgZXh0ZW50Lm1pbnhdLFxuICAgICAgICAgICAgICAgIFtleHRlbnQubWF4eSwgZXh0ZW50Lm1heHhdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZihleHRlbnQuZ2V0V2VzdCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvL0wuTGF0TG5nQm91bmRzXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5maXRCb3VuZHMoZXh0ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIExheWVyIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsYXllciBMZWFmbGV0IExheWVyIGluc3RhbmNlIG9yIG9iamVjdCBkZWZpbml0aW9uXG4gICAgICovXG4gICAgc2V0QmFzZUxheWVyIChsYXllciA6IGFueSkge1xuXG4gICAgICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgaWYoIWxheWVyKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gRGVmYXVsdEJhc2VMYXllci5nZXQodGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5MQVlFUikpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHByb21pc2UgPSBRLnJlc29sdmUobGF5ZXIpO1xuXG4gICAgICAgIHByb21pc2UudGhlbiggbGF5ZXIgPT4ge1xuXG4gICAgICAgICAgICBsZXQgbGVhZmxldExheWVyID0gTGF5ZXJGYWN0b3J5LmNyZWF0ZShsYXllcik7XG4gICAgICAgICAgICBpZighbGVhZmxldExheWVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXYXJuaW5nOiBNYXBJbnN0YW5jZSBjb3VsZCBub3QgY3JlYXRlIGJhc2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImxheWVyIGZvciAnXCIgKyBsYXllci5pZCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmFkZExheWVyKGxlYWZsZXRMYXllcik7XG5cbiAgICAgICAgICAgIChsZWFmbGV0TGF5ZXIgYXMgYW55KS5zZXRaSW5kZXgoMCk7ICAvL3NldCBhdCBib3R0b21cblxuICAgICAgICAgICAgbGV0IG9sZEJhc2VMYXllciA9IHRoaXMuX2Jhc2VMYXllcjtcbiAgICAgICAgICAgIGlmKG9sZEJhc2VMYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcEluc3RhbmNlLnJlbW92ZUxheWVyKG9sZEJhc2VMYXllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vcmVtZW1iZXIgbmV3IGJhc2UgbGF5ZXJcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VMYXllciA9IGxlYWZsZXRMYXllcjtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VMYXllckRlZiA9IGxheWVyO1xuXG4gICAgICAgICAgICAvL3dpbGwgbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnYmFzZWxheWVyOmNoYW5nZWQnLCBsYXllciwgbGVhZmxldExheWVyKTtcbiAgICAgICAgICAgIC8vIHRoaXMubm90aWZ5KCdiYXNlbGF5ZXI6Y2hhbmdlZCcsIGxheWVyLCBsZWFmbGV0TGF5ZXIpO1xuXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBNYXBJbnN0YW5jZS5zZXRCYXNlTGF5ZXIoKSAtIEVycm9yIGdldHRpbmcgYmFzZSBsYXllciBmb3IgbWFwIDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB0aGlzLmxvZ0xheWVyRXJyb3IoIGxheWVyLmlkLCBcIkVycm9yIHNldHRpbmcgYmFzZWxheWVyIG9uIG1hcCBcIiArXG4gICAgICAgICAgICAgICAgXCJiZWNhdXNlIG9mIHRoZSBmb2xsb3dpbmcgZXJyb3Iocyk6IFwiICsgZS5tZXNzYWdlICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gYXJyYXkgb2YgYmFzZSBsYXllcnMgZGVmaW5pdGlvbnMgdGhhdCBjYW4gYmUgdXNlZFxuICAgICAqL1xuICAgIC8vIGdldEJhc2VMYXllck9wdGlvbnMgKCkge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5fYmFzZUxheWVyT3B0aW9ucztcbiAgICAvLyB9LFxuXG4gICAgZ2V0QmFzZUxheWVyICgpIDogYW55IHsgcmV0dXJuIHRoaXMuX2Jhc2VMYXllckRlZjsgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBsaXN0IG9mIGxheWVyIHN0YXRlcyBjb250YWluaW5nIGxheWVyIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgZ2V0TGF5ZXJzICgpIDogYW55W10geyByZXR1cm4gdGhpcy5fbGF5ZXJTdGF0ZXM7IH1cblxuICAgIGdldExheWVyRXJyb3JzICgpIDogYW55W10geyByZXR1cm4gdGhpcy5fbGF5ZXJFcnJvcnM7IH1cblxuICAgIGNsZWFyTGF5ZXJFcnJvcnMgKCkge1xuICAgICAgICB0aGlzLl9sYXllckVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGF5ZXI6ZXJyb3InKTtcbiAgICB9XG5cbiAgICBjbGVhck92ZXJsYXlzICgpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcbiAgICAgICAgZm9yKHZhciBpPXRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aC0xOyBpPj0wOyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2xheWVyU3RhdGVzW2ldO1xuICAgICAgICAgICAgdmFyIGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlW3N0YXRlLmxheWVyLmlkXTtcbiAgICAgICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLm9mZihcImxheWVyOmVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyQ2FjaGVbc3RhdGUubGF5ZXIuaWRdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5yZW1vdmVMYXllcihsYXllckluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnRvdWNoKCdsYXllcnM6Y2hhbmdlZCcpO1xuXG4gICAgICAgIC8vVE9ETyBzdG9wIGxpc3RlbmluZyBmb3IgbGF5ZXIgZXZlbnRzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGxheWVycyAtIGxpc3Qgb2YgbGF5ZXJzIChOT1RFOiBub3Qgd3JhcHBlZCBieSBsYXllciBzdGF0ZXMsIHRoaXMgbWV0aG9kIGFwcGxpZXMgdGhhdClcbiAgICAgKi9cbiAgICBhZGRMYXllcnMgKGxheWVycyA6IGFueXxhbnlbXSApIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTjogYXR0ZW1wdGluZyB0byBhZGQgbGF5ZXJzIHRvIGFuIGVtcHR5IGNhY2hlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTjogQXR0ZW1wdGluZyB0byBhZGQgbGF5ZXJzIHRvIGEgbWFwIHdpdGggbm8gbGF5ZXIgY2FjaGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZighbGF5ZXJzKSByZXR1cm47XG4gICAgICAgIGlmKHR5cGVvZihsYXllcnMucHVzaCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsYXllcnMgPSBbbGF5ZXJzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheWVycy5mb3JFYWNoKCAob2JqLGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBsYXllciA9IG51bGwsIHN0YXRlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYob2JqLnR5cGUgJiYgb2JqLnR5cGU9PT1JdGVtVHlwZXMuTEFZRVIpIHsgLy9pcyBhIGxheWVyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBvYmo7XG4gICAgICAgICAgICB9IGVsc2UgaWYob2JqLmxheWVyKSB7ICAvL2lzIGxheWVyIHN0YXRlXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBvYmoubGF5ZXI7ICAvLyBjb250YWluaW5nIGEgbGF5ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IG9iajtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWxheWVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5hZGRMYXllcnMoKSAtIGxheWVyIChcIiArIGluZGV4ICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIGlzIG5vdCBhIExheWVyIG9yIGEgTGF5ZXIgc3RhdGUuIElnbm9yaW5nLi4uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgIC8vbGF5ZXIgaW5mbyBpcyBtaXNzaW5nLCBza2lwIGl0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vRFQtNDQyIHByZXZlbnQgYWRkaW5nIGxheWVyIHRoYXQgYWxyZWFkeSBleGlzdHMgb24gbWFwXG4gICAgICAgICAgICBpZih0aGlzLl9sYXllckNhY2hlW2xheWVyLmlkXSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZighc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvL3dyYXBwZWQgaW4gdHJ5e31jYXRjaCBiZWNhdXNlIGxheWVyIG1heSBjb250YWluIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3aWxsIGNhdXNlIGVycm9yIHdoZW4gdXNlZCBieSBKU09OIG1ldGhvZHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheWVyQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobGF5ZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiBsYXllckNvcHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGFkZCBsYXllciB0byBtYXAgYmVjYXVzZSBvZiBcIiArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeiA9IGxheWVycy5sZW5ndGggLSBpbmRleDtcbiAgICAgICAgICAgIHN0YXRlLnpJbmRleCA9IHo7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkTGF5ZXJXaXRoU3RhdGUobGF5ZXIsIHN0YXRlKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRvdWNoKCdsYXllcnM6Y2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsYXllciAtIEdlb1BsYXRmb3JtIExheWVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHN0YXRlIC0gR2VvUGxhdGZvcm0gTGF5ZXIgU3RhdGVcbiAgICAgKi9cbiAgICBhZGRMYXllcldpdGhTdGF0ZShsYXllciwgc3RhdGUpIHtcblxuICAgICAgICB2YXIgbGVhZmxldExheWVyID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmKCFsYXllciB8fCAhc3RhdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCwgbWlzc2luZyBsYXllciBhbmQgb3Igc3RhdGVcIik7XG5cbiAgICAgICAgICAgIGxlYWZsZXRMYXllciA9IExheWVyRmFjdG9yeS5jcmVhdGUobGF5ZXIpO1xuICAgICAgICAgICAgaWYoIWxlYWZsZXRMYXllcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgbGVhZmxldCBsYXllciBmb3IgR1AgTGF5ZXIgJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuaWQgKyBcIidcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ0xheWVyRXJyb3IoIGxheWVyLmlkLFxuICAgICAgICAgICAgICAgIFwiTGF5ZXIgJ1wiICsgbGF5ZXIubGFiZWwgKyBcIicgY291bGQgbm90IGJlIGFkZGVkIHRvIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgXCJtYXAgaW5zdGFuY2U7IFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFsZWFmbGV0TGF5ZXIpIHJldHVybjtcblxuICAgICAgICAvL2NhY2hlIGxlYWZsZXQgb2JqZWN0IGZpcnN0XG4gICAgICAgIGlmKHRoaXMuX2xheWVyQ2FjaGUpIHRoaXMuX2xheWVyQ2FjaGVbbGF5ZXIuaWRdID0gbGVhZmxldExheWVyO1xuXG4gICAgICAgIC8vbGlzdGVuIGZvciBsYXllciBlcnJvcnMgc28gd2UgY2FuIGluZm9ybSB0aGUgdXNlclxuICAgICAgICAvLyB0aGF0IGEgbGF5ZXIgaGFzbid0IGJlZW4gbG9hZGVkIGluIGEgdXNlZnVsIHdheVxuICAgICAgICBsZWFmbGV0TGF5ZXIub24oJ3RpbGVlcnJvcicsIChlKSA9PiB7IHRoaXMuaGFuZGxlTGF5ZXJFcnJvcihlKTsgfSk7XG5cbiAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuYWRkTGF5ZXIobGVhZmxldExheWVyKTtcblxuICAgICAgICBpZiggIWlzTmFOKHN0YXRlLnpJbmRleCkgJiYgbGVhZmxldExheWVyLnNldFpJbmRleCApXG4gICAgICAgICAgICBsZWFmbGV0TGF5ZXIuc2V0WkluZGV4KHN0YXRlLnpJbmRleCk7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMucHVzaChzdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xheWVyOmFkZGVkJywgbGF5ZXIsIGxlYWZsZXRMYXllcik7XG5cblxuICAgICAgICAvLyBpZiBsYXllciBpcyBpbml0aWFsbHkgXCJvZmZcIiBvci4uLlxuICAgICAgICAvLyBpZiBsYXllciBpcyBpbml0aWFsbHkgbm90IDEwMCUgb3BhcXVlXG4gICAgICAgIGlmKCFzdGF0ZS52aXNpYmlsaXR5IHx8IHN0YXRlLm9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIGxheWVyIHZpc2liaWxpdHkgYW5kIG9wYWNpdHkgYXN5bmMsIG9yIGVsc2VcbiAgICAgICAgICAgIC8vIHNvbWUgb2YgdGhlIGxheWVycyB3b24ndCBnZXQgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoIChsYXllciwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExheWVyVmlzaWJpbGl0eShsYXllciwgc3RhdGUudmlzaWJpbGl0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMYXllck9wYWNpdHkobGF5ZXIsIHN0YXRlLm9wYWNpdHkpO1xuICAgICAgICAgICAgICAgIC8vVE9ETyBub3RpZnkgb2YgY2hhbmdlXG5cbiAgICAgICAgICAgICAgICAvL0RULTIxMDIgdGltZW91dCBuZWVkcyB0byBiZSBsYXJnZSBlbm91Z2ggb3IgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGZlYXR1cmUgbGF5ZXJzIHdvbid0IGdldCBvcGFjaXR5IHVwZGF0ZWQgb24gbWFwIGxvYWRcbiAgICAgICAgICAgIH0sIDIwMDAsIGxlYWZsZXRMYXllciwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZyb20gLSBwb3NpdGlvbiBvZiBsYXllciBiZWluZyBtb3ZlZFxuICAgICAqIEBwYXJhbSB0byAtIGRlc2lyZWQgcG9zaXRpb24gdG8gbW92ZSBsYXllciB0b1xuICAgICAqL1xuICAgIG1vdmVMYXllciAoZnJvbSA6IG51bWJlciwgdG8gOiBudW1iZXIpIHtcbiAgICAgICAgaWYoIXRoaXMuX2xheWVyQ2FjaGUpIHJldHVybjtcblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmKGlzTmFOKGZyb20pKSByZXR1cm47XG5cbiAgICAgICAgLy9lbmQgb2YgbGlzdFxuICAgICAgICBpZihpc05hTih0bykpIHRvID0gdGhpcy5fbGF5ZXJTdGF0ZXMubGVuZ3RoLTE7XG5cbiAgICAgICAgbGV0IGNvcHkgPSB0aGlzLl9sYXllclN0YXRlcy5zcGxpY2UoZnJvbSwgMSlbMF07ICAgIC8vZ3JhYiBsYXllciBiZWluZyBtb3ZlZFxuICAgICAgICB0aGlzLl9sYXllclN0YXRlcy5zcGxpY2UodG8sIDAsIGNvcHkpO1xuXG4gICAgICAgIGZvcihsZXQgej0xLCBpPXRoaXMuX2xheWVyU3RhdGVzLmxlbmd0aC0xOyBpPj0wOyAtLWksKyt6KSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXJTdGF0ZSA9IHRoaXMuX2xheWVyU3RhdGVzW2ldO1xuICAgICAgICAgICAgbGV0IGxheWVySW5zdGFuY2UgPSB0aGlzLl9sYXllckNhY2hlWyBsYXllclN0YXRlLmxheWVyLmlkIF07XG4gICAgICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5zZXRaSW5kZXgoeik7XG4gICAgICAgICAgICAgICAgbGF5ZXJTdGF0ZS56SW5kZXggPSB6O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b3VjaCgnbGF5ZXJzOmNoYW5nZWQnLCB0aGlzLmdldExheWVycygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUxheWVyIChpZCkge1xuXG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtpZF07XG4gICAgICAgIGlmKGxheWVySW5zdGFuY2UpIHtcblxuICAgICAgICAgICAgLy9yZW1vdmUgbGF5ZXIgZnJvbSB0cmFja2VkIGRlZnMgYXJyYXlcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZUluZGV4KGlkKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIoXCIgKyBpZCArIFwiKVwiKTtcbiAgICAgICAgICAgIGlmKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9sYXllclN0YXRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJTdGF0ZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgLy9zdG9wIGxpc3RlbmluZyBmb3IgZXJyb3JzXG4gICAgICAgICAgICBsYXllckluc3RhbmNlLm9mZihcImxheWVyOmVycm9yXCIpO1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBsYXllciBmcm9tIG1hcFxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIobGF5ZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGxheWVyIGZyb20gY2FjaGVcbiAgICAgICAgICAgIHRoaXMuX2xheWVyQ2FjaGVbaWRdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoKCdsYXllcnM6Y2hhbmdlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlTGF5ZXJWaXNpYmlsaXR5IChpZCkge1xuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbaWRdO1xuICAgICAgICBpZihsYXllckluc3RhbmNlKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoaWQpO1xuICAgICAgICAgICAgc3RhdGUudmlzaWJpbGl0eSA9ICFzdGF0ZS52aXNpYmlsaXR5O1xuXG4gICAgICAgICAgICBpZihsYXllckluc3RhbmNlLl9jdXJyZW50SW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAvL0VTUkkgSW1hZ2UgU2VydmljZSBsYXllcnMgaGF2ZSBhbiBJTUcgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgZ2V0cyBtb2RpZmllZCBhbmQgcmVwbGFjZWQgZXZlcnkgbWFwIGV2ZW50ICh6b29tL3BhbilcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4ndCBqdXN0IHRvZ2dsZSBjbGFzc2VzIGxpa2Ugb24gb3RoZXIgbGF5ZXJzLlxuICAgICAgICAgICAgICAgIC8vSW5zdGVhZCwgd2UgbmVlZCB0byB1c2UgdGhlIEVTUkkgc2V0T3BhY2l0eSBtZXRob2QgdG8gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLy8gYnV0IG5lZWQgdG8gdXBkYXRlIGxheWVyIHN0YXRlIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5zZXRPcGFjaXR5KHN0YXRlLnZpc2liaWxpdHkgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgc3RhdGUub3BhY2l0eSA9IGxheWVySW5zdGFuY2UuZ2V0T3BhY2l0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRMYXllclZpc2liaWxpdHkobGF5ZXJJbnN0YW5jZSwgc3RhdGUudmlzaWJpbGl0eSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHVwZGF0ZSBsYXllciBkZWZpbml0aW9uIHN0YXRlLiBVc2VcbiAgICAgKiBNYXBJbnN0YW5jZS50b2dnbGVMYXllclZpc2liaWxpdHkgdG8gZG8gdGhhdCBhbmQgYWRqdXN0XG4gICAgICogcmVuZGVyZWQgbGF5ZXIncyB2aXNpYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVySW5zdGFuY2UgLSBsZWFmbGV0IGxheWVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBmbGFnIGluZGljYXRpbmcgdmlzaWJpbGl0eSBvZiBsYXllclxuICAgICAqL1xuICAgIHNldExheWVyVmlzaWJpbGl0eSAobGF5ZXJJbnN0YW5jZSA6IExheWVyLCB2aXNpYmxlIDogYm9vbGVhbikge1xuXG4gICAgICAgIGlmKChsYXllckluc3RhbmNlIGFzIGFueSkuc2V0VmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgLy91c2luZyBjdXN0b20gbWV0aG9kIHByb3ZpZGVkIGluIHNyYy9sYXllci9tb2R1bGUuanNcbiAgICAgICAgICAgIChsYXllckluc3RhbmNlIGFzIGFueSkuc2V0VmlzaWJpbGl0eSh2aXNpYmxlKTtcblxuICAgICAgICB9IGVsc2UgaWYoKGxheWVySW5zdGFuY2UgYXMgYW55KS5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICAvL290aGVyd2lzZSwgdXNpbmcganF1ZXJ5IG9uIGRvbSBkaXJlY3RseVxuICAgICAgICAgICAgbGV0IGVsID0galF1ZXJ5KChsYXllckluc3RhbmNlIGFzIGFueSkuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyBpZih2aXNpYmxlKSBlbC5yZW1vdmVDbGFzcyhcImludmlzaWJsZVwiKTtcbiAgICAgICAgICAgIC8vIGVsc2UgZWwuYWRkQ2xhc3MoJ2ludmlzaWJsZScpO1xuICAgICAgICAgICAgZWwuY3NzKHsnZGlzcGxheSc6IHZpc2libGUgPyAnJyA6ICdub25lJ30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b3VjaCgnbWFwOmxheWVyOmNoYW5nZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZUxheWVyT3BhY2l0eSAoaWQgOiBzdHJpbmcsIG9wYWNpdHkgOiBudW1iZXIpIHtcblxuICAgICAgICBpZighdGhpcy5fbGF5ZXJDYWNoZSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2xheWVyQ2FjaGVbaWRdO1xuXG4gICAgICAgIC8vaWYgbGF5ZXIgaWQgaXMgZm9yIGJhc2UgbGF5ZXIuLi5cbiAgICAgICAgaWYoIWxheWVySW5zdGFuY2UgJiYgdGhpcy5fYmFzZUxheWVyRGVmLmlkID09PSBpZCkge1xuICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZSA9IHRoaXMuX2Jhc2VMYXllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYWRqdXN0IHJlbmRlcmVkIGxlYWZsZXQgbGF5ZXJcbiAgICAgICAgb3BhY2l0eSA9IHRoaXMuc2V0TGF5ZXJPcGFjaXR5KGxheWVySW5zdGFuY2UsIG9wYWNpdHkpO1xuXG4gICAgICAgIC8vIGlmIG92ZXJsYXkgbGF5ZXIsIHVwZGF0ZSBzdGF0ZSB2YWx1ZVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoaWQpO1xuICAgICAgICBpZihzdGF0ZSkgc3RhdGUub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBkb2VzIG5vdCB1cGRhdGUgdGhlIGFzc29jaWF0ZWQgTGF5ZXIgRGVmaW5pdGlvblxuICAgICAqIHN0YXRlIHZhbHVlIGZvciBvcGFjaXR5LiBVc2UgTWFwSW5zdGFuY2UudXBkYXRlTGF5ZXJPcGFjaXR5KCkgdG9cbiAgICAgKiBib3RoIHVwZGF0ZSBzdGF0ZSBhbmQgYWRqdXN0IHJlbmRlcmVkIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxheWVySW5zdGFuY2UgLSBsZWFmbGV0IGxheWVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG9wYWNpdHkgLSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuMCBvciAwIGFuZCAxMDBcbiAgICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgb3BhY2l0eSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuMFxuICAgICAqL1xuICAgIHNldExheWVyT3BhY2l0eSAobGF5ZXJJbnN0YW5jZSA6IExheWVyLCBvcGFjaXR5IDogbnVtYmVyKSA6IG51bWJlciB7XG4gICAgICAgIGlmKGxheWVySW5zdGFuY2UgJiYgKGxheWVySW5zdGFuY2UgYXMgYW55KS5zZXRPcGFjaXR5KSB7XG4gICAgICAgICAgICBpZihvcGFjaXR5ID4gMS4wKSBvcGFjaXR5ID0gb3BhY2l0eSAvIDEwMC4wO1xuICAgICAgICAgICAgKGxheWVySW5zdGFuY2UgYXMgYW55KS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgICAgICAgICAgdGhpcy50b3VjaCgnbWFwOmxheWVyOmNoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gR2VvUGxhdGZvcm0gTGF5ZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIExlYWZsZXQgbGF5ZXIgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoYXQgbGF5ZXIgb3IgbnVsbFxuICAgICAqL1xuICAgIGdldExlYWZsZXRMYXllckZvciAoZ3BMYXllciA6IGFueSkgOiBMYXllciB7XG4gICAgICAgIGlmKCFncExheWVyIHx8ICF0aGlzLl9sYXllckNhY2hlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxlYWZsZXRMYXllciA9IHRoaXMuX2xheWVyQ2FjaGVbZ3BMYXllci5pZF07XG4gICAgICAgIHJldHVybiBsZWFmbGV0TGF5ZXIgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUdldEZlYXR1cmVJbmZvIChsYXllcklkIDogc3RyaW5nKSB7XG4gICAgICAgIGlmKCF0aGlzLl9sYXllckNhY2hlKSByZXR1cm47XG4gICAgICAgIHZhciBsYXllckluc3RhbmNlID0gdGhpcy5fbGF5ZXJDYWNoZVtsYXllcklkXTtcbiAgICAgICAgaWYobGF5ZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYodHlwZW9mKGxheWVySW5zdGFuY2UuZW5hYmxlR2V0RmVhdHVyZUluZm8pICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGlmKGxheWVySW5zdGFuY2UuaXNHZXRGZWF0dXJlSW5mb0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckluc3RhbmNlLmRpc2FibGVHZXRGZWF0dXJlSW5mbygpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoKHRoaXMuX21hcEluc3RhbmNlIGFzIGFueSkuX2NvbnRhaW5lcikucmVtb3ZlQ2xhc3MoJ3NlbGVjdGFibGUtY3Vyc29yJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJbnN0YW5jZS5lbmFibGVHZXRGZWF0dXJlSW5mbygpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkoKHRoaXMuX21hcEluc3RhbmNlIGFzIGFueSkuX2NvbnRhaW5lcikuYWRkQ2xhc3MoJ3NlbGVjdGFibGUtY3Vyc29yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICBGZWF0dXJlIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gYXJyYXkgb2YgZmVhdHVyZXMgb24gdGhlIG1hcFxuICAgICAqL1xuICAgIGdldEZlYXR1cmVzICgpIDogYW55W10ge1xuICAgICAgICBpZih0aGlzLl9mZWF0dXJlTGF5ZXIpIHtcbiAgICAgICAgICAgIGxldCBnZW9qc29uID0gdGhpcy5fZmVhdHVyZUxheWVyLnRvR2VvSlNPTigpO1xuICAgICAgICAgICAgcmV0dXJuIChnZW9qc29uIGFzIGFueSkuZmVhdHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBqc29uIGdlb2pzb24gb2JqZWN0IG9yIGFycmF5IG9mIGdlb2pzb24gb2JqZWN0c1xuICAgICAqL1xuICAgIGFkZEZlYXR1cmVzIChqc29uIDogYW55KSB7XG5cbiAgICAgICAgaWYoIWpzb24pIHJldHVybjtcblxuICAgICAgICBpZih0eXBlb2YoanNvbi5wdXNoKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vYXJyYXkgb2YgZmVhdHVyZXNcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGpzb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGpzb25baV0sIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ2ZlYXR1cmVzOmNoYW5nZWQnKTtcblxuICAgICAgICB9IGVsc2UgaWYoanNvbi5mZWF0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlcyhqc29uLmZlYXR1cmVzKTtcblxuICAgICAgICB9IGVsc2UgeyAvL3NpbmdsZSBmZWF0dXJlXG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoanNvbiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBqc29uIGdlb2pzb24gb2JqZWN0XG4gICAgICovXG4gICAgYWRkRmVhdHVyZSAoanNvbiA6IGFueSwgZmlyZUV2ZW50ID86IGJvb2xlYW4pIHtcbiAgICAgICAgLy8gdmFyIHR5cGUgPSBqc29uLnR5cGU7XG4gICAgICAgIC8vIHZhciBjb29yZGluYXRlcyA9IGpzb24uY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgaWYoIXRoaXMuX2ZlYXR1cmVMYXllcikge1xuXG4gICAgICAgICAgICAvLyBfZmVhdHVyZUxheWVyID0gZ2VvSlNPTihbXSwgX2dlb0pzb25MYXllck9wdHMpLmFkZFRvKF9tYXBJbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXIgPSBmZWF0dXJlR3JvdXAoKS5hZGRUbyh0aGlzLl9tYXBJbnN0YW5jZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIF9mZWF0dXJlTGF5ZXIuYWRkRGF0YShqc29uKTtcbiAgICAgICAgdmFyIG9wdHMgPSBqUXVlcnkuZXh0ZW5kKHt9LCB0aGlzLl9nZW9Kc29uTGF5ZXJPcHRzKTtcbiAgICAgICAgZ2VvSlNPTihqc29uLCBvcHRzKS5lYWNoTGF5ZXIoKGwpPT50aGlzLmFkZEZlYXR1cmVMYXllcihsKSk7XG5cbiAgICAgICAgaWYodHlwZW9mKGZpcmVFdmVudCkgPT09ICd1bmRlZmluZWQnIHx8IGZpcmVFdmVudCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ2ZlYXR1cmVzOmNoYW5nZWQnKTtcbiAgICAgICAgZWxzZSB0aGlzLnRvdWNoKCk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoX2ZlYXR1cmVMYXllci50b0dlb0pTT04oKSkpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZlYXR1cmVKc29uIG9iamVjdCBkZWZpbmluZyBhIEdlb0pTT04gZmVhdHVyZVxuICAgICAqL1xuICAgIHVwZGF0ZUZlYXR1cmUgKGZlYXR1cmVKc29uIDogYW55KSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0RmVhdHVyZUxheWVyKGZlYXR1cmVKc29uLnByb3BlcnRpZXMuaWQpO1xuICAgICAgICBpZihsYXllcikge1xuXG4gICAgICAgICAgICAobGF5ZXIgYXMgYW55KS5mZWF0dXJlID0gZmVhdHVyZUpzb247XG5cbiAgICAgICAgICAgIC8vdXBkYXRlIHN0eWxlXG4gICAgICAgICAgICBsYXllci5zZXRTdHlsZShmZWF0dXJlSnNvbi5wcm9wZXJ0aWVzLnN0eWxlKTtcblxuICAgICAgICAgICAgLy9yZWJpbmQgbGFiZWwgaW4gY2FzZSB0aGF0IGNoYW5nZWRcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGZlYXR1cmVKc29uLnByb3BlcnRpZXMubGFiZWwgfHxcbiAgICAgICAgICAgICAgICBcIlVudGl0bGVkIFwiICsgZmVhdHVyZUpzb24uZ2VvbWV0cnkudHlwZSArIFwiIEZlYXR1cmVcIjtcbiAgICAgICAgICAgIGxheWVyLmJpbmRUb29sdGlwKGxhYmVsKTtcblxuICAgICAgICAgICAgLy8gbGF5ZXIucmVkcmF3KCk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKFwibWFwOmZlYXR1cmU6Y2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgYW4gZXhpc3RpbmcgTC5QYXRoLWJhc2VkIGxheWVyIHdpdGggb25lIHVzaW5nXG4gICAgICogdGhlIHN1cHBsaWVkIEZlYXR1cmUgR2VvSlNPTiBvYmplY3QuICBSZW1vdmVzIHRoZSBleGlzdGluZ1xuICAgICAqIGxheWVyIGFuZCBhZGRzIGEgbmV3IG9uZSBjcmVhdGVkIGZyb20gdGhlIEdlb0pTT04uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUpzb24gb2JqZWN0IGRlZmluaW5nIEdlb0pTT04gZmVhdHVyZVxuICAgICAqL1xuICAgIHJlcGxhY2VGZWF0dXJlIChmZWF0dXJlSnNvbiA6IGFueSkge1xuXG4gICAgICAgIC8vZmluZCBleGlzdGluZyBsYXllciBmb3IgdGhpcyBmZWF0dXJlXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0RmVhdHVyZUxheWVyKGZlYXR1cmVKc29uLnByb3BlcnRpZXMuaWQpO1xuICAgICAgICBpZihsYXllcikge1xuXG4gICAgICAgICAgICAvL3JlbW92ZSBleGlzdGluZ1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLnJlbW92ZUxheWVyKGxheWVyKTtcblxuICAgICAgICAgICAgLy9hZGQgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGdlb0pTT04oZmVhdHVyZUpzb24sIHRoaXMuX2dlb0pzb25MYXllck9wdHMpXG4gICAgICAgICAgICAgICAgLmVhY2hMYXllcigobCk9PnRoaXMuYWRkRmVhdHVyZUxheWVyKGwpKTtcblxuICAgICAgICAgICAgdGhpcy50b3VjaChcIm1hcDpmZWF0dXJlOmNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUlkIGlkZW50aWZpZXIgb2YgZmVhdHVyZSB0byBmb2N1cyB0aGUgbWFwIG9uXG4gICAgICovXG4gICAgZm9jdXNGZWF0dXJlIChmZWF0dXJlSWQgOiBzdHJpbmcpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRGZWF0dXJlTGF5ZXIoZmVhdHVyZUlkKTtcbiAgICAgICAgaWYobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YobGF5ZXIuZ2V0Qm91bmRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW50ID0gbGF5ZXIuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZml0Qm91bmRzKGV4dGVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZW9mKCAobGF5ZXIgYXMgYW55KS5nZXRMYXRMbmcpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBsYXRMbmcgPSAobGF5ZXIgYXMgYW55KS5nZXRMYXRMbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZS5wYW5UbyhsYXRMbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmZvY3VzRmVhdHVyZSgpIC0gQ2Fubm90IGZvY3VzIGZlYXR1cmUgYmVjYXVzZSBpdCBoYXMgbm8gYm91bmRzIG9yIGxhdC9sbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1hcEluc3RhbmNlLmZvY3VzRmVhdHVyZSgpIC0gQ2Fubm90IGZvY3VzIGZlYXR1cmUgYmVjYXVzZSBpdCBoYXMgbm8gbGF5ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUlkIDogc3RyaW5nXG4gICAgICovXG4gICAgcmVtb3ZlRmVhdHVyZSAoZmVhdHVyZUlkKSB7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0RmVhdHVyZUxheWVyKGZlYXR1cmVJZCk7XG4gICAgICAgIGlmKGxheWVyICYmIHRoaXMuX2ZlYXR1cmVMYXllcikge1xuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZUxheWVyLnJlbW92ZUxheWVyKGxheWVyKTtcbiAgICAgICAgICAgIHRoaXMudG91Y2goJ2ZlYXR1cmVzOmNoYW5nZWQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlRmVhdHVyZXMgKCkge1xuICAgICAgICBpZih0aGlzLl9mZWF0dXJlTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllci5jbGVhckxheWVycygpO1xuICAgICAgICAgICAgdGhpcy50b3VjaChcImZlYXR1cmVzOmNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldEZlYXR1cmVMYXllciAoIGZlYXR1cmVJZCA/OiBzdHJpbmcgKSA6IEZlYXR1cmVHcm91cCB7XG4gICAgICAgIC8vaWYgbm8gZmVhdHVyZSB3YXMgc3BlY2lmaWVkLCByZXR1cm4gcm9vdCBmZWF0dXJlIGxheWVyXG4gICAgICAgIGlmKCFmZWF0dXJlSWQpIHJldHVybiB0aGlzLl9mZWF0dXJlTGF5ZXI7XG5cbiAgICAgICAgLy9vdGhlcndpc2UsIGZpbmQgZmVhdHVyZS4uLlxuICAgICAgICBpZighdGhpcy5fZmVhdHVyZUxheWVyKSByZXR1cm4gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuX2ZlYXR1cmVMYXllci5nZXRMYXllcnMoKTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8ZmVhdHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmKCAoZmVhdHVyZXNbaV0gYXMgYW55KS5mZWF0dXJlICYmXG4gICAgICAgICAgICAgICAgKGZlYXR1cmVzW2ldIGFzIGFueSkuZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID09PSBmZWF0dXJlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZlYXR1cmVzW2ldIGFzIGFueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdG9nZ2xlRmVhdHVyZXNMYXllciAoKSB7XG4gICAgICAgIGlmKCF0aGlzLl9mZWF0dXJlTGF5ZXIpIHJldHVybiBmYWxzZTsgICAgLy9pZ25vcmUgaWYgbm90IHJlbmRlcmVkIHlldFxuXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGUgPSAhdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZTtcbiAgICAgICAgdGhpcy5zZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KHRoaXMuX2ZlYXR1cmVMYXllciwgdGhpcy5fZmVhdHVyZUxheWVyVmlzaWJsZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgZmVhdHVyZSAtIExlYWZsZXQgZmVhdHVyZSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSAgdmlzaWJpbGl0eSAtIGZsYWdcbiAgICAgKi9cbiAgICBzZXRGZWF0dXJlVmlzaWJpbGl0eSAoZmVhdHVyZSwgdmlzaWJpbGl0eSA6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5zZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KGZlYXR1cmUsIHZpc2liaWxpdHkpO1xuICAgIH1cblxuICAgIGdldEZlYXR1cmVzTGF5ZXJWaXNpYmlsaXR5ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVMYXllclZpc2libGU7XG4gICAgfVxuXG5cbiAgICAvKlxuICAgICAqIG1ldGhvZCBmb3IgYWRkaW5nIGZlYXR1cmUgbGF5ZXJzIHRvIHRoZSBtYXBcbiAgICAgKiB3aGVuIHRoZXNlIGxheWVycyBtYXkgYmUgbGF5ZXIgZ3JvdXBzLlxuICAgICAqIGZpbmRzIGxlYWYgbm9kZSBsYXllcnMgYW5kIGFkZHMgdGhlbSB0byB0aGVcbiAgICAgKiBtYXAncyBmZWF0dXJlIGdyb3VwXG4gICAgICovXG4gICAgYWRkRmVhdHVyZUxheWVyKGxheWVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEZlYXR1cmVMYXllcihsYXllcik7XG4gICAgICAgIHRoaXMudG91Y2goXCJmZWF0dXJlczpjaGFuZ2VkXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCwgdXNlICdhZGRGZWF0dXJlTGF5ZXInIGluc3RlYWRcbiAgICAgKiBAcGFyYW0gbGF5ZXJcbiAgICAgKi9cbiAgICBfYWRkRmVhdHVyZUxheWVyKGxheWVyIDogTGF5ZXIpIHtcbiAgICAgICAgaWYoIShsYXllciBhcyBhbnkpLmZlYXR1cmUgJiYgbGF5ZXIgaW5zdGFuY2VvZiBMYXllckdyb3VwKSB7XG4gICAgICAgICAgICBsYXllci5lYWNoTGF5ZXIoIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEZlYXR1cmVMYXllcihjaGlsZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllci5hZGRMYXllcihsYXllcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vdG9nZ2xlIHZpc2liaWxpdHkgb2YgcGFyZW50IGZlYXR1cmUgbGF5ZXJcbiAgICBzZXRGZWF0dXJlTGF5ZXJWaXNpYmlsaXR5KGxheWVyLCB2aXNpYmlsaXR5KSB7XG4gICAgICAgIGlmKCFsYXllcikgcmV0dXJuO1xuICAgICAgICB0aGlzLl9mZWF0dXJlTGF5ZXJWaXNpYmxlID0gdmlzaWJpbGl0eTtcblxuICAgICAgICBpZihsYXllci5nZXRMYXllcnMpIHtcbiAgICAgICAgICAgIGxheWVyLmdldExheWVycygpLmZvckVhY2goIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmVhdHVyZUxheWVyVmlzaWJpbGl0eShjaGlsZCwgdmlzaWJpbGl0eSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgfHwgbGF5ZXIuX3BhdGg7XG4gICAgICAgICAgICBpZihjb250YWluZXIpXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSB2aXNpYmlsaXR5ID8gJycgOiAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgIE1hcCBsaWZlY3ljbGUgb3BlcmF0aW9uc1xuICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4gcmVzb2x2aW5nIHBlcnNpc3RlZCBtYXBcbiAgICAgKi9cbiAgICBzYXZlIChtZXRhZGF0YSA6IGFueSkgOiBQcm9taXNlPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWFwKG1ldGFkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWQgb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgcHJvcGVydGllcyBmb3IgbWFwXG4gICAgICovXG4gICAgc2F2ZU1hcCAobWQgOiBhbnkpIDogUHJvbWlzZTxhbnk+IHtcblxuICAgICAgICBsZXQgbWV0YWRhdGEgPSBtZCB8fCB7fTtcblxuICAgICAgICAvL2FkZCBHZW9QbGF0Zm9ybU1hcCByZXNvdXJjZSB0eXBlIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgY29uc3QgZ3BNYXBUeXBlID0gJ2h0dHA6Ly93d3cuZ2VvcGxhdGZvcm0uZ292L29udC9vcGVubWFwL0dlb3BsYXRmb3JtTWFwJztcbiAgICAgICAgbWV0YWRhdGEucmVzb3VyY2VUeXBlcyA9IG1ldGFkYXRhLnJlc291cmNlVHlwZXMgfHwgW107XG4gICAgICAgIGlmKG1ldGFkYXRhLnJlc291cmNlVHlwZXMuaW5kZXhPZihncE1hcFR5cGUpIDwgMClcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlc291cmNlVHlwZXMucHVzaChncE1hcFR5cGUpO1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRNYXBSZXNvdXJjZUNvbnRlbnQobWV0YWRhdGEpO1xuXG4gICAgICAgIC8vZW5zdXJlIHRoZSB0d28gbmFtZSBwcm9wZXJ0aWVzIGxpbmUgdXBcbiAgICAgICAgaWYoY29udGVudC50aXRsZSAmJiBjb250ZW50LnRpdGxlICE9PSBjb250ZW50LmxhYmVsKSB7XG4gICAgICAgICAgICBjb250ZW50LmxhYmVsID0gY29udGVudC50aXRsZTtcbiAgICAgICAgfSBlbHNlIGlmKGNvbnRlbnQubGFiZWwgJiYgIWNvbnRlbnQudGl0bGUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQudGl0bGUgPSBjb250ZW50LmxhYmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJVcGRhdGluZzogXCIgKyBKU09OLnN0cmluZ2lmeShtYXApKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VydmljZShJdGVtVHlwZXMuTUFQKVxuICAgICAgICAuc2F2ZShjb250ZW50KVxuICAgICAgICAudGhlbiggcmVzdWx0ID0+IHtcblxuICAgICAgICAgICAgLy90cmFjayBuZXcgbWFwJ3MgaW5mbyBzbyB3ZSBjYW4gdXBkYXRlIGl0IHdpdGggbmV4dCBzYXZlXG4gICAgICAgICAgICBpZighdGhpcy5fbWFwSWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwSWQgPSByZXN1bHQuaWQ7XG5cbiAgICAgICAgICAgIHRoaXMuX21hcERlZiA9IHJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRFeHRlbnQgPSByZXN1bHQuZXh0ZW50O1xuICAgICAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycj0+e1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBDb3JlIE1hcEluc3RhbmNlLnNhdmVNYXAoKSAtIFwiICtcbiAgICAgICAgICAgICAgICBcIlRoZSByZXF1ZXN0ZWQgbWFwIGNvdWxkIG5vdCBiZSBzYXZlZCBiZWNhdXNlOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiVGhlIHJlcXVlc3RlZCBtYXAgY291bGQgbm90IGJlIHNhdmVkIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcihzKTogXCIgK1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBRLnJlamVjdChlKTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIG1hcCdzIGRlc2NyaXB0b3IgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gbWFwSWQgaWRlbnRpZmllciBvZiBtYXBcbiAgICAgKiBAcmV0dXJuIHJlc29sdmluZyB0aGUgbWFwIG9iamVjdFxuICAgICAqL1xuICAgIGZldGNoTWFwIChtYXBJZCA6IHN0cmluZykgOiBQcm9taXNlPGFueT4ge1xuICAgICAgICAvL0hhdmluZyB0byBzZW5kIGNhY2hlIGJ1c3RpbmcgcGFyYW1ldGVyIHRvIGF2b2lkIENPUlMgaGVhZGVyIGNhY2hlXG4gICAgICAgIC8vIG5vdCBzZW5kaW5nIGNvcnJlY3QgT3JpZ2luIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcnZpY2UoSXRlbVR5cGVzLk1BUCkuZ2V0KG1hcElkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIG1hcCdzIGRlc2NyaXB0b3IgYW5kIGxvYWQgaXQgYXMgdGhlXG4gICAgICogY3VycmVudCBtYXAgbWFuYWdlZCBieSB0aGlzIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0gbWFwSWQgaWRlbnRpZmllciBvZiBtYXBcbiAgICAgKiBAcmV0dXJuIHJlc29sdmluZyB0aGUgbWFwIG9iamVjdFxuICAgICAqL1xuICAgIGxvYWRNYXAgKG1hcElkIDogc3RyaW5nKSA6IFByb21pc2U8YW55PiB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hNYXAobWFwSWQpLnRoZW4obWFwID0+IHtcblxuICAgICAgICAgICAgaWYoIW1hcCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgbWFwICgnXCIgKyBtYXBJZCArXG4gICAgICAgICAgICAgICAgICAgIFwiJykgY2FtZSBiYWNrIG51bGxcIik7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZih0eXBlb2YobWFwKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVxdWVzdGVkIG1hcCAoJ1wiICsgbWFwSWQgK1xuICAgICAgICAgICAgICAgICAgICBcIicpIGNhbWUgYmFjayBhcyBhIHN0cmluZ1wiKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmKG1hcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIGxvYWRpbmcgdGhlIHJlcXVlc3RlZCBtYXAgKCdcIiArXG4gICAgICAgICAgICAgICAgICAgIG1hcElkICsgXCInKTogXCIgKyBtYXAubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy9sb2FkaW5nIGEgbWFwIGJ5IGl0cyBJRCwgc28gd2UgbmVlZCB0byBpbmNyZW1lbnQgaXQncyB2aWV3IGNvdW50XG4gICAgICAgICAgICBpZignZGV2ZWxvcG1lbnQnICE9PSBDb25maWcuZW52KSB7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCAobWFwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIHZpZXcgY291bnRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZpZXdzID0gbWFwLnN0YXRpc3RpY3MgPyAobWFwLnN0YXRpc3RpY3MubnVtVmlld3N8fDApIDogMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGNoID0gWyB7IG9wOiAncmVwbGFjZScsIHBhdGg6ICcvc3RhdGlzdGljcy9udW1WaWV3cycsIHZhbHVlOiB2aWV3cysxIH0gXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTZXJ2aWNlKEl0ZW1UeXBlcy5NQVApLnBhdGNoKG1hcC5pZCwgcGF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMubWFwU2VydmljZS5wYXRjaChtYXAuaWQsIHBhdGNoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbiggdXBkYXRlZCA9PiB7IG1hcC5zdGF0aXN0aWNzID0gdXBkYXRlZC5zdGF0aXN0aWNzOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5zYXZlTWFwKCkgLSBFcnJvciB1cGRhdGluZyB2aWV3IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvdW50IGZvciBtYXAgKCdcIiArIG1hcElkICsgXCInKTogXCIgKyBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCwgbWFwKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2xvYWQgdGhlIG1hcCBpbnRvIHRoZSB2aWV3ZXJcbiAgICAgICAgICAgIHRoaXMubG9hZE1hcEZyb21PYmoobWFwKTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKCBlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXBJbnN0YW5jZS5sb2FkTWFwKCkgLSBcIiArXG4gICAgICAgICAgICAgICAgXCJUaGUgcmVxdWVzdGVkIG1hcCBjb3VsZCBub3QgYmUgbG9hZGVkIGJlY2F1c2UgXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgbWFwICgnXCIgKyBtYXBJZCArXG4gICAgICAgICAgICAgICAgXCInKSBjb3VsZCBub3QgYmUgbG9hZGVkIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcihzKTogXCIgK1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBRLnJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIG1hcCBmcm9tIGl0cyBkZXNjcmlwdG9yIGFzIHRoZSBjdXJyZW50XG4gICAgICogbWFwIG1hbmFnZWQgYnkgdGhpcyBzZXJ2aWNlXG4gICAgICogQHBhcmFtIG1hcCBvYmplY3RcbiAgICAgKi9cbiAgICBsb2FkTWFwRnJvbU9iaiAobWFwIDogYW55KSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJMb2FkaW5nIE1hcCBPYmplY3RcIik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG1hcCk7XG5cbiAgICAgICAgdGhpcy5fbWFwSWQgPSBtYXAuaWQ7XG4gICAgICAgIHRoaXMuX21hcERlZiA9IG1hcDtcblxuICAgICAgICBtYXAuZXh0ZW50ID0gbWFwLmV4dGVudCB8fCB7fTtcbiAgICAgICAgbGV0IHdlc3QgPSAgaXNOYU4obWFwLmV4dGVudC5taW54KSA/IC0xNzkuMCA6IG1hcC5leHRlbnQubWlueCoxLjA7XG4gICAgICAgIGxldCBlYXN0ID0gIGlzTmFOKG1hcC5leHRlbnQubWF4eCkgPyAgMTc5LjAgOiBtYXAuZXh0ZW50Lm1heHgqMS4wO1xuICAgICAgICBsZXQgc291dGggPSBpc05hTihtYXAuZXh0ZW50Lm1pbnkpID8gIC04OS4wIDogbWFwLmV4dGVudC5taW55KjEuMDtcbiAgICAgICAgbGV0IG5vcnRoID0gaXNOYU4obWFwLmV4dGVudC5tYXh5KSA/ICAgODkuMCA6IG1hcC5leHRlbnQubWF4eSoxLjA7XG5cbiAgICAgICAgLy9lbnN1cmUgeCx5IGlzIG9yZGVyZWQgY29ycmVjdGx5XG4gICAgICAgIGxldCB0O1xuICAgICAgICBpZih3ZXN0ID4gZWFzdCkge1xuICAgICAgICAgICAgdCA9IE1hdGgubWluKHdlc3QsIGVhc3QpO1xuICAgICAgICAgICAgZWFzdCA9IG1hcC5leHRlbnQubWF4eCA9IE1hdGgubWF4KHdlc3QsIGVhc3QpO1xuICAgICAgICAgICAgd2VzdCA9IG1hcC5leHRlbnQubWlueCA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc291dGggPiBub3J0aCkge1xuICAgICAgICAgICAgdCA9IE1hdGgubWluKHNvdXRoLCBub3J0aCk7XG4gICAgICAgICAgICBub3J0aCA9IG1hcC5leHRlbnQubWF4eSA9IE1hdGgubWF4KHNvdXRoLCBub3J0aCk7XG4gICAgICAgICAgICBzb3V0aCA9IG1hcC5leHRlbnQubWlueSA9IHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL3ByZXZlbnQgb3V0LW9mLWJvdW5kcyBleHRlbnRzXG4gICAgICAgIGlmKHdlc3QgPCAtMTgwLjApIHdlc3QgPSAtMTc5LjA7XG4gICAgICAgIGlmKGVhc3QgPiAxODAuMCkgIGVhc3QgPSAgMTc5LjA7XG4gICAgICAgIGlmKHNvdXRoIDwgLTkwLjApIHNvdXRoID0gLTg5LjA7XG4gICAgICAgIGlmKG5vcnRoID4gOTAuMCkgIG5vcnRoID0gIDg5LjA7XG5cbiAgICAgICAgLy9zZXQgZXh0ZW50IGZyb20gbG9hZGVkIG1hcFxuICAgICAgICB0aGlzLl9kZWZhdWx0RXh0ZW50ID0gbWFwLmV4dGVudDtcbiAgICAgICAgdmFyIGV4dGVudCA9IG1hcC5leHRlbnQ7XG5cbiAgICAgICAgLy9yZW1vdmUgZXhpc3RpbmcgbGF5ZXJzXG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmVhY2hMYXllcigobCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UucmVtb3ZlTGF5ZXIobCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9sYXllckNhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2xheWVyU3RhdGVzID0gW107XG5cbiAgICAgICAgLy9zZXQgbmV3IGJhc2UgbGF5ZXJcbiAgICAgICAgdGhpcy5zZXRCYXNlTGF5ZXIobWFwLmJhc2VMYXllcik7XG5cbiAgICAgICAgLy9hZGQgbGF5ZXJzIGZyb20gbG9hZGVkIG1hcFxuICAgICAgICB0aGlzLmFkZExheWVycyhtYXAubGF5ZXJzKTtcblxuICAgICAgICAvL2FkZCBmZWF0dXJlc1xuICAgICAgICBpZihtYXAuYW5ub3RhdGlvbnMgJiYgbWFwLmFubm90YXRpb25zLmdlb0pTT04pIHtcbiAgICAgICAgICAgIGxldCBmYyA9IG1hcC5hbm5vdGF0aW9ucy5nZW9KU09OO1xuICAgICAgICAgICAgaWYoZmMuZmVhdHVyZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlcyhmYy5mZWF0dXJlcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlcyhbZmNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcEluc3RhbmNlLmZpdEJvdW5kcyhbXG4gICAgICAgICAgICBbZXh0ZW50Lm1pbnksIGV4dGVudC5taW54XSxcbiAgICAgICAgICAgIFtleHRlbnQubWF4eSwgZXh0ZW50Lm1heHhdXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ21hcDpsb2FkZWQnLCBtYXApO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3lNYXAgKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkRlc3Ryb3lpbmcgTWFwXCIpO1xuICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xheWVyQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXllclN0YXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVMYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIG1hcCB0aGF0IGlzIGFscmVhZHkgcGVyc2lzdGVkIG9uIHRoZVxuICAgICAqIHNlcnZlciBhbmQgdW5saW5rIGl0IGhlcmUgaW4gdGhlIGNsaWVudCBzbyB0aGF0IGl0IHdpbGwgYmUgc2F2ZWRcbiAgICAgKiBhcyBhIGNvbXBsZXRlbHkgbmV3IG1hcCB3aGVuIG1hcFNlcnZpY2Uuc2F2ZU1hcCguLi4pIGlzIG5leHQgY2FsbGVkXG4gICAgICovXG4gICAgc2V0QXNOZXdNYXAgKG1hcFRvVXNlKSB7XG4gICAgICAgIHRoaXMuX21hcElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFwRGVmID0gbWFwVG9Vc2UgfHwgdGhpcy5pbml0aWFsaXplTWFwRGVmaW5pdGlvbigpO1xuICAgIH1cblxuXG4gICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBUb29sIG9wZXJhdGlvbnNcbiAgICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgICByZWdpc3RlclRvb2wgKGlkLCB0b29sKSB7XG4gICAgICAgIHRoaXMuX3Rvb2xzW2lkXSA9IHRvb2w7XG4gICAgfVxuXG4gICAgdW5yZWdpc3RlclRvb2wgKGlkKSB7XG4gICAgICAgIHRoaXMuX3Rvb2xzW2lkXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZW5hYmxlVG9vbCAoaWQsIGZpbmlzaCkge1xuICAgICAgICBpZighdGhpcy5fdG9vbHNbaWRdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Rvb2xzW2lkXS5hY3RpdmF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCd0b29sOmRpc2FibGVkJywgaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ3Rvb2w6ZW5hYmxlZCcsIGlkKTtcbiAgICB9XG5cblxuICAgIC8qIC0tLS0tLS0tLS0tIE1JU0MgLS0tLS0tLS0tLS0tICovXG5cbiAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9nc2tsZWUvbmdTdG9yYWdlXG4gICAgY2FjaGVNYXAgKCkge1xuXG4gICAgICAgIGlmKHRoaXMuc3RhdGUgJiYgdGhpcy5zdGF0ZS5kaXJ0eSkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwUmVzb3VyY2VDb250ZW50KCk7XG4gICAgICAgICAgICAvL3VzZSBleHBsb2RlZCBsYXllciBpbmZvXG4gICAgICAgICAgICBtYXAubGF5ZXJzID0gdGhpcy5fbGF5ZXJTdGF0ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICAvLyAkc2Vzc2lvblN0b3JhZ2UubWFwID0gbWFwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdG9yZU1hcCAoKSB7XG4gICAgICAgIC8vIGlmKCRzZXNzaW9uU3RvcmFnZS5tYXApIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwiUmVzdG9yaW5nIGNhY2hlZCBtYXBcIik7XG4gICAgICAgIC8vICAgICBsZXQgbWFwID0gJHNlc3Npb25TdG9yYWdlLm1hcDtcbiAgICAgICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG1hcCkpO1xuICAgICAgICAvLyAgICAgJHNlc3Npb25TdG9yYWdlLm1hcCA9IG51bGw7XG4gICAgICAgIC8vICAgICB0aGlzLmxvYWRNYXBGcm9tT2JqKG1hcCk7XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xufVxuIl19