{"version":3,"sources":["ng://@geoplatform/mapcore/control/loading.ts","ng://@geoplatform/mapcore/control/measure.ts","ng://@geoplatform/mapcore/control/mouse-position.ts","node_modules/tslib/tslib.es6.js","ng://@geoplatform/mapcore/control/feature-editor.ts","ng://@geoplatform/mapcore/service/types.ts","ng://@geoplatform/mapcore/shared/resource-types.ts","ng://@geoplatform/mapcore/layer/osm.ts","ng://@geoplatform/mapcore/layer/baselayer-default.ts","ng://@geoplatform/mapcore/layer/base-clustered-feature-layer.ts","ng://@geoplatform/mapcore/shared/style-resolver.ts","ng://@geoplatform/mapcore/shared/popup-template.ts","ng://@geoplatform/mapcore/layer/cluster-feature.ts","ng://@geoplatform/mapcore/layer/wms.ts","ng://@geoplatform/mapcore/layer/wmst.ts","ng://@geoplatform/mapcore/layer/wmts.ts","ng://@geoplatform/mapcore/layer/esri-tile-layer.ts","ng://@geoplatform/mapcore/layer/osm-factory.ts","ng://@geoplatform/mapcore/shared/mapbox-style.ts","ng://@geoplatform/mapcore/layer/mbvt.ts","ng://@geoplatform/mapcore/layer/factory.ts","ng://@geoplatform/mapcore/layer/feature.ts","ng://@geoplatform/mapcore/map/instance.ts","ng://@geoplatform/mapcore/map/factory.ts","ng://@geoplatform/mapcore/polyfills.ts","ng://@geoplatform/mapcore/index.ts"],"names":["loadingControl","Control","extend","options","position","separate","zoomControl","spinjs","spin","lines","length","width","radius","rotate","top","initialize","Util","setOptions","this","_dataLoaders","onAdd","map","_addLayerListeners","_addMapListeners","zoomsliderControl","container","classes","_container","DomUtil","create","_indicator","onRemove","_removeLayerListeners","_removeMapListeners","removeFrom","removeChild","_map","prototype","remove","call","addLoader","id","updateIndicator","removeLoader","isLoading","_showIndicator","_hideIndicator","_countLoaders","key","size","hasOwnProperty","addClass","Zoom","removeClass","_zoomOutButton","_handleLoading","e","getEventId","_handleLoad","layer","_leaflet_id","target","_layerAdd","on","loading","load","exception","console","warn","eachLayer","off","dataloading","dataload","layerremove","L","L_1","Loading","Map","addInitHook","addControl","measureControl","_createButton","_toggleMeasure","html","title","className","fn","context","link","innerHTML","href","DomEvent","stopPropagation","preventDefault","_measuring","_startMeasuring","_stopMeasuring","_oldCursor","style","cursor","_doubleClickZoom","doubleClickZoom","enabled","disable","_mouseMove","_mouseClick","_finishPath","_layerPaint","layerGroup","addTo","_points","enable","clearLayers","_restartPath","latlng","_lastPoint","_layerPaintPathTemp","spliceLatLngs","polyline","color","weight","clickable","dashArray","_tooltip","_distance","_updateTooltipPosition","distance","distanceTo","_updateTooltipDistance","_createTooltip","_layerPaintPath","addLatLng","_lastCircle","removeLayer","markerOpts","opacity","fill","fillOpacity","CircleMarker","undefined","opts","icon","divIcon","iconAnchor","marker","setLatLng","total","difference","totalRound","_round","differenceRound","text","_icon","val","Math","round","_onKeyDown","keyCode","Measure","control","measure","mergeOptions","positionControl","separator","emptyString","lngFirst","numDigits","lngFormatter","latFormatter","prefix","disableClickPropagation","_onMouseMove","lng","formatNum","lat","value","prefixAndValue","MousePosition","mousePosition","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","__extends","__","constructor","FeatureEditor","doneEditing","unregisterTool","tool","deactivate","getMap","removeControl","editingLayer","showOriginalLayer","bool","feature","properties","getFeatureLayer","setFeatureVisibility","beginEditing","visible","originalFeature","GeoJSON","geometryToLayer","toGeoJSON","_editing","FeatureGroup","geometry","type","indexOf","type_1","replace","coordinates","each","childCoords","shape","onEachFeature","addLayer","geometries","childGeometry","EditFeature","featureGroup","activate","save","hasBeenEdited","geometry_1","isMulti_1","isGeomColl_1","geoms_1","coords_1","replaceFeature","updateFeature","addProperty","highlightFeature","focusFeature","deleteFeature","removeFeature","style_1","setStyle","cancelEditing","tslib_1.__extends","selectedPathOptions","fillColor","maintainColor","handler","Draw","EditToolbar","Edit","result","edited","_super","assign","draw","edit","keyFn","expr","str","m","exec","LayerResourceTypes","OSM","test","resourceTypes","get","layerService","query","QueryFactory","fields","LayerService","Config","ualUrl","XHRHttpClient","search","then","response","results","DefaultBaseLayer","baseLayerId","defaultBaseLayerId","catch","set","configure","ogcExpr","esriExpr","types","ESRI_FEATURE_SERVER","uri","description","label","ESRI_IMAGE_SERVER","ESRI_MAP_SERVER","ESRI_TILE_SERVER","KML","CSW","WCS","WFS","WMS","WMTS","WMST","FEED","refresh","updateList","service","url","pageSize","ItemService","data","i","supported","toUpperCase","error","log","message","BaseClusteredFeatureLayer","esri.FeatureManager","statics","EVENTS","CLUSTEREVENTS","_layers","_leafletIds","cluster","MarkerClusterGroup","_key","random","toString","addEventParent","createLayers","features","markers","geojson","newLayer","asFeature","defaultOptions","resetStyle","fire","timeField","_featureWithinTimeRange","push","addLayers","ids","layersToAdd","removeLayers","permanent","layersToRemove","setFeatureStyle","eachFeature","getFeature","featureStyleResolver","err","Error","Promise","reject","featurePopupTemplate","pFn","list","names","find","name","lc","toLowerCase","date","props","keys","titleProp","descProp","modified","Date","toDateString","toTimeString","linkProp","prop","jQuery","jquery","ClusteredFeatureLayer","currentVisibility","currentOpacity","_gpStyle","pointToLayerFn","stroke","renderer","height","mopts","iconFn","iconUrl","content","iconSize","popupAnchor","leafletPane","pane","markerFn","circleMarkerFn","popupTemplate","bindPopup","eachFeatureFn","_this","pointToLayer","bind","spiderfyDistanceMultiplier","styleResolver","svgOpts","SVG","svg","Canvas","canvas","zIndex","setZIndex","layerId","loadStyle","setVisibility","setOpacity","index","lyr","_updateZIndex","_renderer","toggleVisibility","display","_featureGroup","isNaN","css","gpLayerId","styleLoader","json","styles","styleFn","property","field1","v","wrapper","sw","JSON","stringify","featureFn_1","setTimeout","obj","clusteredFeatures","services","supportedFormats","layerName","geoJsonFeed","layerUrl","styleUrl","isModern","resolve","ajax","dataType","success","xhr","status","TileLayer","enableGetFeatureInfo","getFeatureInfo","_enabled","disableGetFeatureInfo","isGetFeatureInfoEnabled","evt","getFeatureInfoUrl","parseGetFeatureInfo","point","latLngToContainerPoint","getSize","params","srs","bbox","getBounds","toBBoxString","y","x","info_format","j","wmvId","getParamString","field","join","showGetFeatureInfo","popup","maxWidth","setContent","openOn","wms","format","determineWMSFormat","formats","idx","common","supportedCrs","crs","version","versions","serviceTypeVersions","layers","transparent","tileLayer","(L).TimeDimension","Layer","_parseTimeDimensionFromCapabilities","xml","querySelectorAll","_baseLayer","wmsParams","times","forEach","current","querySelector","_getTimesFromLayerCapabilities","parentNode","dimensions","textContent","trim","extents","toISOString","wmst","gpLayer","leafletLayer","proxyUrl","tdOpts","temporal","d1","startDate","d2","endDate","timeDimension","(( /** @type {?} */(L))).TimeDimension","proxy","paramRe","_url","defaultWmtsParams","request","tileMatrixSet","wmtsParams","tileSize","detectRetina","Browser","retina","matrixIds","getDefaultMatrix","_crs","getTileUrl","coords","nwPoint","multiplyBy","sePoint","add","Point","zoom","_tileZoom","nw","project","unproject","tilewidth","ident","identifier","X0","topLeftCorner","Y0","tilecol","floor","tilerow","isTileMatrixTemplated","isTileRowTemplated","isTileColTemplated","o","s","_getSubdomain","k","TileMatrix","TileRow","TileCol","qsi","template","setParams","noRedraw","redraw","matrixIds3857","LatLng","tilePoint","abs","subdomains","wmts","distro","distributions","dist","mediaType","parameters","param","plc","defaultValue","values","EsriTileLayer","defaultESRIParams","f","qidx","substring","dim","esriParams","imagesr","bboxsr","code","z","se","ESRI","esri","OSMLayerFactory","minZoom","maxZoom","attribution","Expression","evaluate","geometryType","p1","p2","operator","getArg","isArray","findMatch","args","end","arg","concat","filter","arr","slice","splice","parseMapBoxStyle","doThis","layerStyles","layerStyle","styleFunctionFactory","geomType","match","styleVal","parseValue","fallback","layerPaint","paint","lineWidth","STYLE_CONCEPT","DEFAULT_STYLE_CONCEPT","mapBoxVectorTileLayer","Leaflet","vectorGrid","rendererFactory","L.canvas","tile","protobuf","related","rel","role","applyVectorTileStyle","styleResource","fetchStyleDefinition","resource","contentId","client","createRequestOpts","method","timeout","execute","styleDef","layerInst","vectorTileLayerStyles","LayerFactory","factories","init","include","LayerFactory$1","register","setLayerService","getStyleResolver","styleResolverFactory","msg","svcType","serviceType","typeUri","checkUrl","ServiceTypes","ESRITileLayer","useCors","esri.tiledMapLayer","esri.imageMapLayer","FeatureLayer","esri.FeatureLayer","Listener","listener","_listeners","notify","_i","arguments","l","apply","MapInstance","dispose","destroyMap","svcCache","serviceFactory","httpClient","_mapId","_mapDef","_mapInstance","_defaultExtent","_baseLayerDef","_layerStates","_layerCache","_layerErrors","_featureLayer","_featureLayerVisible","_tools","state","_geoJsonLayerOpts","getKey","setService","mapService","setServiceFactory","factory","setHttpClient","getService","setErrorHandler","_layerErrorHandler","getLayerStateIndex","getLayerState","initializeMapDefinition","ItemTypes","MAP","createdBy","baseLayer","keywords","themes","getMapResourceContent","metadata","visibility","annotations","geoJSON","extent","minx","getWest","miny","getSouth","maxx","getEast","maxy","getNorth","getDrawControlToolbar","drawControl","toolbars","_toolbars","toolbar","_modes","handleLayerError","processLayerError","finder","obj_1","logLayerError","src","split","LAYER","validate","def","errorMsg","touch","event","dirty","clean","setMap","getMapDefinition","getMapId","setView","getZoom","getView","latLng","getCenter","zoomToDefault","fitBounds","setExtent","setBaseLayer","promise","svc","oldBaseLayer","getBaseLayer","getLayers","getLayerErrors","clearLayerErrors","clearOverlays","layerInstance","parse","addLayerWithState","setLayerVisibility","setLayerOpacity","moveLayer","from","to","copy","layerState","toggleLayerVisibility","_currentImage","getOpacity","updateLayerOpacity","getLeafletLayerFor","toggleGetFeatureInfo","getFeatures","addFeatures","addFeature","fireEvent","addFeatureLayer","featureJson","bindTooltip","featureId","getLatLng","panTo","removeFeatures","toggleFeaturesLayer","setFeatureLayerVisibility","getFeaturesLayerVisibility","_addFeatureLayer","LayerGroup","child","_path","saveMap","md","gpMapType","fetchMap","mapId","loadMap","env","patch","op","path","statistics","numViews","updated","loadMapFromObj","ensureExtent","fc","t","west","east","south","north","min","max","setAsNewMap","mapToUse","registerTool","enableTool","finish","cacheMap","restoreMap","ServiceFactory","ceil","desc","circleMarker","cache","instance","Polyfills","defineProperty","varArgs","TypeError","nextSource","nextKey","writable","configurable"],"mappings":"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","sourcesContent":["\nimport { Control, Util, DomUtil, Map } from 'leaflet';\n\nvar loadingControl = Control.extend({\n    options: {\n        position: 'topleft',\n        separate: false,\n        zoomControl: null,\n        spinjs: false,\n        spin: {\n          lines: 7,\n          length: 3,\n          width: 3,\n          radius: 5,\n          rotate: 13,\n          top: \"83%\"\n        }\n    },\n\n    initialize: function(options) {\n        Util.setOptions(this, options);\n        this._dataLoaders = {};\n\n        // Try to set the zoom control this control is attached to from the\n        // options\n        if (this.options.zoomControl !== null) {\n            this.zoomControl = this.options.zoomControl;\n        }\n    },\n\n    onAdd: function(map) {\n\n        this._addLayerListeners(map);\n        this._addMapListeners(map);\n\n        // Try to set the zoom control this control is attached to from the map\n        // the control is being added to\n        if (!this.options.separate && !this.zoomControl) {\n            if (map.zoomControl) {\n                this.zoomControl = map.zoomControl;\n            } else if (map.zoomsliderControl) {\n                this.zoomControl = map.zoomsliderControl;\n            }\n        }\n\n        // Create the loading indicator\n        var classes = 'leaflet-control-loading';\n        var container;\n        if (this.zoomControl && !this.options.separate) {\n            // If there is a zoom control, hook into the bottom of it\n            container = this.zoomControl._container;\n            // These classes are no longer used as of Leaflet 0.6\n            classes += ' leaflet-bar-part-bottom leaflet-bar-part last';\n        }\n        else {\n            // Otherwise, create a container for the indicator\n            container = DomUtil.create('div', 'leaflet-control-zoom leaflet-bar');\n        }\n        this._indicator = DomUtil.create('a', classes, container);\n        return container;\n    },\n\n    onRemove: function(map) {\n        this._removeLayerListeners(map);\n        this._removeMapListeners(map);\n    },\n\n    removeFrom: function (map) {\n        if (this.zoomControl && !this.options.separate) {\n            // Override Control.removeFrom() to avoid clobbering the entire\n            // _container, which is the same as zoomControl's\n            this._container.removeChild(this._indicator);\n            this._map = null;\n            this.onRemove(map);\n            return this;\n        }\n        else {\n            // If this control is separate from the zoomControl, call the\n            // parent method so we don't leave behind an empty container\n            return Control.prototype.remove.call(this);\n        }\n    },\n\n    addLoader: function(id) {\n        this._dataLoaders[id] = true;\n        this.updateIndicator();\n    },\n\n    removeLoader: function(id) {\n        delete this._dataLoaders[id];\n        this.updateIndicator();\n    },\n\n    updateIndicator: function() {\n        if (this.isLoading()) {\n            this._showIndicator();\n        }\n        else {\n            this._hideIndicator();\n        }\n    },\n\n    isLoading: function() {\n        return this._countLoaders() > 0;\n    },\n\n    _countLoaders: function() {\n        var size = 0, key;\n        for (key in this._dataLoaders) {\n            if (this._dataLoaders.hasOwnProperty(key)) size++;\n        }\n        return size;\n    },\n\n    _showIndicator: function() {\n        // Show loading indicator\n        DomUtil.addClass(this._indicator, 'is-loading');\n\n        // If zoomControl exists, make the zoom-out button not last\n        if (!this.options.separate) {\n            if (this.zoomControl instanceof Control.Zoom) {\n                DomUtil.removeClass(this.zoomControl._zoomOutButton, 'leaflet-bar-part-bottom');\n            }\n        }\n    },\n\n    _hideIndicator: function() {\n        // Hide loading indicator\n        DomUtil.removeClass(this._indicator, 'is-loading');\n\n        // If zoomControl exists, make the zoom-out button last\n        if (!this.options.separate) {\n            if (this.zoomControl instanceof Control.Zoom) {\n                DomUtil.addClass(this.zoomControl._zoomOutButton, 'leaflet-bar-part-bottom');\n            }\n        }\n    },\n\n    _handleLoading: function(e) {\n        this.addLoader(this.getEventId(e));\n    },\n\n    _handleLoad: function(e) {\n        this.removeLoader(this.getEventId(e));\n    },\n\n    getEventId: function(e) {\n        if (e.id) {\n            return e.id;\n        }\n        else if (e.layer) {\n            return e.layer._leaflet_id;\n        }\n        return e.target._leaflet_id;\n    },\n\n    _layerAdd: function(e) {\n        if (!e.layer || !e.layer.on) return;\n        try {\n            e.layer.on({\n                loading: this._handleLoading,\n                load: this._handleLoad\n            }, this);\n        }\n        catch (exception) {\n            console.warn('L.Control.Loading: Tried and failed to add ' +\n                         ' event handlers to layer', e.layer);\n            console.warn('L.Control.Loading: Full details', exception);\n        }\n    },\n\n    _addLayerListeners: function(map) {\n        // Add listeners for begin and end of load to any layers already on the\n        // map\n        map.eachLayer(function(layer) {\n            if (!layer.on) return;\n            layer.on({\n                loading: this._handleLoading,\n                load: this._handleLoad\n            }, this);\n        }, this);\n\n        // When a layer is added to the map, add listeners for begin and end\n        // of load\n        map.on('layeradd', this._layerAdd, this);\n    },\n\n    _removeLayerListeners: function(map) {\n        // Remove listeners for begin and end of load from all layers\n        map.eachLayer(function(layer) {\n            if (!layer.off) return;\n            layer.off({\n                loading: this._handleLoading,\n                load: this._handleLoad\n            }, this);\n        }, this);\n\n        // Remove layeradd listener from map\n        map.off('layeradd', this._layerAdd, this);\n    },\n\n    _addMapListeners: function(map) {\n        // Add listeners to the map for (custom) dataloading and dataload\n        // events, eg, for AJAX calls that affect the map but will not be\n        // reflected in the above layer events.\n        map.on({\n            dataloading: this._handleLoading,\n            dataload: this._handleLoad,\n            layerremove: this._handleLoad\n        }, this);\n    },\n\n    _removeMapListeners: function(map) {\n        map.off({\n            dataloading: this._handleLoading,\n            dataload: this._handleLoad,\n            layerremove: this._handleLoad\n        }, this);\n    }\n});\n\n\nif( (window as any).L) {\n    const L = (window as any).L;\n    L.Control.Loading = loadingControl;\n    L.Control.loading = function(options) {\n        return new L.Control.Loading(options);\n    };\n}\n\nMap.addInitHook(function () {\n    if (this.options.loadingControl) {\n        this.loadingControl = new loadingControl();\n        this.addControl(this.loadingControl);\n    }\n});\n\nexport default loadingControl;\n","\nimport {\n    Control, control,\n    Map,\n    DomUtil, DomEvent,\n    layerGroup,\n    polyline, CircleMarker, divIcon, marker,\n    PolylineOptions, CircleMarkerOptions\n} from 'leaflet';\n\n\nvar measureControl = Control.extend({\n    options: {\n        position: 'topleft'\n    },\n\n    onAdd: function (map) {\n        var className = 'leaflet-control-zoom leaflet-bar leaflet-control',\n            container = DomUtil.create('div', className);\n\n        this._createButton('&#8674;', 'Measure', 'leaflet-control-measure leaflet-bar-part leaflet-bar-part-top-and-bottom', container, this._toggleMeasure, this);\n\n        return container;\n    },\n\n    _createButton: function (html, title, className, container, fn, context) {\n        var link = DomUtil.create('a', className, container);\n        link.innerHTML = html;\n        (link as HTMLAnchorElement).href = '#';\n        link.title = title;\n\n        DomEvent\n            .on(link, 'click', DomEvent.stopPropagation)\n            .on(link, 'click', DomEvent.preventDefault)\n            .on(link, 'click', fn, context)\n            .on(link, 'dblclick', DomEvent.stopPropagation);\n\n        return link;\n    },\n\n    _toggleMeasure: function () {\n        this._measuring = !this._measuring;\n\n        if(this._measuring) {\n            DomUtil.addClass(this._container, 'leaflet-control-measure-on');\n            this._startMeasuring();\n        } else {\n            DomUtil.removeClass(this._container, 'leaflet-control-measure-on');\n            this._stopMeasuring();\n        }\n    },\n\n    _startMeasuring: function() {\n        this._oldCursor = this._map._container.style.cursor;\n        this._map._container.style.cursor = 'crosshair';\n\n        this._doubleClickZoom = this._map.doubleClickZoom.enabled();\n        this._map.doubleClickZoom.disable();\n\n        DomEvent\n            .on(this._map, 'mousemove', this._mouseMove, this)\n            .on(this._map, 'click', this._mouseClick, this)\n            .on(this._map, 'dblclick', this._finishPath, this)\n            //.on( (document as Document), 'keydown', this._onKeyDown, this);\n\n        if(!this._layerPaint) {\n            this._layerPaint = layerGroup().addTo(this._map);\n        }\n\n        if(!this._points) {\n            this._points = [];\n        }\n    },\n\n    _stopMeasuring: function() {\n        this._map._container.style.cursor = this._oldCursor;\n\n        DomEvent\n            //.off((document as Document), 'keydown', this._onKeyDown, this)\n            .off(this._map, 'mousemove', this._mouseMove, this)\n            .off(this._map, 'click', this._mouseClick, this)\n            .off(this._map, 'dblclick', this._mouseClick, this);\n\n        if(this._doubleClickZoom) {\n            this._map.doubleClickZoom.enable();\n        }\n\n        if(this._layerPaint) {\n            this._layerPaint.clearLayers();\n        }\n\n        this._restartPath();\n    },\n\n    _mouseMove: function(e) {\n        if(!e.latlng || !this._lastPoint) {\n            return;\n        }\n\n        if(!this._layerPaintPathTemp) {\n            let opts = {\n                color: 'black',\n                weight: 1.5,\n                clickable: false,\n                dashArray: '6,3'\n            } as PolylineOptions;\n            this._layerPaintPathTemp = polyline([this._lastPoint, e.latlng], opts)\n                .addTo(this._layerPaint);\n        } else {\n            this._layerPaintPathTemp.spliceLatLngs(0, 2, this._lastPoint, e.latlng);\n        }\n\n        if(this._tooltip) {\n            if(!this._distance) {\n                this._distance = 0;\n            }\n\n            this._updateTooltipPosition(e.latlng);\n\n            var distance = e.latlng.distanceTo(this._lastPoint);\n            this._updateTooltipDistance(this._distance + distance, distance);\n        }\n    },\n\n    _mouseClick: function(e) {\n        // Skip if no coordinates\n        if(!e.latlng) {\n            return;\n        }\n\n        // If we have a tooltip, update the distance and create a new tooltip, leaving the old one exactly where it is (i.e. where the user has clicked)\n        if(this._lastPoint && this._tooltip) {\n            if(!this._distance) {\n                this._distance = 0;\n            }\n\n            this._updateTooltipPosition(e.latlng);\n\n            var distance = e.latlng.distanceTo(this._lastPoint);\n            this._updateTooltipDistance(this._distance + distance, distance);\n\n            this._distance += distance;\n        }\n        this._createTooltip(e.latlng);\n\n\n        // If this is already the second click, add the location to the fix path (create one first if we don't have one)\n        if(this._lastPoint && !this._layerPaintPath) {\n            let opts = {\n                color: 'black',\n                weight: 2,\n                clickable: false\n            } as PolylineOptions;\n            this._layerPaintPath = polyline([this._lastPoint], opts).addTo(this._layerPaint);\n        }\n\n        if(this._layerPaintPath) {\n            this._layerPaintPath.addLatLng(e.latlng);\n        }\n\n        // Upate the end marker to the current location\n        if(this._lastCircle) {\n            this._layerPaint.removeLayer(this._lastCircle);\n        }\n\n        let markerOpts = {\n            color: 'black',\n            opacity: 1,\n            weight: 1,\n            fill: true,\n            fillOpacity: 1,\n            radius:2,\n            clickable: this._lastCircle ? true : false\n        } as CircleMarkerOptions;\n        this._lastCircle = new CircleMarker(e.latlng, markerOpts).addTo(this._layerPaint);\n\n        this._lastCircle.on('click', function() { this._finishPath(); }, this);\n\n        // Save current location as last location\n        this._lastPoint = e.latlng;\n    },\n\n    _finishPath: function() {\n        // Remove the last end marker as well as the last (moving tooltip)\n        if(this._lastCircle) {\n            this._layerPaint.removeLayer(this._lastCircle);\n        }\n        if(this._tooltip) {\n            this._layerPaint.removeLayer(this._tooltip);\n        }\n        if(this._layerPaint && this._layerPaintPathTemp) {\n            this._layerPaint.removeLayer(this._layerPaintPathTemp);\n        }\n\n        // Reset everything\n        this._restartPath();\n    },\n\n    _restartPath: function() {\n        this._distance = 0;\n        this._tooltip = undefined;\n        this._lastCircle = undefined;\n        this._lastPoint = undefined;\n        this._layerPaintPath = undefined;\n        this._layerPaintPathTemp = undefined;\n    },\n\n    _createTooltip: function(position) {\n        var icon = divIcon({\n            className: 'leaflet-measure-tooltip',\n            iconAnchor: [-5, -5]\n        });\n\n        let opts: any = {\n            icon: icon,\n            clickable: false\n        };\n        this._tooltip = marker(position, opts as CircleMarkerOptions).addTo(this._layerPaint);\n    },\n\n    _updateTooltipPosition: function(position) {\n        this._tooltip.setLatLng(position);\n    },\n\n    _updateTooltipDistance: function(total, difference) {\n        var totalRound = this._round(total),\n            differenceRound = this._round(difference);\n\n        var text = '<div class=\"leaflet-measure-tooltip-total\">' + totalRound + ' nm</div>';\n        if(differenceRound > 0 && totalRound != differenceRound) {\n            text += '<div class=\"leaflet-measure-tooltip-difference\">(+' + differenceRound + ' nm)</div>';\n        }\n\n        this._tooltip._icon.innerHTML = text;\n    },\n\n    _round: function(val) {\n        return Math.round((val / 1852) * 10) / 10;\n    },\n\n    _onKeyDown: function (e) {\n        if(e.keyCode == 27) {\n            // If not in path exit measuring mode, else just finish path\n            if(!this._lastPoint) {\n                this._toggleMeasure();\n            } else {\n                this._finishPath();\n            }\n        }\n    }\n});\n\n\nif( (window as any).L) {\n    const L = (window as any).L;\n    L.Control.Measure = measureControl;\n    L.control.measure = function (options) {\n        return new L.Control.Measure(options);\n    };\n}\n\nMap.mergeOptions({\n    measureControl: false\n});\n\nMap.addInitHook(function () {\n    if (this.options.measureControl) {\n        this.measureControl = new measureControl();\n        this.addControl(this.measureControl);\n    }\n});\n\n\nexport default measureControl;\n","\nimport {\n    Control, control, DomUtil, DomEvent, Util, Map\n} from 'leaflet';\n\n\nvar positionControl = Control.extend({\n  options: {\n    position: 'bottomleft',\n    separator: ' : ',\n    emptyString: 'Unavailable',\n    lngFirst: false,\n    numDigits: 6,\n    lngFormatter: undefined,\n    latFormatter: undefined,\n    prefix: \"\"\n  },\n\n  onAdd: function (map) {\n    this._container = DomUtil.create('div', 'leaflet-control-mouseposition');\n    DomEvent.disableClickPropagation(this._container);\n    map.on('mousemove', this._onMouseMove, this);\n    this._container.innerHTML=this.options.emptyString;\n    return this._container;\n  },\n\n  onRemove: function (map) {\n    map.off('mousemove', this._onMouseMove);\n  },\n\n  _onMouseMove: function (e) {\n    var lng = this.options.lngFormatter ? this.options.lngFormatter(e.latlng.lng) : Util.formatNum(e.latlng.lng, this.options.numDigits);\n    var lat = this.options.latFormatter ? this.options.latFormatter(e.latlng.lat) : Util.formatNum(e.latlng.lat, this.options.numDigits);\n    var value = this.options.lngFirst ? lng + this.options.separator + lat : lat + this.options.separator + lng;\n    var prefixAndValue = this.options.prefix + ' ' + value;\n    this._container.innerHTML = prefixAndValue;\n  }\n\n});\n\n// if( (window as any).L) {\n//     const L = (window as any).L;\n//     L.Control.MousePosition =  positionControl;\n//     L.control.mousePosition = function (options) {\n//         return new L.Control.MousePosition(options);\n//     };\n// }\n(Control as any).MousePosition =  positionControl;\n(control as any).mousePosition = function (options) {\n    return new (Control as any).MousePosition(options);\n};\n\nMap.mergeOptions({\n    positionControl: false\n});\n\nMap.addInitHook(function () {\n    if (this.options.positionControl) {\n        this.positionControl = new positionControl();\n        this.addControl(this.positionControl);\n    }\n});\n\nexport default positionControl;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","\n\nimport {\n    Map, Layer, FeatureGroup, Control, GeoJSON, popup,\n    Util, DomUtil, DomEvent, Evented, ControlOptions\n} from 'leaflet';\nimport { Draw } from 'leaflet-draw';\n// import * as L from 'leaflet';   //for Leaflet.Draw\n// const Draw = L.Draw;\n// const EditHandler = Draw.EditToolbar.Edit;\n\n\n\nimport MapInstance from '../map/instance';\n\n\n\ninterface EditControlOptions extends ControlOptions {\n    featureGroup : FeatureGroup\n}\n\ninterface FeatureLayer extends Layer {\n    feature : any;\n    geometry : any;\n    properties : {\n        [key:string]: any;\n        id : string;\n    }\n    toGeoJSON() : any;\n    setStyle( args : any );\n}\n\n\nexport default class FeatureEditor {\n\n\n    private map : MapInstance;\n    private feature : FeatureLayer;\n    private originalFeature: FeatureLayer;\n    private editingLayer : FeatureGroup;\n    private tool : EditFeature;\n    private visible : boolean;\n\n\n    constructor( map : MapInstance, feature : FeatureLayer, options ?: any ) {\n        this.map = map;\n        this.feature = feature;\n        this.visible = false;\n    }\n\n\n    /**\n     *\n     */\n    disable () {\n        this.doneEditing(false);\n        this.unregisterTool();\n    }\n\n    /**\n     *\n     */\n    unregisterTool() {\n        if(this.tool) {\n            this.tool.deactivate();\n            let map = this.map.getMap();\n            map.removeControl(this.tool);\n            map.removeLayer(this.editingLayer);\n        }\n    }\n\n    /**\n     * @param bool - flag specifying the visibility of the original feature being edited\n     */\n    showOriginalLayer(bool) {\n        if(!this.feature) return;\n        let id = this.feature.properties.id;\n        let layer = this.map.getFeatureLayer(id);\n        this.map.setFeatureVisibility(layer, bool);\n    }\n\n    /**\n     *\n     */\n    beginEditing() {\n\n        if(!this.visible) return;\n\n        this.originalFeature = GeoJSON.geometryToLayer(this.feature.toGeoJSON()) as FeatureLayer;\n        this.feature.properties._editing=true;\n\n        // get Leaflet.Map from instance\n        let map = this.map.getMap();\n\n        // find feature layer for specific feature\n        let feature = this.map.getFeatureLayer(this.feature.properties.id);\n        if(!feature) return;\n\n        //clone feature layer and wrap with FeatureGroup\n        // because Leaflet.Draw requires edited features\n        // be within a FeatureGroup\n        let editingLayer = this.editingLayer = new FeatureGroup().addTo(map);\n\n        //if the feature being edited is a multi-geometry\n        // (\"MultiPoint\", \"MultiLineString\", \"MultiPolygon\", \"GeometryCollection\")\n        // then we need to split them up into individual geometries and\n        // add them as separate layers which will all be editable\n        if (this.feature.geometry.type.indexOf(\"Multi\")===0) {\n            let type = this.feature.geometry.type.replace(\"Multi\",\"\");\n            this.feature.geometry.coordinates.each( (childCoords) => {\n                let shape = {type:type, coordinates: childCoords};\n                new GeoJSON(shape, {\n                    onEachFeature: (feature, layer) => {\n                        editingLayer.addLayer(layer);\n                    }\n                });\n            });\n\n        } else if(this.feature.geometry.type === 'GeometryCollection') {\n            this.feature.geometry.geometries.each( (childGeometry) => {\n                new GeoJSON(childGeometry, {\n                    onEachFeature:   (feature, layer) => {\n                        editingLayer.addLayer(layer);\n                    }\n                });\n            });\n\n        } else {\n            new GeoJSON(feature.toGeoJSON()).eachLayer( (layer) => {\n                editingLayer.addLayer(layer);\n            });\n        }\n\n        //make this feature invisible\n        this.showOriginalLayer(false);\n\n        //register LeafletDraw control with Edit mode only\n        // using just the feature layer identified\n        this.tool = new EditFeature({\n            featureGroup: editingLayer\n        } as ControlOptions).addTo(map);\n        this.tool.activate();\n\n    }\n\n    /**\n     * @param save - flag specifying whether to persist changes to the feature\n     */\n    doneEditing( save ?: boolean ) {\n\n        this.feature.properties._editing = false;\n\n        if(typeof(save) === 'undefined' || save) {\n\n            //if geometry changed\n            if(this.tool && this.tool.hasBeenEdited()) {\n\n                let isMulti = ~this.feature.geometry.type.indexOf(\"Multi\");\n                let isGeomColl = this.feature.geometry.type === 'GeometryCollection';\n                let geoms = [], coords = [], geometry;\n                this.editingLayer.eachLayer( (layer : Layer) => {\n                    let feature = (layer as FeatureLayer).toGeoJSON();\n                    geometry = feature.geometry;\n                    if(isMulti) {\n                        coords[coords.length] = geometry.coordinates;\n                    } else if(isGeomColl) {\n                        geoms[geoms.length] = feature;\n                    }\n                });\n\n                //update existing feature with edited information\n                if(isMulti)\n                    this.feature.geometry.coordinates = coords;\n                else if(isGeomColl)\n                    this.feature.geometry.geometries = geoms;\n                else\n                    this.feature.geometry = geometry;\n\n                //inform Map of change\n                this.map.replaceFeature(this.feature);\n\n            } else {\n                //restore original layer\n                this.showOriginalLayer(true);\n\n                //redraw feature with new style info\n                this.map.updateFeature(this.feature);\n            }\n\n        } else {\n            //restore original layer (only if feature is to be visible)\n            this.showOriginalLayer(this.visible);\n\n            //Redraw feature which has been updated with\n            // original style information (reset)\n            this.map.updateFeature(this.feature);\n        }\n\n        //lastly, break down the editing tool\n        if(this.tool) this.unregisterTool();\n\n    }\n\n    /**\n     *\n     */\n    addProperty() {\n\n    }\n\n    /**\n     *\n     */\n    highlightFeature() {\n        this.map.focusFeature(this.feature.properties.id);\n    }\n\n    /**\n     *\n     */\n    deleteFeature() {\n        this.map.removeFeature(this.feature.properties.id);\n    }\n\n    /**\n     * update rendered feature with latest info\n     */\n    updateFeature() {\n\n        //if not editing a temporary feature...\n        if(!this.editingLayer)\n            this.map.updateFeature(this.feature);\n\n        else {\n\n            //don't need to update existing rendered feature\n            // because it's been hidden and a temporary 'editing' version\n            // is on the map. So we need to update that instead.\n            // this.map.updateFeature(this.feature);\n\n\n            //update 'editing' version of the feature in question\n\n            let style = this.feature.properties.style;\n            this.editingLayer.eachLayer( (layer : Layer) => {\n                //do nothing for markers\n                if((layer as FeatureLayer).feature.geometry.type !== 'Point') {\n                    (layer as FeatureLayer).setStyle(style);\n                }\n            });\n\n        }\n\n    }\n\n    /**\n     *\n     */\n    cancelEditing () {\n        this.feature = this.originalFeature;\n        this.doneEditing(false);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n/**\n *\n */\nclass EditFeature extends Control {\n\n    private map : Map;\n    private enabled : boolean;\n    private handler : Draw.EditToolbar.Edit;\n\n    constructor( options ?: any ) {\n        super( Object.assign( {\n                position: 'bottomright',\n                draw: false,\n                edit: false\n            }, options || {})\n        );\n    }\n\n    onAdd (map : Map) {\n        this.map = map;\n        this.enabled = false;\n\n        let opts = { };\n        //needed or else L.EditToolbar.Edit fails to addHooks for PolyLine features\n        (opts as any).selectedPathOptions = {\n            dashArray: '10, 10',\n            fill: true,\n            fillColor: '#fe57a1',\n            fillOpacity: 0.1,\n            // Whether to user the existing layers color\n            maintainColor: false\n        };\n        (opts as any).featureGroup = (this.options as any).featureGroup;\n\n        this.handler = new Draw.EditToolbar.Edit(map, opts);\n\n        var container = DomUtil.create('div', 'leaflet-edit-feature');\n        return container;\n    }\n\n    onRemove (map : Map) {\n        this.deactivate();\n    }\n\n    activate() {\n        this.enabled = true;\n        this.handler.enable();\n    }\n\n    deactivate() {\n        this.enabled = false;\n        this.handler.disable();\n    }\n\n    hasBeenEdited() {\n        var result = false;\n        if((this.options as any).featureGroup) {\n            (this.options as any).featureGroup.eachLayer(function(layer) {\n                result = result || layer.edited;\n            });\n        }\n        return result;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n// import {\n//     Map, Layer, FeatureGroup, Control, GeoJSON, popup,\n//     Util, DomUtil, DomEvent, Evented\n// } from 'leaflet';\n// import * as Editable from \"leaflet-editable\";\n//\n// import MapInstance from '../map/instance';\n//\n//\n//\n//\n//\n// const CALLBACKS = {\n//     'marker'    : 'startMarker',\n//     'line'      : 'startPolyline',\n//     'polygon'   : 'startPolygon',\n//     'rectangle' : 'startRectangle',\n//     'circle'    : 'startCircle'\n// };\n//\n//\n// export const Events = {\n//     FEATURE_CREATED: 'feature:created',\n//     FEATURE_REMOVED: 'feature:removed',\n//     FEATURE_EDITED: 'feature:edited'\n// };\n//\n//\n// export default class FeatureEditor extends Evented {\n//\n//     private map : MapInstance;\n//     private editor : Editable;\n//     private editLayer : FeatureGroup;\n//     private featuresLayer : FeatureGroup;\n//\n//     constructor(map : MapInstance, options ?: any) {\n//         super();\n//\n//         this.map = map;\n//\n//         let leafletMap : Map = map.getMap();\n//         if(!leafletMap) throw new Error(\"No Leaflet map is configured\");\n//\n//         this.featuresLayer = map.getFeatureLayer();\n//\n//         this.editLayer = new FeatureGroup();\n//         this.editLayer.addTo(leafletMap);\n//\n//         let opts : any = {};\n//         Object.assign(opts, options||{}, {\n//             //editLayer : ...\n//             featuresLayer : this.editLayer //map.getFeatureLayer()\n//             // drawingCSSClass: 'leaflet-editable-drawing',\n//             // drawingCursor: 'crosshair',\n//             // skipMiddleMarkers: true\n//         });\n//\n//         //create and register editable instance on leaflet map\n//         let editor = new Editable(leafletMap, opts);\n//         (leafletMap as any).editTools = editor;\n//         this.editor = editor;\n//\n//         this.editor.on('editable:drawing:end', (event : any) => {\n//             //have to wrap handler in a timeout in order to not inadvertently\n//             // block the clean up of event handlers within Editable\n//             setTimeout(() => { this.onFeatureCreated(event) },50);\n//         });\n//         // this.editor.on('editable:editing', (event : any) => { this.onFeatureEdited(event) })\n//\n//         this.editor.on('editable:drawing:start', (event: any) => console.log(\"Drawing Start\") );\n//         this.editor.on('editable:drawing:end', (event: any) => console.log(\"Drawing End\") );\n//         this.editor.on('editable:drawing:cancel', (event: any) => console.log(\"Drawing Cancel\") );\n//         this.editor.on('editable:drawing:commit', (event: any) => console.log(\"Drawing Commit\") );\n//\n//         this.editor.on(\n//             'editable:drawing:start editable:drawing:end ' +\n//             'editable:drawing:cancel editable:drawing:commit ' +\n//             'editable:drawing:mousedown editable:drawing:mouseup ' +\n//             'editable:drawing:click editable:drawing:move ' +\n//             'editable:drawing:clicked',\n//             (event : any) => {\n//                 console.log(\"Editor event: \" + event.type);\n//                 if(event.layer && event.layer.options.popup) {\n//                     this.updateFeaturePopup(event.layer, event.layer.options.popup);\n//                 }\n//             }\n//         );\n//\n//         this.editor.on(\n//             'editable:vertex:new editable:vertex:click ' +\n//             'editable:vertex:clicked editable:vertex:rawclick ' +\n//             'editable:vertex:deleted editable:vertex:ctrlclick ' +\n//             'editable:vertex:shiftclick editable:vertex:metakeyclick ' +\n//             'editable:vertex:altclick editable:vertex:contextmenu ' +\n//             'editable:vertex:mousedown editable:vertex:drag ' +\n//             'editable:vertex:dragstart editable:vertex:dragend ' +\n//             'editable:middlemarker:mousedown',\n//             (event : any) => {\n//                 console.log(\"Vertex event: \" + event.type);\n//                 // if(event.layer && event.layer.options.popup) {\n//                 //     this.updateFeaturePopup(event.layer, event.layer.options.popup);\n//                 // }\n//             }\n//         );\n//\n//         if(opts.marker) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.marker],\n//                 kind: 'marker',\n//                 html: opts.marker.icon ? opts.marker.icon : ''\n//             }));\n//         }\n//         if(opts.line) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.line],\n//                 kind: 'line',\n//                 html: opts.line.icon ? opts.line.icon : '\\\\/\\\\'\n//             }));\n//         }\n//         if(opts.polygon) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.polygon],\n//                 kind: 'polygon',\n//                 html: opts.polygon.icon ? opts.polygon.icon : ''\n//             }));\n//         }\n//         if(opts.rectangle) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.rectangle],\n//                 kind: 'rectangle',\n//                 html: opts.rectangle.icon ? opts.rectangle.icon : ''\n//             }));\n//         }\n//         if(opts.circle) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.circle],\n//                 kind: 'circle',\n//                 html: opts.circle.icon ? opts.circle.icon : ''\n//             }));\n//         }\n//     }\n//\n//     isDrawing() : boolean {\n//         return this.editor ? this.editor.drawing() : false;\n//     }\n//\n//     cancel() {\n//         if(this.editor) this.editor.stopDrawing();\n//     }\n//\n//     /**\n//      * @param feature Feature to be edited\n//      */\n//     enableFeatureEdit( feature : any ) {\n//         if(!feature) return;\n//\n//         if(!feature.properties) feature.properties = {};\n//\n//         let fid =  this.getFeatureId(feature, true);\n//\n//         //make a clone of the feature to be edited\n//         let json = (feature as any).toGeoJSON();\n//         let editedLayer = GeoJSON.geometryToLayer(json);\n//         Util.setOptions(editedLayer, { originalLayerId : fid });\n//\n//         //hide that feature on featuresLayer\n//         this.map.setFeatureVisibility(feature, false);\n//\n//         //and add the editble clone of it to the edit layer\n//         this.editLayer.addLayer(editedLayer);\n//         (editedLayer as any).toggleEdit();\n//     }\n//\n//     /**\n//      * @param feature Feature being edited\n//      */\n//     applyFeatureEdit( feature : any ) {\n//\n//         let editedLayer = this.findEditedFeatureLayer(feature);\n//         if(!editedLayer) return;\n//\n//         (editedLayer as any).toggleEdit();                   //turn off editor\n//\n//         let json = (editedLayer as any).toGeoJSON();\n//         this.editLayer.removeLayer(editedLayer);    //remove from edit layer\n//\n//         // let updatedLayer = GeoJSON.geometryToLayer(json);\n//         this.map.replaceFeature(json);\n//         this.map.setFeatureVisibility(feature, true);\n//\n//     }\n//\n//     /**\n//      * @param feature Feature being edited\n//      */\n//     cancelFeatureEdit( feature : any ) {\n//\n//         let editedLayer = this.findEditedFeatureLayer(feature);\n//         if(!editedLayer) return;\n//\n//         (editedLayer as any).toggleEdit();                   //turn off editor\n//         this.editLayer.removeLayer(editedLayer);    //and remove from edit layer\n//\n//         //re-show the original feature layer\n//         this.map.setFeatureVisibility(feature, true);\n//\n//     }\n//\n//     /**\n//      * @param feature Feature Layer associated with an editable feature\n//      * @return editable Feature Layer assocaited with the specified parameter Feature Layer\n//      */\n//     findEditedFeatureLayer( feature : any ) : Layer {\n//         let editedLayer : Layer = null;\n//         this.editLayer.eachLayer( (layer : any) => {\n//             let fid = this.getFeatureId(layer);\n//             if( !editedLayer && fid == layer.originalLayerId ) {\n//                 editedLayer = layer as Layer;\n//             }\n//         });\n//         return editedLayer;\n//     }\n//\n//     /**\n//      * @param feature Feature\n//      * @param createAsNeeded flag indicating whether to create an ID if feature has none\n//      * @return feature id or null\n//      */\n//     getFeatureId( feature : any , createAsNeeded ?: boolean) : string {\n//         if(!feature) return null;\n//         if(!feature.properties) feature.properties = {};\n//         let featureId = feature.properties.id || null;\n//         if(!featureId && true === createAsNeeded)\n//             featureId = feature.properties.id = Math.round(Math.random()*9999);\n//         return featureId;\n//     }\n//\n//\n//\n//\n//     onFeatureCreated(event : any) {\n//         let feature : any = event.layer;\n//\n//         if( typeof(feature.editEnabled) !== 'undefined' && feature.editEnabled() ) {\n//             feature.toggleEdit();\n//         }\n//\n//         this.editLayer.removeLayer(feature);\n//         if(this.featuresLayer) {\n//             this.featuresLayer.addLayer(feature);\n//             feature.on('dblclick', DomEvent.stop).on('dblclick', () => {\n//\n//                 (feature as any).toggleEdit();\n//\n//                 if(feature.editEnabled()) { //'editable:enable'\n//                     //add a save and cancel btn...\n//\n//                     let latLng = null;\n//                     if(typeof(feature.getLatLng) !== 'undefined') {\n//                         latLng = feature.getLatLng();\n//                     } else if(typeof(feature.getCenter()) !== 'undefined') {\n//                         latLng = feature.getCenter();\n//                     }\n//\n//                     let fp = popup({\n//                         autoClose: false,\n//                         closeButton: false,\n//                         closeOnEscapeKey: false,\n//                         closeOnClick: false\n//                     }).setLatLng(latLng)\n//                     .setContent('<button type=\"button\">Save</button> &nbsp;&nbsp;&nbsp; <button type=\"button\">Cancel</button>')\n//                     .openOn(this.map.getMap());\n//\n//                     Util.setOptions(feature, {popup : fp});\n//\n//                 } else if( feature.options.popup ) {\n//                     feature.options.popup.remove();\n//                     // feature.editor.off('editable:drawing:start,editable:drawing:end,editable:drawing:cancel,editable:drawing:commit,editable:drawing:mousedown,editable:drawing:mouseup,editable:drawing:click,editable:drawing:move,editable:drawing:clicked');\n//\n//                 }\n//             });\n//         }\n//         this.fire(Events.FEATURE_CREATED, feature);\n//     }\n//\n//     onFeatureEdited(event : any) {\n//         let feature = event.layer;\n//         this.fire(Events.FEATURE_EDITED, feature);\n//     }\n//\n//\n//     updateFeaturePopup(feature, popup) {\n//         let latLng = null;\n//         if(typeof(feature.getLatLng) !== 'undefined') {\n//             latLng = feature.getLatLng();\n//         } else if(typeof(feature.getCenter()) !== 'undefined') {\n//             latLng = feature.getCenter();\n//         }\n//         if(latLng)\n//             popup.setLatLng(latLng);\n//     }\n// }\n//\n//\n//\n//\n//\n// class EditControl extends Control {\n//\n//     constructor(options ?: any) {\n//         super(options);\n//     }\n//\n//     initialize (options ?: any) {\n// \t\tUtil.setOptions(this, options);\n//     }\n//\n//     onAdd (map : Map) {\n//         let container : HTMLElement = DomUtil.create('div', 'leaflet-control leaflet-bar'),\n//             activateBtn : HTMLAnchorElement = DomUtil.create('a', '', container) as HTMLAnchorElement;\n//\n//         activateBtn.href = '#';\n//         activateBtn.title = 'Create a new ' + (this.options as any).kind;\n//         activateBtn.innerHTML = (this.options as any).html;\n//\n//         DomEvent.on(activateBtn, 'click', DomEvent.stop)\n//         .on(activateBtn, 'click', function () {\n//             (window as any).LAYER = this.options.callback.call( (map as any).editTools );\n//         }, this);\n//\n//         return container;\n//     }\n//\n// }\n","\nimport * as Q from \"q\";\nimport {\n    ItemService, XHRHttpClient, QueryFactory, Config\n} from '@geoplatform/client';\n\n\n\nconst ogcExpr = /OGC.+\\(([A-Z\\-]+)\\)/;\nconst esriExpr = /Esri REST ([A-Za-z]+) Service/;\nconst keyFn = (expr, str) => {\n    let m = expr.exec(str);\n    return (m && m.length) ? m[1] : null;\n};\n\nvar types = {\n\n    ESRI_FEATURE_SERVER: {\n        \"id\":\"48980c5bad0c8d4666b393874eb5279a\",\n        \"uri\":\"http://www.geoplatform.gov/spec/esri-feature-rest\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"Esri ArcGIS Feature Server REST API\",\n        \"label\":\"Esri REST Feature Service\"\n    },\n\n    ESRI_IMAGE_SERVER: {\n        \"id\":\"bcdf764e52064c84323f3f1baea7e245\",\n        \"uri\":\"http://www.geoplatform.gov/spec/esri-image-rest\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"Esri ArcGIS Image Server REST API\",\n        \"label\":\"Esri REST Image Service\"\n    },\n\n    ESRI_MAP_SERVER: {\n        \"id\":\"370cf6ca5d91c07b63329b8384fe76c7\",\n        \"uri\":\"http://www.geoplatform.gov/spec/esri-map-rest\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"Esri ArcGIS Map Server REST API\",\n        \"label\":\"Esri REST Map Service\"\n    },\n\n    ESRI_TILE_SERVER: {\n        \"id\": \"c75570ff2523b1a1631afe7ddac27beb\",\n        \"uri\": \"http://www.geoplatform.gov/spec/esri-tile-rest\",\n        \"type\": \"dct:Standard\",\n        \"description\": \"Esri ArcGIS Tile Server REST API\",\n        \"label\": \"Esri REST Tile Service\"\n    },\n\n    KML: {\n        \"id\":\"c0b39ca2049ba2184472ff27408ffd7e\",\n        \"uri\":\"http://opengis.net/spec/kml\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Keyhole Markup Language (KML)\",\n        \"label\":\"OGC Keyhole Markup Language (KML)\"\n    },\n\n    CSW: {\n        \"id\":\"60de6a422475493b7901ae453d6f4562\",\n        \"uri\":\"http://opengis.net/spec/csw\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Catalog Service (CSW)\",\n        \"label\":\"OGC Web Catalog Service (CSW)\"\n    },\n\n    WCS: {\n        \"id\":\"a7e5a2d81a83d4eae9bf9138f24d0a32\",\n        \"uri\":\"http://opengis.net/spec/wcs\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Coverage Service (WCS)\",\n        \"label\":\"OGC Web Coverage Service (WCS)\"\n    },\n\n    WFS: {\n        \"id\":\"e70e43ed52f83634285a09e959734bff\",\n        \"uri\":\"http://opengis.net/spec/wfs\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Feature Service (WFS)\",\n        \"label\":\"OGC Web Feature Service (WFS)\"\n    },\n\n    WMS: {\n        \"id\":\"abed5a00c536fb2d7019092c37ed634c\",\n        \"uri\":\"http://opengis.net/spec/wms\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Map Service (WMS)\",\n        \"label\":\"OGC Web Map Service (WMS)\"\n    },\n\n    WMTS: {\n        \"id\":\"757858ae77cf8c602b39294c27632dd7\",\n        \"uri\":\"http://opengis.net/spec/wmts\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Map Tile Service (WMTS)\",\n        \"label\":\"OGC Web Map Tile Service (WMTS)\"\n    },\n\n    WMST: {\n        \"id\": \"faae5bff49b1144d500380cbc055c1e5\",\n        \"uri\": \"http://www.geoplatform.gov/spec/ogc-wms-t\",\n        \"type\": \"dct:Standard\",\n        \"description\": \"OGC WMS support for temporal according to OGC Best Practice guidance\",\n        \"label\": \"OGC WMS-T Service\"\n    },\n\n    FEED: {\n        \"id\": \"8edc61870e534a1f23dc967753da3b72\",\n        \"uri\": \"http://www.geoplatform.gov/spec/feed\",\n        \"type\": \"dct:Standard\",\n        \"description\": \"GeoPlatform GeoJSON Feed Service converts an Atom/RSS feed (including GeoRSS and CAP extensions) to GeoJSON\",\n        \"label\": \"GeoPlatform GeoJSON Feed Service\"\n    },\n\n    //\n    //method to allow refreshing list later\n    refresh: updateList\n};\n\nfunction updateList(service : ItemService) {\n\n    let url = Config.ualUrl;\n    if(!url) {\n        console.log(\"WARN : ServiceTypes - no GeoPlatform API URL configured, unable to load service types\");\n    } else {\n\n        let query = QueryFactory()\n            .types('dct:Standard')\n            .resourceTypes('ServiceType')\n            .pageSize(50);\n\n\n        let svc = null;\n        //if a service was provided to be used, use it\n        if(service && typeof(service.search) !== 'undefined') {\n            svc = service;\n        } else { // otherwise, use defaults\n            svc = new ItemService(url, new XHRHttpClient());\n        }\n\n        svc.search(query).then( data => {\n\n            for(let i=0; i<data.results.length; ++i) {\n\n                let type = data.results[i],\n                    key = null,\n                    label = type.label;\n\n                if(~label.indexOf(\"WMS-T\")) {\n                    key = 'WMST';\n                    type.supported = true;\n\n                } else if(~label.indexOf('OGC')) {\n                    key = keyFn(ogcExpr, label);\n                    type.supported = 'WMS' === key || 'WMTS' === key;\n\n                } else if(~label.indexOf('Esri')) {\n                    key = keyFn(esriExpr, label);\n                    type.supported = true;\n                    key = 'ESRI_' + key.toUpperCase() + '_SERVER';\n\n                } else if(~label.indexOf(\"Feed\")) {\n                    key = \"FEED\";\n                    type.supported = true;\n\n                } else {\n                    key = label;\n\n                }\n\n                types[key] = type;\n            }\n            // console.log(types);\n        })\n        .catch( error => {\n            console.log(\"Error loading supported service types: \" + error.message);\n        });\n    }\n}\n\nexport default types;\n","\nconst MapResourceTypes = {\n    GeoPlatformMap: \"http://www.geoplatform.gov/ont/openmap/GeoplatformMap\",\n    AGOL: 'http://www.geoplatform.gov/ont/openmap/AGOLMap'\n};\n\nconst LayerResourceTypes = {\n    MapBoxVectorTile : 'http://www.geoplatform.gov/ont/openlayer/MapBoxVectorTileLayer',\n    OSM: 'http://www.geoplatform.gov/ont/openlayer/OSMLayer',\n    BaseLayer: 'http://www.geoplatform.gov/ont/openlayer/BaseLayer'\n};\n\nconst ServiceResourceTypes = {\n    WMS: 'http://opengis.net/spec/wms',\n    WMTS: 'http://opengis.net/spec/wmts',\n    WMST: 'http://www.geoplatform.gov/spec/ogc-wms-t',\n    WFS: 'http://opengis.net/spec/wfs',\n    WCS: 'http://opengis.net/spec/wcs',\n    CSW: 'http://opengis.net/spec/csw',\n    FEED: 'http://www.geoplatform.gov/spec/feed',\n    EsriTile: 'http://www.geoplatform.gov/spec/esri-tile-rest',\n    EsriMap: 'http://www.geoplatform.gov/spec/esri-map-rest',\n    EsriImage: 'http://www.geoplatform.gov/spec/esri-image-rest',\n    EsriFeature: 'http://www.geoplatform.gov/spec/esri-feature-rest'\n};\n\nexport {\n    MapResourceTypes,\n    LayerResourceTypes,\n    ServiceResourceTypes\n}\n","\nimport * as Q from \"q\";\nimport { LayerResourceTypes } from \"../shared/resource-types\";\nimport {\n    QueryFactory, LayerService, XHRHttpClient, Config\n}  from '@geoplatform/client';\n\n\n/**\n * @param layerService - optional, LayerService to use to fetch the layer\n * @return Promise resolving OpenStreet Map GeoPlatform Layer\n */\nexport default {\n\n    /**\n     * @param  layer - GeoPlatform Layer object\n     * @return boolean, true if is an OSM layer\n     */\n    test : function(layer) {\n        return  layer &&\n                layer.resourceTypes &&\n                layer.resourceTypes.length &&\n                ~layer.resourceTypes.indexOf(LayerResourceTypes.OSM);\n    },\n\n    get : function(layerService ?: LayerService) : any {\n        let query = QueryFactory()\n            .fields('*')\n            .resourceTypes(LayerResourceTypes.OSM);\n        if(!layerService)\n            layerService = new LayerService(Config.ualUrl, new XHRHttpClient());\n        return layerService.search(query)\n        .then( response => response.results.length ? response.results[0] : null);\n    }\n\n};\n","\nimport * as Q from 'q';\nimport OSM from './osm';\nimport { Config, LayerService, XHRHttpClient } from '@geoplatform/client';\n\n\nconst WORLD_STREET_LAYER = '86a8babde086689e21248669ba4ed579';\n\nvar DefaultBaseLayer = {\n\n    get: function(layerService : LayerService) {\n        if(!layerService) {\n            layerService = new LayerService(Config.ualUrl, new XHRHttpClient());\n        }\n        let baseLayerId = Config.defaultBaseLayerId || WORLD_STREET_LAYER;\n        return layerService.get(baseLayerId)\n            .catch( (e : Error) => {\n                return OSM.get();\n            });\n    },\n\n    set: function(layer : any) {\n        let id = null;\n        if(layer && layer.id) id = layer.id;\n        else if(layer && typeof(layer) === 'string') id = layer;\n        if(id) {\n            Config.configure({'defaultBaseLayerId': layer.id});\n        }\n    }\n};\n\nexport default DefaultBaseLayer;\n","\n/* jshint ignore:start */\nimport * as MarkerCluster from 'leaflet.markercluster';\nimport \"leaflet.markercluster\";\nimport { Util, MarkerClusterGroup, GeoJSON } from 'leaflet';\nimport * as esri from \"esri-leaflet\";\n\n/* esri-leaflet-cluster - v2.0.0 - Thu Aug 18 2016 17:12:43 GMT-0700 (PDT)\n * Copyright (c) 2016 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar version = \"2.0.0\";\n\nvar BaseClusteredFeatureLayer = esri.FeatureManager.extend({\n\n  statics: {\n    EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose',\n    CLUSTEREVENTS: 'clusterclick clusterdblclick clustermouseover clustermouseout clustermousemove clustercontextmenu'\n  },\n\n  /**\n   * Constructor\n   */\n\n  initialize: function (options) {\n    esri.FeatureManager.prototype.initialize.call(this, options);\n\n    options = Util.setOptions(this, options);\n\n    this._layers = {};\n    this._leafletIds = {};\n\n    this.cluster = new MarkerClusterGroup(options);\n    this._key = 'c' + (Math.random() * 1e9).toString(36).replace('.', '_');\n\n    this.cluster.addEventParent(this);\n  },\n\n  /**\n   * Layer Interface\n   */\n\n  onAdd: function (map) {\n    esri.FeatureManager.prototype.onAdd.call(this, map);\n    this._map.addLayer(this.cluster);\n\n    // NOTE !!!!!!!\n    // Using this type of layer requires map.maxZoom to be set during map creation!\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  },\n\n  onRemove: function (map) {\n    esri.FeatureManager.prototype.onRemove.call(this, map);\n    this._map.removeLayer(this.cluster);\n  },\n\n  /**\n   * Feature Management Methods\n   */\n\n  createLayers: function (features) {\n    var markers = [];\n\n    for (var i = features.length - 1; i >= 0; i--) {\n      var geojson = features[i];\n      var layer = this._layers[geojson.id];\n\n      if (!layer) {\n        var newLayer : any = GeoJSON.geometryToLayer(geojson, this.options);\n        newLayer.feature = GeoJSON.asFeature(geojson);\n        newLayer.defaultOptions = newLayer.options;\n        newLayer._leaflet_id = this._key + '_' + geojson.id;\n\n        this.resetStyle(newLayer.feature.id);\n\n        // cache the layer\n        this._layers[newLayer.feature.id] = newLayer;\n\n        this._leafletIds[newLayer._leaflet_id] = geojson.id;\n\n        if (this.options.onEachFeature) {\n          this.options.onEachFeature(newLayer.feature, newLayer);\n        }\n\n        this.fire('createfeature', {\n          feature: newLayer.feature\n        });\n\n        // add the layer if it is within the time bounds or our layer is not time enabled\n        if (!this.options.timeField || (this.options.timeField && this._featureWithinTimeRange(geojson))) {\n          markers.push(newLayer);\n        }\n      }\n    }\n\n    if (markers.length) {\n      this.cluster.addLayers(markers);\n    }\n  },\n\n  addLayers: function (ids) {\n    var layersToAdd = [];\n    for (var i = ids.length - 1; i >= 0; i--) {\n      var layer = this._layers[ids[i]];\n      this.fire('addfeature', {\n        feature: layer.feature\n      });\n      layersToAdd.push(layer);\n    }\n    this.cluster.addLayers(layersToAdd);\n  },\n\n  removeLayers: function (ids, permanent) {\n    var layersToRemove = [];\n    for (var i = ids.length - 1; i >= 0; i--) {\n      var id = ids[i];\n      var layer = this._layers[id];\n      this.fire('removefeature', {\n        feature: layer.feature,\n        permanent: permanent\n      });\n      layersToRemove.push(layer);\n      if (this._layers[id] && permanent) {\n        delete this._layers[id];\n      }\n    }\n    this.cluster.removeLayers(layersToRemove);\n  },\n\n  /**\n   * Styling Methods\n   */\n\n  resetStyle: function (id) {\n    var layer = this._layers[id];\n\n    if (layer) {\n      layer.options = layer.defaultOptions;\n      this.setFeatureStyle(layer.feature.id, this.options.style);\n    }\n\n    return this;\n  },\n\n  setStyle: function (style) {\n    this.eachFeature(function (layer) {\n      this.setFeatureStyle(layer.feature.id, style);\n    }, this);\n    return this;\n  },\n\n  setFeatureStyle: function (id, style) {\n    var layer = this._layers[id];\n\n    if (typeof style === 'function') {\n      style = style(layer.feature);\n    }\n    if (layer.setStyle) {\n      layer.setStyle(style);\n    }\n  },\n\n  /**\n   * Utility Methods\n   */\n\n  eachFeature: function (fn, context) {\n    for (var i in this._layers) {\n      fn.call(context, this._layers[i]);\n    }\n    return this;\n  },\n\n  getFeature: function (id) {\n    return this._layers[id];\n  }\n});\n\n// function featureLayer (options) {\n//   return new FeatureLayer(options);\n// }\n//\n// export {\n//     FeatureLayer,\n//     featureLayer as default,\n//     version as VERSION\n// }\n\nexport default BaseClusteredFeatureLayer;\n","\n// import * as jquery from \"jquery\";\n// const jQuery = jquery;\n\nimport * as Q from \"q\";\nimport {\n    Config, XHRHttpClient, LayerService\n} from '@geoplatform/client';\n\n/**\n * Fetches style information from GeoPlatform UAL\n * @param  id - identifier of layer to resolve style for\n */\nfunction featureStyleResolver(id : string) : Promise<any> {\n\n    let service = new LayerService( Config.ualUrl, new XHRHttpClient() );\n    return service.style(id).catch( (e:Error) => {\n        let err = new Error(`Unable to download style for layer ${id} because of an error; ${e.message}`);\n        return Promise.reject(err);\n    });\n\n    // return new Promise<any>( (resolve, reject) => {\n    //\n    //     if(!jQuery) {\n    //         reject(new Error(\"Unable to load feature layer style, jQuery is not installed\"));\n    //     }\n    //     jQuery.ajax({\n    //        url: Config.ualUrl + '/api/layers/' + id + '/style',\n    //        dataType: 'json',\n    //        success: function(data) { resolve(data); },\n    //        error: function(xhr, status, message) {\n    //            let em = `FeatureStyleResolver() -\n    //                Error loading style information for layer ${id} : ${message}`;\n    //            reject( new Error(em) );\n    //        }\n    //     });\n    //\n    // });\n}\n\nexport default featureStyleResolver;\n","\n\nfunction featurePopupTemplate(feature) {\n\n    let props = Object.keys(feature.properties);\n\n    const pFn = function(list, names) {\n        if(!list || !list.find) return null;\n        let match = list.find( name => {\n            let lc = name.toLowerCase();\n            return names.indexOf(lc)>=0;\n        });\n        return match;\n    };\n\n    let titleProp = pFn(props, ['title','name','label']);\n    let title = titleProp ? feature.properties[titleProp] : \"Untitled\";\n\n    let descProp = pFn(props, ['description', 'summary', 'descript']);\n    let description = descProp ? feature.properties[descProp] : \"No description provided\";\n\n    let result = '<div class=\"feature-popup\">' +\n        '<h5>' + title + '</h5>' +\n        '<p>' + description + '</p>';\n\n    if(feature.properties.modified) {\n        let modified = new Date(feature.properties.modified);\n        result += '<div><span class=\"label\">Updated</span><span class=\"value\">' +\n            modified.toDateString() + '</span></div>';\n    }\n\n    if(feature.properties['cap:effective']) {\n        let date = new Date(feature.properties['cap:effective']);\n        result += '<div>' +\n            '<span class=\"label\">Effective</span>' +\n            '<span class=\"value\">' +\n            date.toDateString() + ' ' + date.toTimeString() +\n            '</span>' +\n            '</div>';\n    }\n    if(feature.properties['cap:expires']) {\n        let date = new Date(feature.properties['cap:expires']);\n        result += '<div>' +\n            '<span class=\"label\">Expires</span>' +\n            '<span class=\"value\">' +\n            date.toDateString() + ' ' + date.toTimeString() +\n            '</span>' +\n            '</div>';\n    }\n\n    let linkProp = pFn(props, ['landingpage','link','website']);\n    if(linkProp) {\n        result += '<br>';\n        result += '<a href=\"' + feature.properties[linkProp] + '\" target=\"_blank\">link</a>';\n    }\n\n    result += '<hr>';\n\n    for(let prop in feature.properties) {\n        if(titleProp === prop || descProp === prop ||\n            linkProp === prop || 'modified' === prop)\n            continue;\n        let value = feature.properties[prop];\n        if(typeof(value) === 'object') {\n            for(let p in value) {\n                result += '<div>' +\n                    '<span class=\"label\">' + prop + '.' + p + '</span>' +\n                    '<span class=\"value\">' + value[p] + '</span>' +\n                    '</div>';\n            }\n        } else {\n            result += '<div>' +\n                '<span class=\"label\">' + prop + '</span>' +\n                '<span class=\"value\">' + value + '</span>' +\n                '</div>';\n        }\n    }\n    result += '</div>';\n    return result;\n}\n\nexport default featurePopupTemplate;\n","\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport { Config } from '@geoplatform/client';\n\nimport {\n    Control,\n    icon as iconFn,\n    marker as markerFn,\n    circleMarker as circleMarkerFn,\n    SVG, svg, Canvas, canvas,\n    Util,\n    Layer\n} from 'leaflet';\n\nimport BaseClusteredFeatureLayer from './base-clustered-feature-layer';\nimport featureStyleResolver from '../shared/style-resolver';\nimport featurePopupTemplate from '../shared/popup-template';\n\n\n/**\n * Clustered Feature Layer\n * Provides custom style loading and point-ilization as well\n * as adding visibility and opacity manipulation methods\n */\nvar ClusteredFeatureLayer = BaseClusteredFeatureLayer.extend({\n\n    currentVisibility: true,\n    currentOpacity: 1.0,\n\n    _gpStyle : { color: \"#00f\", weight: 2, fillColor: '#00f', fillOpacity: 0.3 },\n\n    /**\n     * @param  feature - GeoJSON Point Feature\n     * @param latlng - L.LatLng\n     * @return L.Marker\n     */\n    pointToLayerFn: function (feature, latlng) {\n\n        var style = feature && feature.properties ? feature.properties.style : null;\n        if(!style && typeof this.options.style === 'function') {\n            // console.log(\"Using local style function\");\n            try {\n                style = this.options.style(feature);\n            } catch(e) {\n                console.log(\"error using style function in ClusteredFeatureLayer: \" + e.message);\n            }\n        }\n\n        style = style || this.options.style || {};\n        style.radius      = style['stroke-width'] || style.radius || 4;\n        style.weight      = style['stroke-width'] || style.weight || 2;\n        style.color       = style.stroke || style.color || '#03f';\n        style.opacity     = style['stroke-opacity'] || style.opacity || 0.9;\n        style.fillOpacity = style['fill-opacity'] || style.opacity || 0.3;\n        style.fillColor   = style.fill || style.color || '#03f';\n        style.renderer    = this.options.renderer;  //important for pane!\n\n        let marker = null;\n        if(style.shape === 'image') {\n            let width = style.width || 16;\n            let height = style.height || 16;\n            var icon = iconFn( {\n                iconUrl: style.content, //base64 encoded string\n                iconSize: [width, height],\n                iconAnchor: [width*0.5, height*0.5],\n                popupAnchor: [0, -11],\n            });\n            let mopts = { icon: icon };\n            if(Config.leafletPane) (mopts as any).pane = Config.leafletPane;\n            marker = markerFn( latlng, mopts);\n        } else {\n            marker = circleMarkerFn(latlng, style);\n        }\n\n        let popupTemplate = this.options.popupTemplate || featurePopupTemplate;\n        marker.bindPopup(popupTemplate(feature));\n\n        return marker;\n    },\n\n    /**\n     * for all non-point features, bind a popup\n     * @param  feature - GeoJSON feature\n     * @param layer - L.Layer representing feature\n     */\n    eachFeatureFn: function(feature, layer) {\n        if(!feature || !feature.geometry || feature.geometry.type === 'Point') {\n            return;\n        }\n        layer.bindPopup(featurePopupTemplate(feature));\n    },\n\n\n\n    initialize: function (options) {\n\n        var self = this;\n\n        options = options || {};\n\n        if(Config.leafletPane)\n            options.pane = Config.leafletPane;\n\n        options.pointToLayer = Util.bind(this.pointToLayerFn, this);\n        options.onEachFeature = Util.bind(this.eachFeatureFn, this);\n        // options.fields = ['FID', 'type', 'title', 'geometry'];\n\n        //Increase from 1 to increase the distance away from the center that spiderfied markers are placed.\n        // This needs to be increased to ensure all markers can be clicked\n        // when spiderfied (some get stuck under the spider legs)\n        options.spiderfyDistanceMultiplier = 2;\n\n        let getGPStyle = () => { return this._gpStyle; };\n        options.style = options.style || getGPStyle;\n        if(options.styleResolver) {\n            this.styleResolver = options.styleResolver;\n        }\n\n        //in order to put features-based layers into same pane as tile layers,\n        // must specify renderer and set desired pane on that\n        let svgOpts = { };\n        if(Config.leafletPane)\n            (svgOpts as any).pane = Config.leafletPane;\n        var renderer = (SVG && svg(svgOpts)) || (Canvas && canvas());\n        options.renderer = renderer;\n\n        BaseClusteredFeatureLayer.prototype.initialize.call(this, options);\n\n        this.on('load', function() {\n            if(typeof this.options.zIndex !== 'undefined')\n                this.setZIndex(this.options.zIndex);\n        });\n\n    },\n\n    onAdd: function(map) {\n        BaseClusteredFeatureLayer.prototype.onAdd.call(this, map);\n\n        if(this.options.layerId) {\n            this.loadStyle(this.options.layerId);\n        }\n    },\n\n    /** override super class' method to set viz/opac after sub layers created */\n    createLayers: function (features) {\n        BaseClusteredFeatureLayer.prototype.createLayers.call(this, features);\n        this.setVisibility(this.currentVisibility);\n        this.setOpacity(this.currentOpacity);\n    },\n\n    /**\n     * @param index\n     */\n    setZIndex : function (index) {\n        this.options.zIndex = index;\n        for(var id in this._layers) {\n\n            let lyr = this._layers[id];\n            if(lyr.setZIndex)\n                lyr.setZIndex(index);\n            else if(lyr._updateZIndex)\n                lyr._updateZIndex(index);\n            else if(lyr._renderer && lyr._renderer._container){\n                lyr._renderer._container.style.zIndex = index;\n            } else {\n                // console.log(\"Clustered feature layer child \" + id + \" does not support ordering using z-index\");\n            }\n        }\n    },\n\n    /** */\n    toggleVisibility: function() {\n\n        this.currentVisibility = !this.currentVisibility;\n        this.setVisibility(this.currentVisibility);\n\n        // //clustered features\n        // if(this.cluster && this.cluster._featureGroup && this.cluster._featureGroup._layers) {\n        //     for(let id in this.cluster._featureGroup._layers) {\n        //         let layer = this.cluster._featureGroup._layers[id];\n        //         if(layer._icon) {\n        //             jQuery(layer._icon).toggleClass('invisible');\n        //         }\n        //     }\n        // }\n        //\n        // //non-clustered features\n        // if(this._layers) {\n        //     for(let id in this._layers)\n        //         this._layers[id].toggleVisibility();\n        // }\n    },\n\n    /**\n     * @param bool - flag\n     */\n    setVisibility: function(bool) {\n\n        this.currentVisibility = !!bool;\n\n        if(this.options.renderer._container) {\n            this.options.renderer._container.style.display = bool ? '' : 'none';\n        }\n\n        //clustered features\n        if(this.cluster && this.cluster._featureGroup && this.cluster._featureGroup._layers) {\n            for(let id in this.cluster._featureGroup._layers) {\n                let layer = this.cluster._featureGroup._layers[id];\n                if(layer._icon) {\n                    //probably is a more efficient way to do this,\n                    // but this works currently.\n                    // TODO look at using\n                    //  markerCluster.refreshIconOptions({className:'invisible'});\n                    var icon = jQuery(layer._icon);\n                    if(bool) icon.removeClass('invisible');\n                    else icon.addClass('invisible');\n                }\n            }\n        }\n\n        //non-clustered features\n        if(this._layers) {\n            for(let id in this._layers) {\n                let layer = this._layers[id];\n                if(layer.setVisibility)\n                    layer.setVisibility(bool);\n                else if(layer.setStyle)\n                    layer.setStyle({display: bool ? '':'none'});\n            }\n        }\n    },\n\n    /**\n     * @param  opacity\n     */\n    setOpacity: function(opacity) {\n\n        this.currentOpacity = isNaN(opacity) ? 1.0 : opacity*1;\n\n        //clustered features\n        if(this.cluster && this.cluster._featureGroup && this.cluster._featureGroup._layers) {\n            for(let id in this.cluster._featureGroup._layers) {\n                let layer = this.cluster._featureGroup._layers[id];\n                if(layer._icon) {\n                    jQuery(layer._icon).css({opacity: opacity});\n                }\n            }\n        }\n\n        //non-clustered features\n        if(this._layers) {\n            for(let id in this._layers) {\n                let layer = this._layers[id];\n                if(layer.setOpacity)\n                    layer.setOpacity(opacity);\n            }\n        }\n    },\n\n    setStyle: function(style) {\n        this.eachFeature(function (layer) {\n            this.setFeatureStyle(layer.feature.id, style);\n        }, this);\n    },\n\n    loadStyle: function(gpLayerId) {\n\n        if(this.options.styleLoader) {\n            this.options.styleLoader(gpLayerId)\n            .then( json => {\n\n                if(!json) return;\n\n                let style = null;\n\n                if(json && json.styles) {\n\n                    let featureFn = function(feature) {\n\n                        let property = this.property || this.field1;\n                        let v = feature[property] || (feature.properties ? feature.properties[property] : null);\n                        let style = null;\n                        if(this.styles) {\n                            let wrapper = this.styles.find( sw => sw.value === v );\n                            if(wrapper) {\n                                style = wrapper.style;\n                                style.radius = style['stroke-width'] || style.radius || 4;\n                                style.weight = style['stroke-width'] || style.weight || 2;\n                                style.color = style.stroke || style.color || '#03f';\n                                style.opacity = style['stroke-opacity'] || style.opacity || 0.9;\n                                style.fillOpacity = style['fill-opacity'] || style.opacity || 0.3;\n                                style.fillColor = style.fill || style.color || '#03f';\n                            } else {\n                                console.log(\"No matching style for \" + JSON.stringify(feature.properties));\n                            }\n                        }\n                        // console.log(\"Using style: \" + JSON.stringify(style));\n                        return style;\n                    };\n                    let styleFn = () => { return featureFn(json); };\n                    this.options.style = styleFn;\n                    setTimeout( (layer, style) => { layer.setStyle(style); }, 1000, this, styleFn);\n                    return;\n\n                } else if(json && typeof(json.push) !== 'undefined') {\n                    //multiple styles returned\n                    style = json[0];  //use first for now\n\n                } else if(json) {\n                    style = json;\n\n                } else {\n                    return; //unrecognizable style\n                }\n\n                if(style.shape) {\n                    var obj = jQuery.extend({}, style);\n                    obj.style = style;\n                    this._gpStyle = style;\n\n                    //setStyle on Cluster.FeatureLayer doesn't appear to work consistently for\n                    // non-clustered features.\n                    // this.setStyle(obj);\n                    //So instead, we manually set it on all features of the layer (that aren't clustered)\n                    for(let id in this._layers)\n                        this._layers[id].setStyle(obj);\n\n                }\n            })\n            .catch( e => {\n                console.log(\"Error fetching feature layer style\");\n                console.log(e);\n            });\n        }\n    }\n});\n\n\n\n\n/**\n * @param layer - GeoPlatform Layer object\n * @param options - optional properties\n * @return leaflet layer instance or null\n */\nfunction clusteredFeatures(layer, options) : Layer {\n\n    let service = layer.services && layer.services.length ?\n        layer.services[0] : null;\n    if(!service) {\n        let msg = `clusteredFeatures() -\n                  Cannot create leaflet layer for GP Layer:\n                  layer has no service`;\n        throw new Error(msg);\n    }\n\n    let url     = service.href,\n        format  = layer.supportedFormats ? layer.supportedFormats[0] : null;\n\n    let styleResolver = options && options.styleResolver ?\n        options.styleResolver : featureStyleResolver;\n\n    let opts = {\n        url: url + '/' + layer.layerName,\n        styleLoader: styleResolver,\n        layerId: layer.id\n    };\n\n    if(Config.leafletPane) (opts as any).pane = Config.leafletPane;\n    if(options && options.leafletPane) (opts as any).pane = options.leafletPane;\n\n    return new ClusteredFeatureLayer(opts);\n}\n\n\n\n/**\n * @param  layer - GeoPlatform Layer object\n * @param  options - optional properties\n * @return leaflet layer instance or null\n */\nfunction geoJsonFeed(layer, options) : Layer {\n\n    let service = layer.services && layer.services.length ?\n        layer.services[0] : null;\n    if(!service) {\n        let msg = `geoJsonFeed() -\n                  Cannot create leaflet layer for GP Layer:\n                  layer has no service`;\n        throw new Error(msg);\n    }\n\n    let url     = service.href,\n        format  = layer.supportedFormats ? layer.supportedFormats[0] : null;\n\n    let layerUrl = url + (url[url.length-1]==='/'?'':'/') +\n        layer.id + '/FeatureServer/' + layer.layerName;\n\n    let styleUrl = url.replace('feeds','styles') +\n        (url[url.length-1]==='/'?'':'/') + layer.id;\n\n    let styleLoaderFactory = function(url) {\n        return function (layerId) {\n            return new Promise<any>( (resolve, reject) => {\n                if(!jQuery) {\n                    reject(new Error(\"Unable to load GeoJSON feed style, jQuery is not installed\"));\n                }\n                jQuery.ajax(url, {\n                    dataType:'json',\n                    success: function(data) { resolve(data); },\n                    error: function(xhr, status, message) {\n                        let em = `geoJsonFeed() -\n                            Error loading style information for layer ${layerId} : ${message}`;\n                        reject( new Error(em) );\n                    }\n                });\n            });\n        };\n    };\n\n    let opts = {\n        url: layerUrl,\n        isModern: true,         //force to use GeoJSON\n        layerId: layer.id,    //used by style loader\n        styleLoader: styleLoaderFactory(styleUrl)\n    };\n\n    if(Config.leafletPane) (opts as any).pane = Config.leafletPane;\n    if(options && options.leafletPane) (opts as any).pane = options.leafletPane;\n\n    return new ClusteredFeatureLayer(opts);\n\n}\n\n\nexport {\n    ClusteredFeatureLayer as default,\n    ClusteredFeatureLayer,\n    clusteredFeatures,\n    geoJsonFeed\n};\n","\n/// <reference path=\"../../node_modules/@geoplatform/client/dist/shared/models.d.ts\" />\n\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport { Map, TileLayer, tileLayer, LatLng, Util, popup } from 'leaflet';\n\nimport {\n    Config, Layer as LayerModel, Service as ServiceModel\n} from '@geoplatform/client';\n\n\n\nclass WMS extends TileLayer.WMS {\n\n    private _enabled : boolean = false;\n\n    constructor(url : string, opts ?: any) {\n        super(url, opts);\n        this._enabled = false;\n    }\n\n    enableGetFeatureInfo  () {\n        this._map.on('click', this.getFeatureInfo, this);\n        this._enabled = true;\n    }\n\n    disableGetFeatureInfo () {\n        this._map.off('click', this.getFeatureInfo, this);\n        this._enabled = false;\n    }\n\n    isGetFeatureInfoEnabled () {\n        return this._enabled;\n    }\n\n    onRemove (map : Map) : this {\n\n        //if GFI is enabled, disable it before removing\n        if(this.isGetFeatureInfoEnabled())\n        this.disableGetFeatureInfo();\n\n        // Triggered when the layer is removed from a map.\n        //   Unregister a click listener, then do all the upstream WMS things\n        return super.onRemove.call(this, map);\n\n    }\n\n    getFeatureInfo  (evt) {\n        // Make an AJAX request to the server and hope for the best\n        var url = this.getFeatureInfoUrl(evt.latlng),\n        parseGetFeatureInfo = this.parseGetFeatureInfo;\n        jQuery.ajax({\n            url: url,\n            success  (data, status, xhr) {\n                // var err = typeof data === 'string' ? null : data;\n                if(typeof(data) !== 'string')\n                data = parseGetFeatureInfo(data);\n                () => {\n                    this.showGetFeatureInfo(null, evt.latlng, data);\n                }\n            },\n            error  (xhr, status, error) {\n                () => { this.showGetFeatureInfo(error); }\n            }\n        });\n    }\n\n    getFeatureInfoUrl  (latlng : LatLng) {\n        // Construct a GetFeatureInfo request URL given a point\n        var point = this._map.latLngToContainerPoint(latlng),\n        size = this._map.getSize(),\n\n        params = {\n            srs: 'EPSG:4326',\n            bbox: this._map.getBounds().toBBoxString(),\n            height: size.y,\n            width: size.x,\n            // layers: this.wmsParams.layers,\n            // query_layers: this.wmsParams.layers,\n            info_format: 'text/xml',\n            x: point.x,\n            y: point.y,\n            i: point.x, //1.3.0\n            j: point.y  //1.3.0\n        };\n\n        let wmvId = (this.wmsParams as any).wmvId;\n\n        // return this._url + Util.getParamString(params, this._url, true);\n        var url = '/api/layers/' + wmvId + '/feature';\n        return Config.ualUrl + url + Util.getParamString(params, url, true);\n    }\n\n    parseGetFeatureInfo (content) {\n        var fields = [];\n        for(var field in content) {\n            fields.push(['<div><strong>', field, ': </strong>', content[field], '</div>'].join(' '));\n        }\n        if(fields.length == 0)\n        fields.push('<em>No data available</em>');\n        return '<div>' + fields.join(' ') + '</div>';\n    }\n\n    showGetFeatureInfo  (err : Error, latlng : LatLng, content: any) {\n        if (err) { console.log(err); return; } // do nothing if there's an error\n\n        // Otherwise show the content in a popup, or something.\n        popup({ maxWidth: 800})\n        .setLatLng(latlng)\n        .setContent(content)\n        .openOn(this._map);\n    }\n\n}\n\n\nfunction determineWMSFormat( layer : LayerModel ) : string {\n    let formats : string[] = layer.formats;\n    if(formats && formats.length) {\n        //look for common formats that make sense first...\n        let idx = 0;\n        let common = [ 'image/png32', 'image/png24', 'image/png8', 'image/png', 'image/jpeg' ];\n        while( idx < common.length) {\n            if( formats.indexOf( common[idx] ) >= 0 ) return common[idx];\n            idx++;\n        }\n    }\n    console.log(\"Layer '\" + layer.label + \"' has no formats specified, \" +\n        \"assuming a default of 'image/png'\");\n    return 'image/png';\n}\n\n\n/**\n * short-form function for instantiating a WMS-based Layer's Leaflet instance\n */\nfunction wms(layer : LayerModel) : WMS {\n\n    let service : ServiceModel = layer.services && layer.services.length ?\n        layer.services[0] : null;\n    if(!service) {\n        throw new Error(\"Cannot create leaflet layer for WMS Layer '\" +\n            (layer.label || layer.id) +\n            \"' because layer has no service associated with it\");\n    }\n\n    let url : string = service.href;\n    if(!url) {\n        throw new Error(\"WMS layer's service does not defined a service url\");\n    }\n\n    //pick output format for the raster images\n    let format = determineWMSFormat(layer);\n\n    let supportedCrs = layer.crs || [];\n    if(supportedCrs && supportedCrs.length > 0 && ~supportedCrs.indexOf(\"ESPG:3857\")) {\n        console.log(\"Layer '\" + layer.label + \"' does not support \" +\n            \"EPSG:3857 Spherical Mercator projection and may not render appropriately or at all.\");\n    }\n\n    //determine proper version of the WMS spec to use\n    let version : string = '1.1.1';\n    let versions : string[] = service.serviceTypeVersions || [];\n    if(versions.length && versions.indexOf('1.1.1') < 0) {\n        version = versions[0];\n    } else {\n        console.log(\"Warning: WMS Service doesn't list supported versions, assuming 1.1.1\");\n    }\n\n    let opts : any = {\n        layers      : layer.layerName,\n        transparent : true,\n        format      : format,\n        wmvId       : layer.id,\n        version     : version\n    };\n    if(Config.leafletPane) {\n        (opts as any).pane = Config.leafletPane;\n    }\n\n    return new WMS(url, opts);\n\n}\n\nif( (window as any).L ) {\n    const L = (window as any).L;\n    L.TileLayer.WMS = WMS;\n    L.tileLayer.wms = wms;\n}\n\nexport {\n    WMS as default,\n    WMS,\n    wms\n};\n","\n\nimport * as Q from \"q\";\n\nimport * as L from 'leaflet';\nimport { TileLayer, tileLayer } from 'leaflet';\nimport 'leaflet-timedimension/dist/leaflet.timedimension.src';\n// import { TimeDimension, timeDimension } from \"../libs/L.TimeDimension\";\n\nimport {Config} from '@geoplatform/client';\n\nimport WMS from './wms';\n\n\n\nclass WMST extends (L as any).TimeDimension.Layer.WMS {\n\n    private _baseLayer : TileLayer.WMS\n\n    constructor(layer : TileLayer.WMS, opts ?: any) {\n        super(layer, opts);\n    }\n\n    //override default parser to query all Layers (whether queryable or not)\n    _parseTimeDimensionFromCapabilities (xml) {\n        var layers = xml.querySelectorAll('Layer');\n        var layerName = this._baseLayer.wmsParams.layers;\n        var layer = null;\n        var times = null;\n\n        layers.forEach(function(current) {\n            if (current.querySelector(\"Name\").innerHTML === layerName) {\n                layer = current;\n            }\n        });\n        if (layer) {\n            times = this._getTimesFromLayerCapabilities(layer);\n            if (!times) {\n                times = this._getTimesFromLayerCapabilities(layer.parentNode);\n            }\n        }\n\n        return times;\n    }\n\n    //override default parser to fall back if Dimension is provided but has no values\n    _getTimesFromLayerCapabilities (layer) {\n        var times = null;\n        var dimensions = layer.querySelectorAll(\"Dimension[name='time']\");\n        if (dimensions && dimensions.length && dimensions[0].textContent.length) {\n            times = dimensions[0].textContent.trim();\n        }\n        if(!times || !times.length) {\n            var extents = layer.querySelectorAll(\"Extent[name='time']\");\n            if (extents && extents.length && extents[0].textContent.length) {\n                times = extents[0].textContent.trim();\n            }\n        }\n        if(times && ~times.indexOf(\"current\")) {\n            times = times.replace('current', new Date().toISOString());\n        }\n        return times;\n    }\n\n}\n\n\n\n\nfunction wmst(gpLayer) {\n\n    let service = gpLayer.services[0];\n    let url = service.href;\n\n    if(!url) {\n        throw new Error(\"WMST Layer's service does not defined a service url\");\n    }\n\n    let opts = {\n        layers: gpLayer.layerName,\n        transparent: true,\n        format: \"image/png\",\n        wmvId: gpLayer.layerId\n    };\n    if(Config.leafletPane)\n        (opts as any).pane = Config.leafletPane;\n\n    let leafletLayer = new WMS( url, opts );\n\n    let proxyUrl = Config.ualUrl + '/api/services/' +\n        service.id + '/proxy/capabilities';\n\n    let tdOpts = { times : null };\n\n    if(gpLayer.temporal) {\n\n        let d1 = gpLayer.temporal.startDate ?\n            new Date(gpLayer.temporal.startDate) : new Date();\n        let d2 = gpLayer.temporal.endDate ?\n            new Date(gpLayer.temporal.endDate) : new Date();\n\n        tdOpts.times = d1.toISOString() + '/' + d2.toISOString() + '/P1D';\n    }\n\n    return new WMST(leafletLayer, {\n        timeDimension: new (L as any).TimeDimension(tdOpts),\n        proxy: proxyUrl\n    });\n}\n\nif( (window as any).L ) {\n    const L = (window as any).L;\n    L.TileLayer.WMST = WMST;\n    L.tileLayer.wmst = wmst;\n}\n\nexport {\n    WMST as default,\n    WMST,\n    wmst\n};\n","\n\nimport * as Q from \"q\";\nimport {\n    Map, TileLayer, tileLayer, Browser,\n    Point, Util, LatLng\n} from 'leaflet';\n\nimport { Config } from '@geoplatform/client';\n\n\n\n\nconst paramRe = /\\{ *([\\w_-]+) *\\}/g;\n\n// @function template(str: String, data: Object): String\n// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n// `('Hello foo, bar')`. You can also specify functions instead of strings for\n// data values  they will be evaluated passing `data` as an argument.\nfunction template(str, data) {\n\treturn str.replace(paramRe, function (str, key) {\n\t\tvar value = data[key];\n        if (value === undefined) {\n            value = data[key.toLowerCase()];\n        }\n        if (value === undefined) {\n        \tthrow new Error('No value provided for variable ' + str);\n\t\t} else if (typeof value === 'function') {\n\t\t\tvalue = value(data);\n\t\t}\n\t\treturn value;\n\t});\n}\n\n\n/*\n * inspired by and uses code from https://github.com/mylen/leaflet.TileLayer.WMTS\n */\nclass WMTS extends TileLayer {\n\n    private _url: string;\n    private _crs: any;\n    private matrixIds : any;\n    private wmtsParams : any;\n\n    private defaultWmtsParams: any;\n\n    constructor(url : string, options ?: any) {\n        super(url, options);\n    }\n\n    initialize (url, options) { // (String, Object)\n        this._url = url;\n        this.defaultWmtsParams = {\n            service: 'WMTS',\n            request: 'GetTile',\n            version: '1.0.0',\n            layers: '',\n            styles: '',\n            tileMatrixSet: '',\n            format: 'image/png'\n        };\n        var wmtsParams = Util.extend({}, this.defaultWmtsParams);\n        var tileSize = options.tileSize || this.options.tileSize;\n        if (options.detectRetina && Browser.retina) {\n            wmtsParams.width = wmtsParams.height = tileSize * 2;\n        } else {\n            wmtsParams.width = wmtsParams.height = tileSize;\n        }\n        for (var i in options) {\n            // all keys that are not TileLayer options go to WMTS params\n            if (!this.options.hasOwnProperty(i) && i!=\"matrixIds\") {\n                wmtsParams[i] = options[i];\n            }\n        }\n        this.wmtsParams = wmtsParams;\n        this.matrixIds = options.matrixIds||this.getDefaultMatrix();\n        Util.setOptions(this, options);\n    }\n\n    onAdd ( map: Map ) : this {\n        this._crs = (this.options as any).crs || (map.options as any).crs;\n        return super.onAdd(map);\n    }\n\n    getTileUrl (coords : Point) : string { // (Point, Number) -> String\n        var tileSize = this.options.tileSize as number;\n        var nwPoint = coords.multiplyBy(tileSize);\n        nwPoint.x+=1;\n        nwPoint.y-=1;\n        var sePoint = nwPoint.add( new Point(tileSize, tileSize) );\n        var zoom = this._tileZoom;\n        var nw = this._crs.project(this._map.unproject(nwPoint, zoom));\n        var se = this._crs.project(this._map.unproject(sePoint, zoom));\n        var tilewidth = se.x-nw.x;\n        //zoom = this._map.getZoom();\n        var ident = this.matrixIds[zoom].identifier;\n        var tileMatrix = this.wmtsParams.tileMatrixSet + \":\" + ident;\n        var X0 = this.matrixIds[zoom].topLeftCorner.lng;\n        var Y0 = this.matrixIds[zoom].topLeftCorner.lat;\n        var tilecol=Math.floor((nw.x-X0)/tilewidth);\n        var tilerow=-Math.floor((nw.y-Y0)/tilewidth);\n\n\n        let url = this._url;\n        let isTileMatrixTemplated = url.indexOf('{TileMatrix}');\n        let isTileRowTemplated = url.indexOf('{TileRow}');\n        let isTileColTemplated = url.indexOf('{TileCol}');\n\n        let o = Object.assign({s: this._getSubdomain(coords)}, this.wmtsParams);\n        if(isTileMatrixTemplated>0) o.TileMatrix = ident;\n        if(isTileRowTemplated>0) o.TileRow = tilerow;\n        if(isTileColTemplated>0) o.TileCol = tilecol;\n        for(let k in o) {\n            o[k.toLowerCase()] = o[k];\n        }\n        // url = Util.template(url.toLowerCase(), o);\n        url = template(url, o);\n\n        let qsi = url.indexOf(\"?\");\n        if(qsi<0 || (isTileMatrixTemplated<qsi && isTileRowTemplated<qsi || isTileColTemplated<qsi)) {\n            //if the TM,TR,TC variables are templated but not as querystring parameters\n            // (ie, no '?' present or those params are before the '?'),\n            // then the URL must not be OGC WMTS, so no need for WMTS parameters\n\n        } else {\n            url = url + Util.getParamString(this.wmtsParams, url);\n            if(isTileMatrixTemplated<0)\n                url += \"&TileMatrix=\" + ident; //tileMatrixSet\n            if(isTileRowTemplated<0)\n                url += \"&TileRow=\" + tilerow;\n            if(isTileColTemplated<0)\n                url += \"&TileCol=\" + tilecol;\n        }\n\n        return url;\n    }\n\n    setParams (params, noRedraw) {\n        Util.extend(this.wmtsParams, params);\n        if (!noRedraw) {\n            this.redraw();\n        }\n        return this;\n    }\n\n    getDefaultMatrix  () {\n        /**\n         * the matrix3857 represents the projection\n         * for in the IGN WMTS for the google coordinates.\n         */\n        var matrixIds3857 = new Array(22);\n        for (var i= 0; i<22; i++) {\n            matrixIds3857[i]= {\n                identifier    : \"\" + i,\n                topLeftCorner : new LatLng(20037508.3428,-20037508.3428)\n            };\n        }\n        return matrixIds3857;\n    }\n\n    _getSubdomain (tilePoint : Point) : string {\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n\t\treturn this.options.subdomains[index];\n\t}\n\n}\n\n\n\n\nfunction wmts(layer) {\n\n    let url = layer.services && layer.services.length ? layer.services[0].href : null;\n\n    let supportedCrs = layer.crs || [];\n    if(supportedCrs && supportedCrs.length > 0 && ~supportedCrs.indexOf(\"ESPG:3857\")) {\n        console.log(\"Layer '\" + layer.label + \"' does not support \" +\n            \"EPSG:3857 Spherical Mercator projection and may not render appropriately or at all.\");\n    }\n\n    let options = {\n        layer: layer.layerName,\n        style: 'default',\n        tileMatrixSet: \"default\",\n        format: \"image/png\"\n    };\n    if(Config.leafletPane)\n        (options as any).pane = Config.leafletPane;\n\n    let distro = (layer.distributions || []).find( dist => {\n        //ensure dist isn't 'null'\n        return dist && dist.href && ( dist.mediaType==='image/png' || dist.mediaType==='image/jpeg' );\n    });\n    if(distro) {\n        url = distro.href;\n        options.format = distro.mediaType;\n\n        let params = distro.parameters || [];\n        params.forEach( param => {\n\n            //ignore wmts specific parameters, WMTS layer will populate those values\n            // based upon map state.\n            let plc = param.name.toLowerCase();\n            if(\"tilematrix\" === plc || \"tilerow\" === plc || \"tilecol\" === plc)\n                return;\n\n            //for all other parameters, try to fill in default or initial values\n            let value = param.defaultValue || param.values && param.values.length && param.values[0];\n            if(value !== null && value !== undefined) {\n                url = url.replace('{' + param.name + '}', value);\n            }\n        });\n    } else {\n        throw new Error(\"WTMS Layer - layer \" + layer.id +\n            \" has no distribution(s) usable to make WMTS requests\");\n    }\n\n    if(!url) throw new Error(\"Unable to determine WMTS URL for layer \" + layer.id +\n        \". Please make sure it is defined by either the service or a distribution on the layer itself.\");\n\n    return new WMTS( url, options );\n\n}\n\n\nif((window as any).L) {\n    const L = (window as any).L;\n    L.TileLayer.WMTS = WMTS;\n    L.tileLayer.wmts = wmts;\n}\n\nexport {\n    WMTS as default,\n    WMTS,\n    wmts\n};\n","\nimport * as Q from \"q\";\nimport { Map, TileLayer, tileLayer, Point, Coords, Browser, Util } from 'leaflet';\n\nimport {Config} from '@geoplatform/client';\n\n\nclass EsriTileLayer extends TileLayer {\n\n    private _url : string;\n    private _crs : any;\n    private esriParams : any;\n    private defaultESRIParams : any;\n\n    constructor(url, options) {\n        super(url, options);\n    }\n\n    initialize (url, options) { // (String, Object)\n\n        if(!url) throw new Error(\"Layer was not configured with a URL\");\n\n        this.defaultESRIParams = {\n            layers:       '', //=show:0,1,2\n            transparent:  true,\n            format:       'png32',\n            f:            'image'\n            // srs:          '4326',\n            // bboxsr:       '4326',\n            // bbox:         null,\n            // size:         '256,256',\n            // imagesr:      '4326'\n        };\n\n        if(url.indexOf(\"/export\") < 0) {\n            let qidx = url.indexOf(\"?\");\n            if(qidx > 0) {\n                url = url.substring(0, qidx) + '/export' + url.substring(qidx);\n            } else {\n                url += '/export';\n            }\n        }\n        this._url = url;\n\n        let esriParams : any = Util.extend({}, this.defaultESRIParams),\n            tileSize = options.tileSize || this.options.tileSize;\n\n        let dim;\n        if (options.detectRetina && Browser.retina) {\n            dim = esriParams.height = tileSize * 2;\n        } else {\n            dim = esriParams.height = tileSize;\n        }\n        esriParams.size = dim + ',' + dim;\n\n        for (var i in options) {\n            // all keys that are not TileLayer options go to WMS params\n            if (!this.options.hasOwnProperty(i) && i !== 'crs') {\n                esriParams[i] = options[i];\n            }\n        }\n\n        //layer ids\n        // esriParams.layers = \"show:\" + esriParams.layers;\n\n        this.esriParams = esriParams;\n\n        Util.setOptions(this, options);\n\n    }\n\n    onAdd (map : Map) : this {\n        this._crs = (this.options as any).crs || (map.options as any).crs;\n        this.esriParams.srs = this.esriParams.imagesr = this.esriParams.bboxsr = this._crs.code;\n        return super.onAdd(map);\n    }\n\n    getTileUrl (tilePoint : Coords ) : string { // (Point, Number) -> String\n\n        let map = this._map,\n            tileSize = this.options.tileSize as number,\n\n        nwPoint = tilePoint.multiplyBy(tileSize),\n        sePoint = nwPoint.add([tileSize, tileSize]),\n\n        nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\n        se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\n        bbox = [nw.x, se.y, se.x, nw.y].join(','),\n\n        url = Util.template(this._url, {s: this._getSubdomain(tilePoint)});\n\n        let params = Util.extend({}, this.esriParams);\n        params.layers = \"show:\" + params.layers;\n\n        //convert to esri-special SR for spherical mercator\n        if(params.bboxsr === 'EPSG:3857')\n            params.bboxsr = '102100';\n        if(params.imagesr === 'EPSG:3857')\n            params.imagesr = '102100';\n\n        return url + Util.getParamString(params, url, true) + '&BBOX=' + bbox;\n    }\n\n    setParams (params, noRedraw) {\n        Util.extend(this.esriParams, params);\n        if (!noRedraw) {\n            this.redraw();\n        }\n        return this;\n    }\n\n    _getSubdomain (tilePoint : Point) : string {\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n\t\treturn this.options.subdomains[index];\n\t}\n}\n\nif((window as any).L) {\n    const L = (window as any).L;\n    L.TileLayer.ESRI = EsriTileLayer;\n    L.tileLayer.esri = function (url, options) {\n        return new L.TileLayer.ESRI(url, options);\n    };\n}\n\nexport default EsriTileLayer;\n","\nimport { TileLayer } from 'leaflet';\nimport { Config } from '@geoplatform/client';\n\n\n/**\n * @param layer - GeoPlatform Layer\n * @return\n */\nfunction OSMLayerFactory() : TileLayer {\n\n    let opts : any = {\n        minZoom: 1, maxZoom: 19,\n        attribution: 'Map data (c) <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors'\n    };\n    if(Config.leafletPane) opts.pane = Config.leafletPane;\n    return new TileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', opts);\n}\n\nexport default OSMLayerFactory;\n","\ninterface LeafletStyle {\n    weight      ?: number;\n    opacity     ?: number;\n    color       ?: string;\n    dashArray   ?: number[];\n    fillOpacity ?: number;\n    fillColor   ?: string;\n}\n\ninterface LeafletStyleMap {\n    [key:string]: Function | LeafletStyle\n}\n\ninterface MapBoxStyle {\n    version      : number;  //Style specification version number. Must be 8.\n    name        ?: string;  //A human-readable name for the style.\n    metadata    ?: any;     //Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'.\n    center      ?: number[]; //Default map center in longitude and latitude. The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).\n    zoom        ?: number;  //Default zoom level. The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).\n    bearing     ?: number;  //Default bearing, in degrees. The bearing is the compass direction that is \"up\"; for example, a bearing of 90 orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).\n    pitch       ?: number;  //Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).\n    light       ?: any;     //The global light source.\n    sources     ?: any[];   //Data source specifications.\n    sprite      ?: string;  //A base URL for retrieving the sprite image and metadata. The extensions .png, .json and scale factor @2x.png will be automatically appended. This property is required if any layer uses the background-pattern, fill-pattern, line-pattern, fill-extrusion-pattern, or icon-image properties. The URL must be absolute, containing the scheme, authority and path components.\n    glyphs      ?: string;  //A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include {fontstack} and {range} tokens. This property is required if any layer uses the text-field layout property. The URL must be absolute, containing the scheme, authority and path components.\n    transition  ?: any;     //A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style's transition property.\n    layers      ?: MapBoxStyleLayer[];   //Layers will be drawn in the order of this array.\n}\n\ninterface MapBoxStyleLayer {\n    id              : string;      //Unique layer name.\n    type            : \"fill\" | \"line\" | \"symbol\" | \"circle\" | \"heatmap\" | \"fill-extrusion\" | \"raster\" | \"hillshade\" | \"background\"; //Rendering type of this layer.\n    metadata       ?: any;         //Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'.\n    source         ?: string;      //Name of a source description to be used for this layer. Required for all layer types except background.\n    'source-layer' ?: string; //Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources.\n    minzoom        ?: number;      //The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden.\n    maxzoom        ?: number;      //The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden.\n    filter         ?: any;         //A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The feature-state expression is not supported in filter expressions.\n    layout         ?: any;         //Layout properties for the layer.\n    paint          ?: MapBoxPaint; //Default paint properties for this layer.\n}\n\ninterface MapBoxPaint {\n    visibility           ?: \"visible\" | \"none\";   //Whether this layer is displayed.\n    'background-color'   ?: string;     //The color with which the background will be drawn.\n    'background-pattern' ?: string;     //Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.\n    'background-opacity' ?: number;     //The opacity at which the background will be drawn.\n    'fill-antialias'     ?: boolean;    //Whether or not the fill should be antialiased.\n    'fill-opacity'       ?: number|any[];     //The opacity of the entire fill layer. In contrast to the fill-color, this value will also affect the 1px stroke around the fill, if the stroke is used.\n    'fill-color'         ?: string|any[];  //The color of the filled part of this layer. This color can be specified as rgba with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.\n    'fill-outline-color' ?: string|any[];     //The outline color of the fill. Matches the value of fill-color if unspecified.\n    'fill-translate'     ?: number[];   //The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.\n    'fill-translate-anchor' : \"map\" | \"viewport\"; //Controls the frame of reference for fill-translate.\n    'fill-pattern'       ?: string;     //Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.\n    'line-cap'           ?: \"butt\" | \"round\" | \"square\"; //The display of line endings.\n    'line-join'          ?:  \"bevel\" | \"round\" | \"miter\" //The display of lines when joining.\n    'line-miter-limit'   ?: number;     //Used to automatically convert miter joins to bevel joins for sharp angles.\n    'line-round-limit'   ?: number;     //Used to automatically convert round joins to miter joins for shallow angles.\n    'line-opacity'       ?: number|any[];     //The opacity at which the line will be drawn.\n    'line-color'         ?: string|any[];     //The color with which the line will be drawn.\n    'line-translate'     ?: number[];   //The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.\n    'line-translate-anchor' ?: \"map\" | \"viewport\";  //Controls the frame of reference for line-translate.\n    'line-width'         ?: number|any[];     //Stroke thickness.\n    'line-gap-width'     ?: number;     //Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.\n    'line-offset'        ?: number;     //The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.\n    'line-blur'          ?: number;     //Blur applied to the line, in pixels.\n    'line-dasharray'     ?: number[];   //Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with lineMetrics: true specified won't render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.\n    'line-pattern'       ?: string;     //Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.\n    'line-gradient'      ?: string;     //Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify \"lineMetrics\": true.\n    //TODO symbols\n}\n\n\n\n\n\n\n\n/**\n * Class representing an evaluatable expression associated with a layer style,\n * following MapBox Style Spec format.\n * Expressions are arrays of:\n *   - operator key ('get', '==', 'has', etc)\n *   - any number of parameters including nested expressions\n *\n *  Examples:\n *\n *  [ 'has', 'propertyName' ]   // simple expression checking for existance of a specific feature property\n *\n *  [\n *    '=='                      // type of expression (equality comparison)\n *    [ 'get', 'propertyA' ],   // nested expression to extract feature's property value\n *    'expectedValue'           // value to compare against\n *  ]\n *\n *  [\n *    'match',                   // type of expression ('switch' statement)\n *    [ 'get', 'propertyName' ], // first param is another expression to extract a feature's property value\n *    'A', 'valueForA',          // next two params are first 'case' of \"switch\"\n *    'B', 'valueForB',          // second 'case' for 'switch'\n *    'fallbackValue'            // default 'case' for 'switch'\n *  ]\n *\n */\nclass Expression {\n\n    private operator: string;\n    private args ?: any[];\n\n    constructor( filter : any[] ) {\n        let arr = filter.slice(0);\n        this.operator = arr[0];\n        this.args = arr.splice(1).map( arg => {\n            return Array.isArray( arg ) ? new Expression( arg ) : arg;\n        });\n    }\n\n    /**\n     * @param properties - map of feature properties to use in evaluating the expression for a specific feature instance\n     * @param zoom - zoom level of the map\n     * @param geometryType - type of geometry for the specific feature instance being evaluated\n     * @return value result of the expression\n     */\n    evaluate( properties : any, zoom : number, geometryType : string ) : any {\n        let p1, p2;\n        switch(this.operator) {\n            case 'get':\n                return this.getArg(0, properties, zoom, geometryType);\n            case 'has':\n                return this.getArg(0, properties, zoom, geometryType);\n            case '!has':\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                return !( typeof(p1) !== 'undefined' && p1 in properties);\n            case '==':\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                p2 = this.getArg(1, properties, zoom, geometryType);\n                // console.log(`Comparing ${p1} == ${p2}`);\n                return p1 == p2;\n            case '!=':\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                p2 = this.getArg(1, properties, zoom, geometryType);\n                // console.log(`Comparing ${p1} != ${p2}`);\n                return p1 != p2;\n            case '>':\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                p2 = this.getArg(1, properties, zoom, geometryType);\n                return p1 > p2;\n            case '<':\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                p2 = this.getArg(1, properties, zoom, geometryType);\n                return p1 < p2;\n            case '>=':\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                p2 = this.getArg(1, properties, zoom, geometryType);\n                return p1 >= p2;\n            case '<=':\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                p2 = this.getArg(1, properties, zoom, geometryType);\n                return p1 <= p2;\n            case 'array':\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                return Array.isArray(p1);\n            case 'at' :\n                p1 = this.getArg(0, properties, zoom, geometryType);\n                p2 = this.getArg(1, properties, zoom, geometryType);\n                return typeof(p1) === 'number' && Array.isArray(p2) &&\n                    p2.length >= p1 ? p2[p1] : null;\n\n            case 'zoom': return zoom;\n            case 'id': return properties.id;\n            case 'geometry-type': return geometryType;\n            case 'match' :  //works like a switch statement\n                return this.findMatch(properties, zoom, geometryType);\n        }\n        return null;\n    }\n\n    /**\n     * @param properties - map of feature properties to use in evaluating the expression for a specific feature instance\n     * @param zoom - zoom level of the map\n     * @param geometryType - type of geometry for the specific feature instance being evaluated\n     * @return value of the argument (which may be result of an expression)\n     */\n    getArg(index : number, properties : any, zoom : number, geometryType : string) : any {\n        let value = this.args[index];\n        if(value && typeof(value.evaluate) !== 'undefined') {\n            //arg is a nested expression...\n            return value.evaluate(properties, zoom, geometryType);\n\n        } else if(value && typeof(value) === 'string' && properties.hasOwnProperty(value)) {\n            //arg is a property name instead of a nested expression...\n            return properties[value];\n        }\n        return value;\n    }\n\n    /**\n     * @param properties - map of feature properties to use in evaluating the expression for a specific feature instance\n     * @param zoom - zoom level of the map\n     * @param geometryType - type of geometry for the specific feature instance being evaluated\n     * @return value associated with matching condition of expression, or fallback value\n     */\n    findMatch( properties : any, zoom : number, geometryType : string ) : any {\n        let result = null, end = this.args.length-1;\n\n        //the input value to test against\n        //  ... should be value of Input portion (ie, \"Lake\" for wetlands)\n        let value = this.getArg(0, properties, zoom, geometryType);\n        // console.log(\"Expression.match - \" + JSON.stringify(value) );\n\n        //find value inside remaining args to assign style associated with that value\n        this.args.forEach( (arg,i) => {\n            // ignore first arg (see above) and last arg (it's the fallback value)\n            // also skip if we've already found a match\n            if( result !== null || i === 0 || i === end) return;\n            if( Array.isArray(arg) ) {          //array of literal values\n                if(~arg.indexOf( value )) {\n                    result = this.args[i+1];    //match, return next value in array\n                }\n            } else if( arg == value ){      //literal value\n                result = this.args[i+1];    //match, return next value in array\n            }\n        });\n        if(!result) result = this.args[end]; //last arg is always fallback value\n        // console.log(\"Match returned: \" + result);\n        return result;\n    }\n\n    toString() {\n        return [this.operator].concat(\n            this.args.map( arg => {\n                return (typeof(arg.evaluate) !== 'undefined') ? arg.toString() : arg;\n            })\n        ).join(',');\n    }\n}\n\n\n\n\n\n/**\n * @param style MapBox Style definition\n * @return object associating Leaflet styles with layer ids\n */\nexport default function parseMapBoxStyle( style : MapBoxStyle ) : { [key:string]:LeafletStyleMap } {\n\n    //TODO validate style.version to make sure we are parsing something we understand\n\n    // console.log(\"Parsing MapBox Style\");\n    // console.log(JSON.stringify(style, null, ' '));\n    // console.log(\"--------------------\");\n\n    if( !style.layers || !Array.isArray(style.layers) || !style.layers.length) {\n        console.log(\"Style has no layer definitions\");\n        return {};   //empty styles\n    }\n\n    //have to group layers with same id but with different filters under the same style function\n    let layers = {};\n    style.layers.forEach( layer => {\n        //use source-layer key first, fallback to layer id\n        let id = (layer['source-layer'] || layer.id).trim();\n        if(layers[id]) layers[id].push(layer);  //layer already exists\n        else layers[id] = [layer];              //new layer's style\n    });\n    // console.log(JSON.stringify(layers, null, ' '));\n\n    let result = {};\n    Object.keys(layers).forEach( id => {\n        let styles = layers[id];    //array of 1 or more for given id (differentiated by filters)\n        result[id] = doThis(styles);\n    })\n    // style.layers.forEach( layer => {\n    //     result[ layer.id ] = styleFunctionFactory(layer); //new LayerStyle( layer ).getStyleFunction()\n    // });\n    return result;\n}\n\n\n\nfunction doThis( layerStyles : MapBoxStyleLayer[] ) : Function {\n\n    let styles = layerStyles.map( layerStyle => styleFunctionFactory(layerStyle) );\n\n    return function( properties : any, zoom: number, geomType : string ) {\n\n        let match : any = styles.find( style => {\n            if(style.filter && typeof(style.filter.evaluate) !== 'undefined') {\n                // console.log(\"Style has a filter... \" + style.filter.toString());\n                let found = style.filter.evaluate(properties, zoom, geomType);\n                // if(!found) console.log(\"Filter does not match\");\n                // else console.log(\"Filter matches\");\n                return found;\n            }\n            return true;\n        });\n\n        let result = {};\n        if(match) {\n            Object.keys(match.style).forEach( key => {\n                let styleVal = match.style[key];\n                if( styleVal && typeof(styleVal.evaluate) !== 'undefined')\n                    result[key] = styleVal.evaluate(properties, zoom, geomType);\n                else result[key] = styleVal;\n            });\n        } else {\n            console.log(\"Warning, no style found\");\n        }\n        return result;\n    };\n\n}\n\n\n\n/**\n * @param layer MapBox Style Spec Layer definition\n * @return Function accepting feature properties, zoom level, and geometry type and returning a Leaflet style object\n */\nvar styleFunctionFactory = ( function( layerStyle : MapBoxStyleLayer ) {\n\n    /**\n     *\n     */\n    let parseValue = function ( value : any, fallback ?: any ) {\n        if( value && Array.isArray(value) && value.length ) {\n            return new Expression(value);\n        }\n        else if( value !== null && typeof(value) !== 'undefined' ) return value;\n        else return fallback || null;\n    }\n\n    let filter : any = parseValue(layerStyle.filter);\n\n    let layerPaint : MapBoxPaint  = layerStyle.paint;\n\n    let lineWidth   = parseValue( layerPaint['line-width'], 1);\n    let opacity     = parseValue( layerPaint['line-opacity'], 1.0);\n    let color       = parseValue( layerPaint['line-color']   || layerPaint['fill-outline-color'] || layerPaint['fill-color'], '#000');\n    let fillOpacity = parseValue( layerPaint['fill-opacity'] || layerPaint['background-opacity'], 1.0);\n    let fillColor   = parseValue( layerPaint['fill-color']   || layerPaint['background-color'], '#000');\n\n    let style : LeafletStyle = {\n        color      : color,         //stroke color\n        opacity    : opacity,       //stroke opacity\n        weight     : lineWidth,     //stroke size\n        fillOpacity: fillOpacity,   //fill opacity\n        fillColor  : fillColor      //fill color\n    };\n\n    return {\n        filter: filter,\n        style: style\n    };\n\n    // return function( properties : any, zoom: number, geomType : string ) {\n    //     let result = {};\n    //\n    //     if(filter && typeof(filter.evaluate)) {\n    //         console.log(\"Style has a filter... \" + filter.toString());\n    //         if(!filter.evaluate(properties, zoom, geomType)) {\n    //             console.log(\"Filter does not match\");\n    //             return false;\n    //         }\n    //         console.log(\"Filter matches\");\n    //     }\n    //\n    //     Object.keys(style).forEach( key => {\n    //         let styleVal = style[key];\n    //         if( styleVal && typeof(styleVal.evaluate) !== 'undefined')\n    //             result[key] = styleVal.evaluate(properties, zoom, geomType);\n    //         else result[key] = styleVal;\n    //     });\n    //     return result;\n    // };\n});\n","\nimport * as L                        from 'leaflet';\nimport { Layer as LeafletLayer }     from \"leaflet\";\nimport {\n    Layer as GeoPlatformLayer, Config, XHRHttpClient\n} from '@geoplatform/client';\nimport parseMapBoxStyle from \"../shared/mapbox-style\";\n\n\nconst STYLE_CONCEPT = {\n    \"id\": \"78ad3ecc883de444c8a0684087a61753\",\n    \"uri\": \"http://www.geoplatform.gov/def/OnlineFunction/styling\",\n    \"type\": \"skos:Concept\",\n    \"label\": \"styling\"\n};\n\nconst DEFAULT_STYLE_CONCEPT = {\n    \"id\": \"53983c42978cd510a5f844ec0a0c6c2b\",\n    \"uri\": \"http://www.geoplatform.gov/def/OnlineFunction/default_styling\",\n    \"type\": \"skos:Concept\",\n    \"label\": \"default styling\"\n};\n\n\n\nfunction mapBoxVectorTileLayer( layer : GeoPlatformLayer ) : LeafletLayer {\n\n    let href = layer.href;\n    if(!href || href.indexOf(\".pbf\") < 0) {\n        console.log(\"LayerFactory - Layer does not define an Access URL\");\n        return null;  //missing URL\n    }\n\n    const Leaflet = L as any;\n\n    //if Leaflet vector grid plugin is not installed, can't render VT Layers\n    if( typeof(Leaflet.vectorGrid) === 'undefined' &&\n        typeof(Leaflet.vectorGrid.protobuf) === 'undefined') {\n        console.log(\"LayerFactory - Leaflet Vector Tiles plugin not found\");\n        return null;\n    }\n\n    let opts : any = {\n        rendererFactory: ( L.canvas as any ).tile\n        // ,\n        // getFeatureId: function( feature : any ) { return feature.properties.id; }\n    };\n    if(Config.leafletPane) opts.pane = Config.leafletPane;\n\n    let result = Leaflet.vectorGrid.protobuf(href, opts);\n\n    //If the layer object defines styles to use, resolve them and apply the style(s)\n    let style = null;\n    let styles = (layer.related || []).filter( rel => {\n        if(!rel.role) return false;\n        if(rel.role.uri === DEFAULT_STYLE_CONCEPT.uri) {\n            style = rel;\n            return false;\n        }\n        return rel.role.uri === STYLE_CONCEPT.uri;\n    });\n    style = style || (styles.length ? styles[0] : null);\n    if( style ) {\n        applyVectorTileStyle( layer, result, style );\n    }\n    return result;\n}\n\n\n\n/**\n * @param layer GeoPlatform Layer object\n * @param leafletLayer GridLayer instance representing the GP Layer object specified\n * @param styleResource GP Auxillary Resource object\n */\nfunction applyVectorTileStyle(\n    layer : GeoPlatformLayer,\n    leafletLayer : LeafletLayer,\n    styleResource : any\n) {\n\n    if(!leafletLayer.hasOwnProperty('options')) {\n        console.log(\"Warn: Could not apply style to layer; layer is not a VectorGrid instance\");\n        return;\n    }\n\n    //fetch clob definition of style to use...\n    fetchStyleDefinition( layer.id, styleResource )\n    .then( (styleDef : any) => {\n        let layerInst = (leafletLayer as any);\n        let style = parseMapBoxStyle( styleDef );\n        if(style && typeof(style) !== 'undefined') {\n            layerInst.options.vectorTileLayerStyles = style;\n            layerInst.redraw();\n        } else {\n            console.log(\"[WARN] Unable to parse MapBox-style Style definitions from: \");\n            console.log(JSON.stringify(styleResource, null, ' '));\n        }\n    })\n    .catch( e => {\n        console.log(\"An error occurred fetching the style definition for layer '\" +\n            layer.label + \"'. \" + e.message + \". Using default Leaflet style.\");\n    });\n}\n\n\n\n/**\n * @param layerId string identifier of GeoPlatform Layer object\n * @param resource - auxillary resource referencing style definition to fetch\n * @return Promise resolving style definition\n */\nfunction fetchStyleDefinition( layerId : string, resource : any ) : Promise<any> {\n    if(!layerId || !resource) {\n        let err = new Error(\"Unable to fetch style definition, one or more parameters were invalid\");\n        return Promise.reject(err);\n    }\n\n    if(!resource.contentId && !resource.href) {\n        let err = new Error(\"Unable to fetch style definition, missing id or url to style\");\n        return Promise.reject(err);\n    }\n\n    let url = null;\n    if(resource.contentId) {\n        url = Config.ualUrl + '/api/layers/' + layerId + '/styles/' + resource.contentId;\n    } else if(resource.href) {\n        url = resource.href;\n    }\n\n    let client = new XHRHttpClient();\n    let request = client.createRequestOpts({\n        method : \"GET\",\n        url    : url,\n        timeout: 5000,\n        json   : true\n    });\n    return client.execute(request);\n}\n\n\n\nexport {\n    mapBoxVectorTileLayer as default,\n    mapBoxVectorTileLayer,\n    applyVectorTileStyle\n};\n","\nimport * as L from 'leaflet';\nimport { Layer } from \"leaflet\";\nimport * as esri from \"esri-leaflet\";\nimport ServiceTypes from \"../service/types\";\nimport OSM from \"./osm\";\nimport FeatureLayer from './feature';\nimport {\n    ClusteredFeatureLayer,\n    clusteredFeatures,\n    geoJsonFeed\n} from './cluster-feature';\n\nimport {WMS, wms} from './wms';\nimport {WMST, wmst} from './wmst';\nimport {WMTS, wmts} from './wmts';\nimport ESRITileLayer from './esri-tile-layer';\nimport OSMLayerFactory from './osm-factory';\nimport {LayerResourceTypes} from '../shared/resource-types';\nimport { mapBoxVectorTileLayer } from './mbvt';\nimport {\n    Config, ItemTypes, LayerService, XHRHttpClient,\n    Layer as LayerModel, Service as ServiceModel,\n    ServiceTypeStandard\n} from '@geoplatform/client';\n\ninterface LayerOptions {\n    layers ?: string|string[],\n    transparent ?: boolean,\n    format ?: string,\n    pane ?: string,\n    srs ?: string,\n    url ?: string,\n    useCors ?: boolean\n};\n\n\n\n\n/*\n * Extend base Leaflet layer class to ensure there's always a function\n * available for modifying zindex and opacity, even if nothing actually\n * happens inside.\n */\nLayer.include({\n\n    // Redefining a method\n    setZIndex: function(value : number) {\n        //do nothing in this abstract class, let impls do the work\n    },\n\n    setOpacity: function(value : number) {\n        //do nothing in this abstract class, let impls do the work\n    }\n\n});\n\n\n\n\n/**\n * Fetches style information from GeoPlatform UAL\n * @param id - identifier of layer to resolve style for\n */\nfunction styleResolverFactory(service ?: LayerService) : any {\n\n    if(!service || typeof(service.style) !== 'function') {\n        throw new Error(\"Must provide a LayerService instance\");\n    }\n\n    return function featureStyleResolver(id) {\n        return new Promise<any>( (resolve, reject) => {\n            service.style(id)\n            .then( result => resolve(result) )\n            .catch(e => {\n                let msg = `Error loading style information for layer ${id} : ${e.message}`;\n                reject( new Error(msg) );\n            });\n        });\n    };\n}\n\n\n\n\n\n\n\n\n/**\n * Layer Factory\n *\n * Used to instantiate GeoPlatform Layer objects as Leaflet layer instances\n * capable of being rendered on Leaflet maps.\n *\n * Usage:\n *      let leafletLayer = LayerFactory.create(gpLayerObj);\n *\n *\n * Basic layer support is built in, but additional layer types can be supported\n * by registering new factory methods.\n *\n * Example:\n *      LayerFactory.register( (gpLayerObj) => {\n *          let isSupported = false;\n *          //implement test to verify supported layer type\n *          // ...\n *          if(isSupported) {\n *              return new MyCustomLayerClass(gpLayerObj);\n *          }\n *          return null;\n *      });\n *\n */\nclass LayerFactory {\n\n    private factories : Function[];\n    private service : LayerService;\n\n    constructor() {\n        this.factories = [];    // A list of configured factory functors to instantiate layers\n        this.init();\n    }\n\n    register(fn : Function) {\n        if(typeof(fn) === 'function') {\n            this.factories.push(fn);\n        }\n    }\n\n    setLayerService(service : LayerService) {\n        this.service = service;\n    }\n\n    /**\n     */\n    getStyleResolver() : Function {\n        if(!this.service || typeof(this.service.style) === 'undefined') {\n            this.service = new LayerService(Config.ualUrl, new XHRHttpClient());\n        }\n        return styleResolverFactory(this.service);\n    }\n\n    /**\n     * @param layer - GP Layer object\n     * @return leaflet layer instance or null\n     */\n    create( layer : LayerModel ) : Layer {\n        if(!layer) {\n            throw new Error(\"LayerFactory expects a layer object\");\n        }\n        for(let i=0; i<this.factories.length; ++i) {\n            let fn = this.factories[i];\n            let result = fn && typeof(fn)==='function' && fn(layer);\n            if(result) return result;\n        }\n        return null;\n    }\n\n\n    init () {\n\n        //OSM factory\n        this.register( ( layer : LayerModel )=> {\n            if(layer && layer.resourceTypes &&\n                layer.resourceTypes.length &&\n                ~layer.resourceTypes.indexOf(LayerResourceTypes.OSM)) {\n                return OSMLayerFactory();\n            }\n        });\n\n        // ESRI factory\n        this.register( (layer : LayerModel) => {\n            if(!layer || !layer.services || !layer.services.length) return null;\n            let service : ServiceModel = layer.services[0];\n            let url     = service.href,\n                svcType : ServiceTypeStandard = service.serviceType,\n                typeUri = svcType ? svcType.uri : null,\n                // srs     = layer.supportedCRS ? layer.supportedCRS[0] : null,\n                format  = layer.supportedFormats ? layer.supportedFormats[0] : null,\n                opts : LayerOptions;\n\n            function checkUrl(url) {\n                if(!url) throw new Error(\"Layer's service does not define a service url\");\n            }\n\n            if(ServiceTypes.ESRI_MAP_SERVER &&\n                ServiceTypes.ESRI_MAP_SERVER.uri === typeUri) {\n                checkUrl(url);\n                opts = {\n                    layers: layer.layerName,\n                    transparent: true,\n                    format: format || \"png32\"\n                } as LayerOptions;\n\n                // if(srs) opts.srs = srs;\n                let supportedCrs = layer.crs || [];\n                if(supportedCrs && supportedCrs.length > 0 && ~supportedCrs.indexOf(\"ESPG:3857\")) {\n                    console.log(\"Layer '\" + layer.label + \"' does not support \" +\n                        \"EPSG:3857 Spherical Mercator projection and may not render appropriately or at all.\");\n                }\n\n                if(Config.leafletPane)\n                    opts.pane = Config.leafletPane;\n                return new ESRITileLayer(url, opts);\n\n            } else if(ServiceTypes.ESRI_FEATURE_SERVER &&\n                ServiceTypes.ESRI_FEATURE_SERVER.uri === typeUri) {\n                checkUrl(url);\n                return clusteredFeatures(layer, {\n                    styleResolver: this.getStyleResolver()\n                });\n\n            } else if(ServiceTypes.ESRI_TILE_SERVER &&\n                ServiceTypes.ESRI_TILE_SERVER.uri === typeUri) {\n                checkUrl(url);\n                opts = { url: url, useCors: true };\n                if(Config.leafletPane)\n                    opts.pane = Config.leafletPane;\n                return esri.tiledMapLayer(opts);\n\n            } else if(ServiceTypes.ESRI_IMAGE_SERVER &&\n                ServiceTypes.ESRI_IMAGE_SERVER.uri === typeUri) {\n                opts = { url: url, useCors: true };\n                if(Config.leafletPane)\n                    opts.pane = Config.leafletPane;\n                return esri.imageMapLayer(opts);\n\n            }\n            return null;\n        });\n\n        // OGC factory\n        this.register( (layer : LayerModel) => {\n            if(!layer || !layer.services || !layer.services.length) return null;\n            let service : ServiceModel = layer.services[0];\n            let svcType : ServiceTypeStandard = service.serviceType;\n            let typeUri : string = svcType ? svcType.uri : null;\n\n            if(ServiceTypes.WMS && ServiceTypes.WMS.uri === typeUri) {\n                return wms(layer);\n            } else if(ServiceTypes.WMST && ServiceTypes.WMST.uri === typeUri) {\n                return wmst(layer);\n            } else if(ServiceTypes.WMTS && ServiceTypes.WMTS.uri === typeUri) {\n                return wmts(layer);\n            }\n            return null;\n        });\n\n\n        this.register( (layer : LayerModel) => {\n            if(!layer || !layer.services || !layer.services.length) return null;\n            let service : ServiceModel = layer.services[0];\n            let svcType : ServiceTypeStandard = service.serviceType;\n            let typeUri : string = svcType ? svcType.uri : null;\n            if(ServiceTypes.FEED && ServiceTypes.FEED.uri === typeUri) {\n                return geoJsonFeed(layer, {\n                    styleResolver: this.getStyleResolver()\n                });\n            }\n            return null;\n        });\n\n\n\n\n        this.register( (layer : LayerModel) => {\n            if(!layer) return null;\n            let resourceTypes = layer.resourceTypes || [];\n            if(resourceTypes.indexOf(LayerResourceTypes.MapBoxVectorTile) < 0) { //not tagged as VT layer\n                return null;\n            }\n            return mapBoxVectorTileLayer(layer);\n\n\n\n\n            // let href = layer.href;\n            // if(!href || href.indexOf(\".pbf\") < 0) {\n            //     console.log(\"LayerFactory - Layer does not define an Access URL\");\n            //     return null;  //missing URL\n            // }\n            //\n            // const Leaflet = L as any;\n            //\n            // //if Leaflet vector grid plugin is not installed, can't render VT Layers\n            // if( typeof(Leaflet.vectorGrid) === 'undefined' &&\n            //     typeof(Leaflet.vectorGrid.protobuf) === 'undefined') {\n            //     console.log(\"LayerFactory - Leaflet Vector Tiles plugin not found\");\n            //     return null;\n            // }\n            //\n            // let opts : any = { rendererFactory: ( L.canvas as any ).tile };\n            // if( (layer as any).styles ) {\n            //     opts.vectorTileLayerStyles = (layer as any).styles;\n            // }\n            // if(Config.leafletPane) opts.pane = Config.leafletPane;\n        \t// return Leaflet.vectorGrid.protobuf(href, opts);\n\n        });\n\n\n\n    }\n}\n\nexport default new LayerFactory();\n","\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport * as Q from \"q\";\n\nimport {\n    icon as iconFn, marker as markerFn, circleMarker as circleMarkerFn,\n    SVG, svg, Canvas, canvas,\n    Util\n} from 'leaflet';\n\nimport * as esri from \"esri-leaflet\";\nvar EsriFeatureLayer = esri.FeatureLayer;\n\nimport { Config } from \"@geoplatform/client\";\nimport featurePopupTemplate from '../shared/popup-template';\n\n/**\n * Feature Layer\n * Provides custom style loading and point-ilization as well\n * as adding visibility and opacity manipulation methods\n */\nvar FeatureLayer = EsriFeatureLayer.extend({\n\n    _gpStyle : { color: \"#00f\", weight: 2, fillColor: '#00f', fillOpacity: 0.3 },\n\n    /**\n     * @param  feature - GeoJSON Point Feature\n     * @param latlng - L.LatLng\n     * @return L.Marker\n     */\n    pointToLayerFn: function (feature, latlng) {\n\n        // console.log(\"Feature: \" + feature.id);\n\n        var style = feature && feature.properties ? feature.properties.style : null;\n        if(!style && typeof this.options.style === 'function') {\n            // console.log(\"Using local style function\");\n            try {\n                style = this.options.style(feature);\n            } catch(e) {\n                console.log(\"error using style function in ClusteredFeatureLayer: \" + e.message);\n            }\n        }\n\n        style = style || this.options.style || {};\n\n        let marker = null;\n        if(style.shape === 'image') {\n            let width = style.width || 16;\n            let height = style.height || 16;\n            var icon = iconFn( {\n                iconUrl: style.content, //base64 encoded string\n                iconSize: [width, height],\n                iconAnchor: [width*0.5, height*0.5],\n                popupAnchor: [0, -11],\n            });\n            let mopts = { icon: icon };\n            if(Config.leafletPane) (mopts as any).pane = Config.leafletPane;\n            marker = markerFn( latlng, mopts);\n\n        } else {\n            style.radius = style.radius || style['stroke-width'] || 4;\n            style.weight = style.weight || style['stroke-width'] || 2;\n            style.color = style.color || style.stroke || '#03f';\n            style.opacity = style.opacity || style['stroke-opacity'] || 0.9;\n            style.fillOpacity = style.opacity || style['fill-opacity'] || 0.3;\n            style.fillColor = style.color || style.fill;\n            style.renderer = this.options.renderer;  //important for pane!\n            marker = circleMarkerFn(latlng, style);\n        }\n\n        let popupTemplate = this.options.popupTemplate || featurePopupTemplate;\n        marker.bindPopup(popupTemplate(feature));\n        return marker;\n    },\n\n    /**\n     * for all non-point features, bind a popup\n     * @param  feature - GeoJSON feature\n     * @param layer - L.Layer layer representing feature\n     */\n    eachFeatureFn: function(feature, layer) {\n        if(!feature || !feature.geometry || feature.geometry.type === 'Point') {\n            return;\n        }\n        layer.bindPopup(featurePopupTemplate(feature));\n    },\n\n\n\n    initialize: function (options) {\n\n        var self = this;\n        options = options || {};\n\n        if(Config.leafletPane)\n            options.pane = Config.leafletPane;\n\n        let getGPStyle = () => { return this._gpStyle; };\n        options.style = options.style || getGPStyle();\n\n        //in order to put features-based layers into same pane as tile layers,\n        // must specify renderer and set desired pane on that\n        let svgOpts = { };\n        if(Config.leafletPane)\n            (svgOpts as any).pane = Config.leafletPane;\n        var renderer = (SVG && svg(svgOpts)) || (Canvas && canvas());\n        options.renderer = renderer;\n\n        options.pointToLayer = Util.bind(this.pointToLayerFn, this);\n        options.onEachFeature = Util.bind(this.eachFeatureFn, this);\n\n        // options.fields = ['FID', 'type', 'title', 'geometry'];\n\n        FeatureLayer.prototype.initialize.call(this, options);\n\n        this.on('load', function() {\n            if(typeof this.options.zIndex !== 'undefined')\n                this.setZIndex(this.options.zIndex);\n        });\n\n    },\n\n    setZIndex : function (index) {\n        this.options.zIndex = index;\n        for(var id in this._layers)\n            this._layers[id].setZIndex(index);\n    },\n\n    toggleVisibility: function() {\n        for(var id in this._layers) {\n            let layer = this._layers[id];\n            if(layer.toggleVisibility)\n                this._layers[id].toggleVisibility();\n        }\n    },\n\n    setOpacity: function(opacity) {\n        for(var id in this._layers) {\n            let layer = this._layers[id];\n            if(layer.setOpacity)\n                layer.setOpacity(opacity);\n        }\n    },\n\n    loadStyle: function(gpLayerId) {\n        var self = this;\n\n        if(this.options.styleLoader) {\n            this.options.styleLoader(gpLayerId)\n            .then( json => {\n\n                if(!json) return;\n\n                let style = null;\n\n                if(json && json.styles) {\n\n                    let featureFn = function(feature : any) : any {\n\n                        let property = this.property || this.field1;\n                        let v = feature[property] || (feature.properties ? feature.properties[property] : null);\n                        let style = null;\n                        if(this.styles) {\n                            let wrapper = this.styles.find( sw => sw.value === v );\n                            if(wrapper) {\n                                style = wrapper.style;\n                                style.radius = style.radius || style['stroke-width'] || 4;\n                                style.weight = style.weight || style['stroke-width'] || 2;\n                                style.color = style.color   || style.stroke || '#03f';\n                                style.opacity = style.opacity || style['stroke-opacity'] || 0.9;\n                                style.fillOpacity = style.opacity || style['fill-opacity'] || 0.3;\n                                style.fillColor = style.color || style.fill;\n                            }\n                        }\n                        // console.log(\"Using style: \" + JSON.stringify(style));\n                        return style;\n                    }\n\n                    let styleFn = () => { return featureFn(json); }\n                    this.options.style = styleFn;\n                    this.setStyle(styleFn);\n                    return;\n\n                } else if(json && typeof(json.push) !== 'undefined') {\n                    //multiple styles returned\n                    style = json[0];  //use first for now\n\n                } else if(json) {\n                    style = json;\n\n                } else {\n                    return; //unrecognizable style\n                }\n\n                if(style.shape) {\n                    var obj = jQuery.extend({}, style);\n                    obj.style = style;\n                    this._gpStyle = style;\n\n                    //setStyle on Cluster.FeatureLayer doesn't appear to work consistently for\n                    // non-clustered features.\n                    // this.setStyle(obj);\n                    //So instead, we manually set it on all features of the layer (that aren't clustered)\n                    for(let id in this._layers)\n                        this._layers[id].setStyle(obj);\n\n                }\n            })\n            .catch( e => {\n                console.log(\"Error fetching feature layer style\");\n                console.log(e);\n            });\n        }\n    }\n\n});\n\nexport default FeatureLayer;\n","\n\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport * as Q from \"q\";\nimport * as geojson from 'geojson';\nimport {\n    Map, Layer, LatLng, LatLngBounds,\n    circleMarker, geoJSON,\n    featureGroup, FeatureGroup, LayerGroup\n} from 'leaflet';\n\nimport {\n    Config, ItemTypes,\n    ServiceFactory, ItemService, MapService, LayerService,\n    XHRHttpClient\n} from '@geoplatform/client';\n\nimport LayerFactory from '../layer/factory';\nimport OSM from \"../layer/osm\";\nimport DefaultBaseLayer from '../layer/baselayer-default';\n\n\nclass Listener {\n\n    _listeners : any;\n\n    constructor() {\n        //listeners to be unregistered upon destroy\n        this._listeners = {};\n    }\n\n    on (type, listener) {\n        if(!this._listeners[type])\n            this._listeners[type] = [];\n        this._listeners[type].push(listener);\n    }\n\n    off (type, listener) {\n        if(!type) this._listeners = {};\n        if(!this._listeners[type]) return;\n        if(!listener) this._listeners[type] = [];\n        else {\n            var idx = this._listeners[type].indexOf(listener);\n            if(idx >= 0)\n                this._listeners[type].splice(idx, 1);\n        }\n    }\n\n    notify(type, ...options) {\n        if(!this._listeners[type]) return;\n        var args = Array.prototype.slice.call(arguments, 1);\n        this._listeners[type].forEach(function(l) { l.apply(null, args); });\n    }\n\n}\n\n\n\nexport default class MapInstance extends Listener {\n\n    private svcCache        : any;\n    private serviceFactory  : any;\n    private httpClient      : any;\n    public _key            : string;\n    private _mapId          : string;\n    private _mapDef         : any;\n    private _mapInstance    : Map;\n    private _defaultExtent  : any;\n    private _baseLayerDef   : any;\n    private _baseLayer      : Layer;\n    private _layerStates    : any;\n    private _layerCache     : any;\n    private _layerErrors    : any[];\n    private _layerErrorHandler : Function;\n    private _featureLayer   : FeatureGroup;\n    private _featureLayerVisible  : boolean;\n    private _tools          : any[];\n    private state           : any;\n    private _geoJsonLayerOpts : any;\n\n\n\n\n    constructor(key) {\n        super();\n\n        this.setHttpClient(new XHRHttpClient());\n        this.setServiceFactory(ServiceFactory);\n\n        //generate random key (see factory below)\n        this._key = key || Math.ceil(Math.random()*9999);\n\n        //registry id of current map if available\n        this._mapId = null,\n\n        //definition of map (ie, from server)\n        this._mapDef = this.initializeMapDefinition(),\n\n        //primary map instance (ie, leaflet)\n        this._mapInstance = null,\n\n        //default map extent (if map doesn't have one for being saved)\n        this._defaultExtent = null,\n\n        //current base layer object and leaflet instance\n        this._baseLayerDef = null,\n        this._baseLayer = null,\n\n        //set definitions of layer states (including layer info) on map\n        this._layerStates = [],\n\n        //map layer def ids with leaflet instances\n        this._layerCache = {},\n\n        //errors generated by layers loading\n        this._layerErrors= [],\n        this._layerErrorHandler = function(e) {\n            console.log(`MapInstance.defaultLayerErrorHandler() - ${e.id} : ${e.message}`);\n        },\n\n        //layer used to store features on map\n        this._featureLayer = null,\n        this._featureLayerVisible = true,\n\n        //set of registered map tools\n        this._tools = [],\n\n        //state management\n        this.state = { dirty: false }; // jshint ignore:line\n\n        this._geoJsonLayerOpts  = {\n            style: function(feature) {\n                if(feature.properties.style)\n                    return feature.properties.style;\n            },\n            onEachFeature: function(feature, layer) {\n\n                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };\n                if(~feature.geometry.type.indexOf('Point')) {\n                    style.fillOpacity = 0.9;\n                }\n\n                var props = feature.properties = feature.properties || {};\n                if(feature.properties.id === undefined || feature.properties.id === null)\n                    feature.properties.id = Math.floor(Math.random()*999999);\n                feature.properties.label = props.label || props.title || props.name || \"Untitled \" + feature.geometry.type + \" Feature\";\n                feature.properties.description = props.description || props.desc || \"This feature needs a description!\";\n                feature.properties.style = props.style || style;\n\n                layer.bindTooltip(props.label);\n                /*\n                toggle: setLabelNoHide(bool)\n                it may only exist on markers!\n                */\n            },\n            pointToLayer: function (feature : any, latlng : LatLng ) {\n                var style = feature.properties.style || {};\n                style.radius = style.radius || 4;\n                style.weight = style.weight || 2;\n                style.color = style.color || '#03f';\n                style.opacity = style.opacity || 0.9;\n                style.fillOpacity = style.opacity;\n                style.fillColor = style.color;\n                return circleMarker(latlng, style);\n            }\n        };\n    }\n\n    dispose () {\n        this.destroyMap();\n        this.svcCache = null;\n        this.serviceFactory = null;\n        this.httpClient = null;\n        this._key = null;\n        this._mapId = null;\n        this._mapDef = null;\n        this._mapInstance = null;\n        this._defaultExtent = null;\n        this._baseLayerDef = null;\n        this._baseLayer = null;\n        this._layerStates = null;\n        this._layerCache = null;\n        this._layerErrors= null;\n        this._featureLayer = null;\n        this._featureLayerVisible = true;\n        this._tools = null;\n        this.state = null;\n        this._geoJsonLayerOpts = null;\n    }\n\n\n    getKey () {\n        return this._key;\n    }\n\n    /**\n     * Override default (JQuery-based) map service used by this instance\n     * @param mapService - service to use to CRUD map objects\n     * @deprecated use setServiceFactory instead\n     */\n    setService(mapService : MapService) {\n        // this.mapService = mapService;\n    }\n\n    /**\n     * @param factory - GeoPlatform ServiceFactory to instantiate services for maps and layers\n     */\n    setServiceFactory(factory : any) {\n        this.svcCache = {}; //wipe out cached services\n        this.serviceFactory = factory;\n    }\n\n    /**\n     * @param httpClient - HttpClient impl to use with the new factory\n     */\n    setHttpClient(httpClient : any) {\n        this.svcCache = {}; //wipe out cached services\n        this.httpClient = httpClient;\n    }\n\n    /**\n     * @param type - GeoPlatform Object model type to support (\"Map\", \"Layer\", etc)\n     * @return item service implementation for the requested type\n     */\n    getService(type : string) : ItemService {\n        if(!this.svcCache[type])\n            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);\n        return this.svcCache[type];\n    }\n\n    /**\n     * @param fn - callback when an error is encountered\n     */\n    setErrorHandler(fn) {\n        this._layerErrorHandler = fn;\n    }\n\n\n    //-----------------\n    getLayerStateIndex (layerId) {\n        if(!layerId) return -1;\n        for(let i=0; i<this._layerStates.length; ++i) {\n            if(this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {\n                return i;\n            }\n        }\n        return -1;\n        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );\n    }\n\n    getLayerState (layerId) {\n        let index = this.getLayerStateIndex(layerId);\n        return index >= 0 ? this._layerStates[index] : null;\n    }\n    //-----------------\n\n\n    initializeMapDefinition() {\n        return {\n            type: ItemTypes.MAP,\n            title: \"My New Map\",\n            label: \"My New Map\",\n            description: \"This map needs a description\",\n            createdBy: null,\n            baseLayer: this._baseLayerDef,\n            layers: [],\n            keywords: [],\n            themes: [],\n            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']\n        };\n    }\n\n    /**\n     * @param metadata object\n     * @return object definition of the current map suitable for sending to WMVR\n     */\n    getMapResourceContent(metadata ?: any) {\n\n        metadata = metadata || {};\n\n        //map layers\n        metadata.layers = this._layerStates.map(state => {\n            let result = {\n                visibility : state.visibility || true,\n                opacity : isNaN(state.opacity) ? 1.0 : state.opacity*1,\n                layer: {\n                    id: state.layer.id,\n                    uri: state.layer.uri,\n                    label: state.layer.label,\n                    type: state.layer.type\n                }\n            };\n            return result;\n        });\n        // ... UAL should support accepting just an id here, so we'll do just that\n        metadata.baseLayer = {\n            id: this._baseLayerDef.id,\n            uri: this._baseLayerDef.uri,\n            label: this._baseLayerDef.label,\n            type: this._baseLayerDef.type\n        };\n\n        metadata.annotations = this._featureLayer ?\n            { title: \"Map Features\", geoJSON: this._featureLayer.toGeoJSON() } : null;\n\n        //geographic extent\n        let extent = this._mapInstance.getBounds();\n        metadata.extent = {\n            minx: extent.getWest(),\n            miny: extent.getSouth(),\n            maxx: extent.getEast(),\n            maxy: extent.getNorth()\n        };\n\n        return metadata;\n    }\n\n    /**\n     * @return Leaflet toolbar\n     */\n    getDrawControlToolbar() {\n        if(!(this._mapInstance as any).drawControl) return null;\n        var toolbars = (this._mapInstance as any).drawControl._toolbars;\n        var toolbar = null;\n        for(var key in toolbars) {\n            if(toolbars.hasOwnProperty(key)) {\n                if(toolbars[key]._modes) {\n                    toolbar = toolbars[key];\n                    break;\n                }\n            }\n        }\n        return toolbar;\n    }\n\n    /**\n     * @param error Leaflet tile load error (.target is layer, .tile is image)\n     */\n    handleLayerError(error) {\n        // console.log(\"MapInstance.handleLayerError() - \" +\n        //     \"Layer's tile failed to load: \" + error.tile.src);\n        if(!this._layerCache) {\n            console.log(\"Unable to find layer in layer cache. Layer error is \" + error);\n            return;\n        }\n        var layer = error.target;\n        for(var id in this._layerCache) {\n            if(this._layerCache[id] === layer) {\n                this.processLayerError(error, id);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Given a Leaflet tile load error and the responsible layer id,\n     * Try to isolate the cause of the error using the proxy\n     * and notify listeners that an error has occurred\n     */\n    processLayerError(error : Error, id : string) {\n\n        var finder = (l) => { return l.id === id || (l.layer && l.layer.id === id); };\n\n        if(!this._layerErrors.find(finder)) {\n\n            let obj = this.logLayerError(id, \"Layer ('\" + id + \"') failed to completely load. \" +\n                \"It may be inaccessible or misconfigured.\");\n\n            var url = (error as any).tile.src;\n            var params = {id:id};\n            url.substring(url.indexOf(\"?\")+1, url.length).split('&').forEach(function(param) {\n                var p = param.split('=');\n                params[p[0]] = p[1];\n            });\n\n            let layerService = this.getService(ItemTypes.LAYER) as LayerService;\n            if(layerService) {\n                layerService.validate(id, params)\n                .catch(e => {\n                    var def = this._layerStates.find(finder);\n                    if(def) {\n                        obj.message = \"Layer '\" + def.layer.label + \"' failed to completely load. \" +\n                                \"Reported cause: \" + e.message;\n                    }\n                    this.notify('layer:error', obj);\n                });\n            }\n        }\n    }\n\n    /**\n     * @param layerId - identifier of layer generating the error\n     * @param errorMsg - message of the error\n     */\n    logLayerError(layerId, errorMsg) {\n        // console.log(\"MapInstance.logLayerError() - layer \"  + id +\n        //     \" generated error '\" + errorMsg + \"'\");\n        let err = { id: layerId, message: errorMsg };\n        this._layerErrors.push(err);\n        if(this._layerErrorHandler) {\n            this._layerErrorHandler(err);\n        }\n        return err;\n    }\n\n    /* -- State Management of internal model -- */\n\n    touch (event ?: any, ...options) {\n        this.state.dirty = true;\n        if(event) {\n            if(arguments.length > 1) {\n                this.notify.apply(this, Array.prototype.slice.call(arguments));\n            } else\n                this.notify(event);\n            // console.log(\"Dirtying map for \" + event);\n        }\n        // else console.log(\"Dirtying map\");\n    }\n    clean() {\n        // console.log(\"Cleaning map\");\n        this.state.dirty = false;\n    }\n    /* --------------------------------------- */\n\n\n\n\n    /* ==============================================\n        Map manipulation operations\n       ============================================== */\n\n    setMap (map : Map) { this._mapInstance = map; }\n\n    /**\n     * @return  map instance\n     */\n    getMap () : Map { return this._mapInstance; }\n\n    /** @return definition of map */\n    getMapDefinition () : any { return this._mapDef; }\n\n    /** @return identifier of map */\n    getMapId () : string { return this._mapId; }\n\n    /**\n     * Focuses the map on the specified lat/lng coordinate\n     * @param lat number\n     * @param lng number\n     * @param zoom number (optional)\n     */\n    setView (lat : number, lng : number, zoom ?: number) {\n        let z = zoom;\n        if(typeof(z) === 'undefined')\n            z = this._mapInstance.getZoom();\n        this._mapInstance.setView([lat,lng], z);\n        this.touch('map:view:changed');\n    }\n\n    /**\n     * Retrieve the current center of the map\n     * @return [lat,lng]\n     */\n    getView () : number[] {\n        var latLng = this._mapInstance.getCenter();\n        return [latLng.lat, latLng.lng];\n    }\n\n    /**\n     * @return integer current zoom level of the map\n     */\n    getZoom () : number {\n        return this._mapInstance.getZoom();\n    }\n\n    /**\n     * Zoom to the map's default extent\n     * If the map is saved, this will be the saved viewport\n     * otherwise, it will be CONUS\n     */\n    zoomToDefault () {\n        if(!this._mapInstance) return;\n        if(this._defaultExtent) {\n            this._mapInstance.fitBounds([\n                [this._defaultExtent.miny, this._defaultExtent.minx],\n                [this._defaultExtent.maxy, this._defaultExtent.maxx]\n            ]);\n        } else {\n            console.log(\"MapInstance.zoomToDefault() - No default extent specified\");\n            this._mapInstance.setView([38, -96], 5);\n        }\n        try {\n            this.touch('map:view:changed');\n        } catch(e) { }\n    }\n\n    /**\n     * @param extent - either a GP extent object or Leaflet LatLngBounds object\n     */\n    setExtent(extent : LatLngBounds|any) {\n        if(!extent) return;\n        if( typeof(extent.minx) !== 'undefined' &&\n            typeof(extent.miny) !== 'undefined' &&\n            typeof(extent.maxx) !== 'undefined' &&\n            typeof(extent.maxy) !== 'undefined' ) {\n            //GP model extent\n            this._mapInstance.fitBounds([\n                [extent.miny, extent.minx],\n                [extent.maxy, extent.maxx]\n            ]);\n        } else if(typeof(extent.getWest) !== 'undefined') {\n            //L.LatLngBounds\n            this._mapInstance.fitBounds(extent);\n        } else {\n\n        }\n    }\n\n\n    /* ==============================================\n        Layer operations\n       ============================================== */\n\n\n    /**\n     * @param layer Leaflet Layer instance or object definition\n     */\n    setBaseLayer (layer : any) {\n\n        let promise = null;\n        if(!layer) {\n            let svc = this.getService(ItemTypes.LAYER) as LayerService;\n            promise = DefaultBaseLayer.get(svc);\n        } else\n            promise = Promise.resolve(layer);\n\n        promise.then( layer => {\n\n            let leafletLayer = LayerFactory.create(layer);\n            if(!leafletLayer) {\n                console.log(\"Warning: MapInstance could not create base \" +\n                    \"layer for '\" + layer.id + \"'\");\n                return;\n            }\n\n            this._mapInstance.addLayer(leafletLayer);\n\n            (leafletLayer as any).setZIndex(0);  //set at bottom\n\n            let oldBaseLayer = this._baseLayer;\n            if(oldBaseLayer) {\n                this._mapInstance.removeLayer(oldBaseLayer);\n            }\n\n            //remember new base layer\n            this._baseLayer = leafletLayer;\n            this._baseLayerDef = layer;\n\n            //will notify listeners\n            this.touch('baselayer:changed', layer, leafletLayer);\n            // this.notify('baselayer:changed', layer, leafletLayer);\n\n        })\n        .catch(e => {\n            console.log(`MapInstance.setBaseLayer() - Error getting base layer for map : ${e.message}`);\n            this.logLayerError( layer.id, \"Error setting baselayer on map \" +\n                \"because of the following error(s): \" + e.message );\n        });\n    }\n\n    /**\n     * @return array of base layers definitions that can be used\n     */\n    // getBaseLayerOptions () {\n    //     return this._baseLayerOptions;\n    // },\n\n    getBaseLayer () : any { return this._baseLayerDef; }\n\n    /**\n     * @return list of layer states containing layer information\n     */\n    getLayers () : any[] { return this._layerStates; }\n\n    getLayerErrors () : any[] { return this._layerErrors; }\n\n    clearLayerErrors () {\n        this._layerErrors = [];\n        this.notify('layer:error');\n    }\n\n    clearOverlays () {\n        if(!this._layerCache) return;\n        for(var i=this._layerStates.length-1; i>=0; --i) {\n            var state = this._layerStates[i];\n            var layerInstance = this._layerCache[state.layer.id];\n            if(layerInstance) {\n                layerInstance.off(\"layer:error\");\n                this._layerCache[state.layer.id] = null;\n                this._mapInstance.removeLayer(layerInstance);\n            }\n        }\n        this._layerStates = [];\n        this.touch('layers:changed');\n\n        //TODO stop listening for layer events\n    }\n\n    /**\n     * @param layers - list of layers (NOTE: not wrapped by layer states, this method applies that)\n     */\n    addLayers (layers : any|any[] ) {\n        if(!this._layerCache) {\n            console.log(\"WARN: attempting to add layers to an empty cache\");\n            return;\n        }\n\n        if(!this._layerCache) {\n            console.log(\"WARN: Attempting to add layers to a map with no layer cache\");\n            return;\n        }\n\n        if(!layers) return;\n        if(typeof(layers.push) === 'undefined') {\n            layers = [layers];\n        }\n\n        layers.forEach( (obj,index) => {\n\n            let layer = null, state = null;\n\n            if(obj.type && obj.type===ItemTypes.LAYER) { //is a layer\n                layer = obj;\n            } else if(obj.layer) {  //is layer state\n                layer = obj.layer;  // containing a layer\n                state = obj;\n            }\n\n            if(!layer) {\n                console.log(\"MapInstance.addLayers() - layer (\" + index +\n                    \") is not a Layer or a Layer state. Ignoring...\");\n                return;  //layer info is missing, skip it\n            }\n\n            //DT-442 prevent adding layer that already exists on map\n            if(this._layerCache[layer.id]) return;\n\n            if(!state) {\n                try {\n                    //wrapped in try{}catch because layer may contain circular reference\n                    // which will cause error when used by JSON methods\n                    let layerCopy = JSON.parse(JSON.stringify(layer));\n                    state = {\n                        opacity: 1,\n                        visibility: true,\n                        layer: layerCopy\n                    };\n                } catch(e) {\n                    throw new Error(\"Unable to add layer to map because of \" + e.message);\n                }\n            }\n\n            let z = layers.length - index;\n            state.zIndex = z;\n\n            this.addLayerWithState(layer, state);\n\n        });\n\n        this.touch('layers:changed');\n    }\n\n    /**\n     * @param layer - GeoPlatform Layer instance\n     * @param state - GeoPlatform Layer State\n     */\n    addLayerWithState(layer, state) {\n\n        var leafletLayer = null;\n        try {\n            if(!layer || !state)\n                throw new Error(\"Invalid argument, missing layer and or state\");\n\n            leafletLayer = LayerFactory.create(layer);\n            if(!leafletLayer) {\n                let msg = \"Could not create leaflet instance for GP Layer '\" + layer.id + \"'.\";\n                if(!layer.services || !layer.services.length) {\n                    msg += '  The layer instance has no services included, ' +\n                        'which will prevent most layers from being displayed.';\n                }\n                throw new Error(msg);\n            }\n\n        } catch(e) {\n            this.logLayerError( layer.id,\n                \"Layer '\" + layer.label + \"' could not be added to the \" +\n                \"map instance; \" + e.message);\n        }\n\n        if(!leafletLayer) return;\n\n        //cache leaflet object first\n        if(this._layerCache) this._layerCache[layer.id] = leafletLayer;\n\n        //listen for layer errors so we can inform the user\n        // that a layer hasn't been loaded in a useful way\n        leafletLayer.on('tileerror', (e) => { this.handleLayerError(e); });\n\n        this._mapInstance.addLayer(leafletLayer);\n\n        if( !isNaN(state.zIndex) && leafletLayer.setZIndex )\n            leafletLayer.setZIndex(state.zIndex);\n\n        this._layerStates.push(state);\n\n        this.notify('layer:added', layer, leafletLayer);\n\n\n        // if layer is initially \"off\" or...\n        // if layer is initially not 100% opaque\n        if(!state.visibility || state.opacity < 1) {\n            // initialize layer visibility and opacity async, or else\n            // some of the layers won't get properly initialized\n            setTimeout( (layer, state) => {\n                this.setLayerVisibility(layer, state.visibility);\n                this.setLayerOpacity(layer, state.opacity);\n                //TODO notify of change\n\n                //DT-2102 timeout needs to be large enough or else\n                // feature layers won't get opacity updated on map load\n            }, 2000, leafletLayer, state);\n        }\n    }\n\n    /**\n     * @param from - position of layer being moved\n     * @param to - desired position to move layer to\n     */\n    moveLayer (from : number, to : number) {\n        if(!this._layerCache) return;\n\n        if(!this._layerCache) return;\n\n        if(isNaN(from)) return;\n\n        //end of list\n        if(isNaN(to)) to = this._layerStates.length-1;\n\n        let copy = this._layerStates.splice(from, 1)[0];    //grab layer being moved\n        this._layerStates.splice(to, 0, copy);\n\n        for(let z=1, i=this._layerStates.length-1; i>=0; --i,++z) {\n            let layerState = this._layerStates[i];\n            let layerInstance = this._layerCache[ layerState.layer.id ];\n            if(layerInstance) {\n                layerInstance.setZIndex(z);\n                layerState.zIndex = z;\n            }\n        }\n\n        this.touch('layers:changed', this.getLayers());\n    }\n\n    /**\n     *\n     */\n    removeLayer (id) {\n\n        if(!this._layerCache) return;\n        var layerInstance = this._layerCache[id];\n        if(layerInstance) {\n\n            //remove layer from tracked defs array\n            let index = this.getLayerStateIndex(id);\n            // console.log(\"MapInstance.removeLayer(\" + id + \")\");\n            if(index >= 0 && index < this._layerStates.length)\n                this._layerStates.splice(index, 1);\n\n            //stop listening for errors\n            layerInstance.off(\"layer:error\");\n\n            //remove layer from map\n            this._mapInstance.removeLayer(layerInstance);\n\n            //remove layer from cache\n            this._layerCache[id] = null;\n        }\n        this.touch('layers:changed');\n    }\n\n    /**\n     *\n     */\n    toggleLayerVisibility (id) {\n        if(!this._layerCache) return;\n        var layerInstance = this._layerCache[id];\n        if(layerInstance) {\n            let state = this.getLayerState(id);\n            state.visibility = !state.visibility;\n\n            if(layerInstance._currentImage) {\n                //ESRI Image Service layers have an IMG element\n                // that gets modified and replaced every map event (zoom/pan)\n                // so we can't just toggle classes like on other layers.\n                //Instead, we need to use the ESRI setOpacity method to toggle\n                // but need to update layer state as well.\n                layerInstance.setOpacity(state.visibility ? 1 : 0);\n                state.opacity = layerInstance.getOpacity();\n                return;\n            }\n\n            this.setLayerVisibility(layerInstance, state.visibility);\n        }\n    }\n\n    /**\n     * Note: this does not update layer definition state. Use\n     * MapInstance.toggleLayerVisibility to do that and adjust\n     * rendered layer's visibility.\n     *\n     * @param layerInstance - leaflet layer instance\n     * @param visible - flag indicating visibility of layer\n     */\n    setLayerVisibility (layerInstance : Layer, visible : boolean) {\n\n        if((layerInstance as any).setVisibility) {\n            //using custom method provided in src/layer/module.js\n            (layerInstance as any).setVisibility(visible);\n\n        } else if((layerInstance as any)._container) {\n            //otherwise, using jquery on dom directly\n            let el = jQuery((layerInstance as any)._container);\n            // if(visible) el.removeClass(\"invisible\");\n            // else el.addClass('invisible');\n            el.css({'display': visible ? '' : 'none'});\n        }\n\n        this.touch('map:layer:changed');\n    }\n\n    /**\n     *\n     */\n    updateLayerOpacity (id : string, opacity : number) {\n\n        if(!this._layerCache) return;\n        var layerInstance = this._layerCache[id];\n\n        //if layer id is for base layer...\n        if(!layerInstance && this._baseLayerDef.id === id) {\n            layerInstance = this._baseLayer;\n        }\n\n        //adjust rendered leaflet layer\n        opacity = this.setLayerOpacity(layerInstance, opacity);\n\n        // if overlay layer, update state value\n        let state = this.getLayerState(id);\n        if(state) state.opacity = opacity;\n\n    }\n\n    /**\n     * Note: this method does not update the associated Layer Definition\n     * state value for opacity. Use MapInstance.updateLayerOpacity() to\n     * both update state and adjust rendered layer.\n     *\n     * @param layerInstance - leaflet layer instance\n     * @param opacity - value between 0 and 1.0 or 0 and 100\n     * @return normalized opacity value between 0 and 1.0\n     */\n    setLayerOpacity (layerInstance : Layer, opacity : number) : number {\n        if(layerInstance && (layerInstance as any).setOpacity) {\n            if(opacity > 1.0) opacity = opacity / 100.0;\n            (layerInstance as any).setOpacity(opacity);\n            this.touch('map:layer:changed');\n        }\n        return opacity;\n    }\n\n    /**\n     * @param GeoPlatform Layer instance\n     * @return Leaflet layer instance representing that layer or null\n     */\n    getLeafletLayerFor (gpLayer : any) : Layer {\n        if(!gpLayer || !this._layerCache) return null;\n        let leafletLayer = this._layerCache[gpLayer.id];\n        return leafletLayer || null;\n    }\n\n    /**\n     *\n     */\n    toggleGetFeatureInfo (layerId : string) {\n        if(!this._layerCache) return;\n        var layerInstance = this._layerCache[layerId];\n        if(layerInstance) {\n            if(typeof(layerInstance.enableGetFeatureInfo) !== 'undefined') {\n                if(layerInstance.isGetFeatureInfoEnabled()) {\n                    layerInstance.disableGetFeatureInfo();\n                    jQuery((this._mapInstance as any)._container).removeClass('selectable-cursor');\n                } else {\n                    layerInstance.enableGetFeatureInfo();\n                    jQuery((this._mapInstance as any)._container).addClass('selectable-cursor');\n                }\n            }\n\n        }\n    }\n\n\n    /* ==============================================\n       Feature operations\n       ============================================== */\n\n\n    /**\n     * @return array of features on the map\n     */\n    getFeatures () : any[] {\n        if(this._featureLayer) {\n            let geojson = this._featureLayer.toGeoJSON();\n            return (geojson as any).features;\n        }\n        return [];\n    }\n\n    /**\n     * @param json geojson object or array of geojson objects\n     */\n    addFeatures (json : any) {\n\n        if(!json) return;\n\n        if(typeof(json.push) !== 'undefined') {\n            //array of features\n            for(var i=0; i<json.length; ++i)\n                this.addFeature(json[i], false);\n            this.touch('features:changed');\n\n        } else if(json.features) {\n            this.addFeatures(json.features);\n\n        } else { //single feature\n            this.addFeature(json, true);\n        }\n\n    }\n\n    /**\n     * @param json geojson object\n     */\n    addFeature (json : any, fireEvent ?: boolean) {\n        // var type = json.type;\n        // var coordinates = json.coordinates;\n\n        if(!this._featureLayer) {\n\n            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);\n            this._featureLayer = featureGroup().addTo(this._mapInstance);\n\n        }\n\n        // _featureLayer.addData(json);\n        var opts = jQuery.extend({}, this._geoJsonLayerOpts);\n        geoJSON(json, opts).eachLayer((l)=>this.addFeatureLayer(l));\n\n        if(typeof(fireEvent) === 'undefined' || fireEvent === true)\n            this.touch('features:changed');\n        else this.touch();\n\n        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));\n\n    }\n\n    /**\n     * @param featureJson object defining a GeoJSON feature\n     */\n    updateFeature (featureJson : any) {\n        var layer = this.getFeatureLayer(featureJson.properties.id);\n        if(layer) {\n\n            (layer as any).feature = featureJson;\n\n            //update style\n            layer.setStyle(featureJson.properties.style);\n\n            //rebind label in case that changed\n            var label = featureJson.properties.label ||\n                \"Untitled \" + featureJson.geometry.type + \" Feature\";\n            layer.bindTooltip(label);\n\n            // layer.redraw();\n            this.touch(\"map:feature:changed\");\n        }\n    }\n\n    /**\n     * Replace an existing L.Path-based layer with one using\n     * the supplied Feature GeoJSON object.  Removes the existing\n     * layer and adds a new one created from the GeoJSON.\n     *\n     * @param featureJson object defining GeoJSON feature\n     */\n    replaceFeature (featureJson : any) {\n\n        //find existing layer for this feature\n        var layer = this.getFeatureLayer(featureJson.properties.id);\n        if(layer) {\n\n            //remove existing\n            this._featureLayer.removeLayer(layer);\n\n            //add replacement\n            geoJSON(featureJson, this._geoJsonLayerOpts)\n                .eachLayer((l)=>this.addFeatureLayer(l));\n\n            this.touch(\"map:feature:changed\");\n        }\n    }\n\n    /**\n     * @param featureId identifier of feature to focus the map on\n     */\n    focusFeature (featureId : string) {\n        var layer = this.getFeatureLayer(featureId);\n        if(layer) {\n            if( typeof(layer.getBounds) !== 'undefined') {\n                let extent = layer.getBounds();\n                this._mapInstance.fitBounds(extent);\n            } else if(typeof( (layer as any).getLatLng) !== 'undefined') {\n                let latLng = (layer as any).getLatLng();\n                this._mapInstance.panTo(latLng);\n            } else {\n                console.log(\"MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng\");\n            }\n        } else {\n            console.log(\"MapInstance.focusFeature() - Cannot focus feature because it has no layer\");\n        }\n    }\n\n    /**\n     * @param featureId : string\n     */\n    removeFeature (featureId) {\n        var layer = this.getFeatureLayer(featureId);\n        if(layer && this._featureLayer) {\n            this._featureLayer.removeLayer(layer);\n            this.touch('features:changed');\n        }\n    }\n\n    /**\n     *\n     */\n    removeFeatures () {\n        if(this._featureLayer) {\n            this._featureLayer.clearLayers();\n            this.touch(\"features:changed\");\n        }\n    }\n\n    /**\n     *\n     */\n    getFeatureLayer ( featureId ?: string ) : FeatureGroup {\n        //if no feature was specified, return root feature layer\n        if(!featureId) return this._featureLayer;\n\n        //otherwise, find feature...\n        if(!this._featureLayer) return null;\n\n        var features = this._featureLayer.getLayers();\n        for(var i=0; i<features.length; ++i) {\n            if( (features[i] as any).feature &&\n                (features[i] as any).feature.properties.id === featureId) {\n                return (features[i] as any);\n            }\n        }\n        return null;\n    }\n\n    toggleFeaturesLayer () {\n        if(!this._featureLayer) return false;    //ignore if not rendered yet\n\n        this._featureLayerVisible = !this._featureLayerVisible;\n        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);\n        return this._featureLayerVisible;\n    }\n\n    /**\n     * @param  feature - Leaflet feature instance\n     * @param  visibility - flag\n     */\n    setFeatureVisibility (feature, visibility : boolean) {\n        this.setFeatureLayerVisibility(feature, visibility);\n    }\n\n    getFeaturesLayerVisibility () {\n        return this._featureLayerVisible;\n    }\n\n\n    /*\n     * method for adding feature layers to the map\n     * when these layers may be layer groups.\n     * finds leaf node layers and adds them to the\n     * map's feature group\n     */\n    addFeatureLayer(layer) {\n        this._addFeatureLayer(layer);\n        this.touch(\"features:changed\");\n    }\n\n    /**\n     * Internal method, use 'addFeatureLayer' instead\n     * @param layer\n     */\n    _addFeatureLayer(layer : Layer) {\n        if(!(layer as any).feature && layer instanceof LayerGroup) {\n            layer.eachLayer( (child) => {\n                this._addFeatureLayer(child);\n            });\n        } else {\n            this._featureLayer.addLayer(layer);\n        }\n    }\n\n\n    //toggle visibility of parent feature layer\n    setFeatureLayerVisibility(layer, visibility) {\n        if(!layer) return;\n        this._featureLayerVisible = visibility;\n\n        if(layer.getLayers) {\n            layer.getLayers().forEach( (child) => {\n                this.setFeatureLayerVisibility(child, visibility);\n            });\n\n        } else {\n            let container = layer._container || layer._path;\n            if(container)\n                container.style.display = visibility ? '' : 'none';\n        }\n    }\n\n\n\n    /* ==============================================\n       Map lifecycle operations\n       ============================================== */\n\n    /**\n     * @param metadata\n     * @return resolving persisted map\n     */\n    save (metadata : any) : Promise<any> {\n        return this.saveMap(metadata);\n    }\n\n    /**\n     * @param md object containing metadata properties for map\n     */\n    saveMap (md : any) : Promise<any> {\n\n        let metadata = md || {};\n\n        //add GeoPlatformMap resource type if not already present\n        const gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';\n        metadata.resourceTypes = metadata.resourceTypes || [];\n        if(metadata.resourceTypes.indexOf(gpMapType) < 0)\n            metadata.resourceTypes.push(gpMapType);\n\n        var content = this.getMapResourceContent(metadata);\n\n        //ensure the two name properties line up\n        if(content.title && content.title !== content.label) {\n            content.label = content.title;\n        } else if(content.label && !content.title) {\n            content.title = content.label;\n        }\n\n        // console.log(\"Updating: \" + JSON.stringify(map));\n        return new Promise<any>( (resolve, reject) => {\n            this.getService(ItemTypes.MAP).save(content)\n            .then( result => {\n\n                //track new map's info so we can update it with next save\n                if(!this._mapId)\n                    this._mapId = result.id;\n\n                this._mapDef = result;\n                this._defaultExtent = result.extent;\n                this.clean();\n                resolve(result);\n            })\n            .catch(err=>{\n                console.log(\"MapCore MapInstance.saveMap() - \" +\n                    \"The requested map could not be saved because: \" + err.message);\n                let e = new Error(\"The requested map could not be saved because of the following error(s): \" +\n                    err.message);\n                reject(e);\n            });\n        });\n\n    }\n\n    /**\n     * Retrieve a map's descriptor from the registry\n     * @param mapId identifier of map\n     * @return resolving the map object\n     */\n    fetchMap (mapId : string) : any {\n        //Having to send cache busting parameter to avoid CORS header cache\n        // not sending correct Origin value\n        return this.getService(ItemTypes.MAP).get(mapId);\n    }\n\n    /**\n     * Retrieve a map's descriptor and load it as the\n     * current map managed by this service\n     * @param mapId identifier of map\n     * @return resolving the map object\n     */\n    loadMap (mapId : string) : any {\n\n        return new Promise<any>( (resolve, reject) => {\n\n            this.fetchMap(mapId).then(map => {\n\n                if(!map) {\n                    throw new Error(\"The requested map ('\" + mapId +\n                        \"') came back null\");\n\n                } else if(typeof(map) === 'string') {\n                    throw new Error(\"The requested map ('\" + mapId +\n                        \"') came back as a string\");\n\n                } else if((map as any).message) {\n                    throw new Error(\"There was an error loading the requested map ('\" +\n                        mapId + \"'): \" + (map as any).message);\n                }\n\n\n                //loading a map by its ID, so we need to increment it's view count\n                if('development' !== Config.env) {\n\n                    setTimeout( (map) => {\n                        //update view count\n                        let views = map.statistics ? (map.statistics.numViews||0) : 0;\n                        let patch = [ { op: 'replace', path: '/statistics/numViews', value: views+1 } ];\n                        this.getService(ItemTypes.MAP).patch(map.id, patch)\n                        // this.mapService.patch(map.id, patch)\n                        .then( updated => { map.statistics = updated.statistics; })\n                        .catch( e => {\n                            console.log(\"MapInstance.loadMap() - Error updating view \" +\n                                \"count for map ('\" + mapId + \"'): \" + e);\n                        });\n                    }, 1000, map);\n\n                }\n\n                //load the map into the viewer\n                this.loadMapFromObj(map);\n\n                resolve(map);\n            })\n            .catch( err => {\n                console.log(\"MapInstance.loadMap() - \" +\n                    \"The requested map could not be loaded because \" + err.message);\n                let e = new Error(\"The requested map ('\" + mapId +\n                    \"') could not be loaded because of the following error(s): \" +\n                    err.message);\n                reject(e);\n            });\n        });\n    }\n\n    /**\n     * Load a map from its descriptor as the current\n     * map managed by this service\n     * @param map object\n     */\n    loadMapFromObj (map : any) {\n\n        // console.log(\"Loading Map Object\");\n        // console.log(map);\n\n        this._mapId = map.id;\n        this._mapDef = map;\n\n        map.extent = this.ensureExtent(map.extent);\n\n        //set extent from loaded map\n        this._defaultExtent = map.extent;\n        var extent = map.extent;\n\n        //remove existing layers\n        this._mapInstance.eachLayer((l) => {\n            this._mapInstance.removeLayer(l);\n        });\n        this._layerCache = {};\n        this._layerStates = [];\n\n        //set new base layer\n        this.setBaseLayer(map.baseLayer);\n\n        //add layers from loaded map\n        this.addLayers(map.layers);\n\n        //add features\n        if(map.annotations && map.annotations.geoJSON) {\n            let fc = map.annotations.geoJSON;\n            if(fc.features)\n                this.addFeatures(fc.features);\n            else\n                this.addFeatures([fc]);\n        }\n\n        this._mapInstance.fitBounds([\n            [extent.miny, extent.minx],\n            [extent.maxy, extent.maxx]\n        ]);\n\n        this.clean();\n        this.notify('map:loaded', map);\n\n    }\n\n\n    /**\n     * @param extent\n     * @return corrected or default extent\n     */\n    ensureExtent( extent : any ) : any {\n\n        let west  = !extent || isNaN(extent.minx) ? -179.0 : extent.minx*1.0;\n        let east  = !extent || isNaN(extent.maxx) ?  179.0 : extent.maxx*1.0;\n        let south = !extent || isNaN(extent.miny) ?  -89.0 : extent.miny*1.0;\n        let north = !extent || isNaN(extent.maxy) ?   89.0 : extent.maxy*1.0;\n\n        //ensure x,y is ordered correctly\n        let t;\n        if(west > east) {\n            t = Math.min(west, east);\n            east = Math.max(west, east);\n            west = t;\n        }\n        if(south > north) {\n            t = Math.min(south, north);\n            north = Math.max(south, north);\n            south = t;\n        }\n\n        //prevent out-of-bounds extents\n        if(west < -180.0) west = -179.0;\n        if(east > 180.0)  east =  179.0;\n        if(south < -90.0) south = -89.0;\n        if(north > 90.0)  north =  89.0;\n\n        return { minx : west, miny : south, maxx : east, maxy : north };\n    }\n\n\n    /**\n     *\n     */\n    destroyMap () {\n        // console.log(\"Destroying Map\");\n        this._mapInstance = null;\n        this._layerCache = null;\n        this._layerStates = null;\n        this._featureLayer = null;\n    }\n\n\n    /**\n     * Used to take an existing map that is already persisted on the\n     * server and unlink it here in the client so that it will be saved\n     * as a completely new map when mapService.saveMap(...) is next called\n     */\n    setAsNewMap (mapToUse) {\n        this._mapId = null;\n        this._mapDef = mapToUse || this.initializeMapDefinition();\n    }\n\n\n    /* ==============================================\n        Tool operations\n       ============================================== */\n\n    registerTool (id, tool) {\n        this._tools[id] = tool;\n    }\n\n    unregisterTool (id) {\n        this._tools[id] = null;\n    }\n\n    enableTool (id, finish) {\n        if(!this._tools[id]) return false;\n        this._tools[id].activate(function() {\n            this.notify('tool:disabled', id);\n        });\n        this.notify('tool:enabled', id);\n    }\n\n\n    /* ----------- MISC ------------ */\n\n    //https://github.com/gsklee/ngStorage\n    cacheMap () {\n\n        if(this.state && this.state.dirty) {\n            var map = this.getMapResourceContent();\n            //use exploded layer info\n            map.layers = this._layerStates.slice(0);\n            // $sessionStorage.map = map;\n        }\n    }\n\n    restoreMap () {\n        // if($sessionStorage.map) {\n        //     console.log(\"Restoring cached map\");\n        //     let map = $sessionStorage.map;\n        //     // console.log(JSON.stringify(map));\n        //     $sessionStorage.map = null;\n        //     this.loadMapFromObj(map);\n        // }\n    }\n    /* ---------------------------- */\n}\n","\nimport MapInstance from './instance';\n\nvar cache = {};\n\nexport default {\n\n    get: function(key) {\n        if(key && cache[key])\n            return cache[key];\n\n        let instance = new MapInstance(key);\n        cache[instance._key] = instance;\n        return instance;\n    },\n\n    dispose: function(key) {\n        if(key) {\n            cache[key].dispose();\n            delete cache[key];\n        } else {\n            cache = null;\n        }\n    }\n};\n","\n\nexport default function() {\n\n    if (typeof Object.assign != 'function') {\n        // Must be writable: true, enumerable: false, configurable: true\n        Object.defineProperty(Object, \"assign\", {\n            value: function assign(target, varArgs) { // .length of function is 2\n                'use strict';\n                if (target == null) { // TypeError if undefined or null\n                    throw new TypeError('Cannot convert undefined or null to object');\n                }\n\n                var to = Object(target);\n\n                for (var index = 1; index < arguments.length; index++) {\n                    var nextSource = arguments[index];\n\n                    if (nextSource != null) { // Skip over if undefined or null\n                        for (var nextKey in nextSource) {\n                            // Avoid bugs when hasOwnProperty is shadowed\n                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                                to[nextKey] = nextSource[nextKey];\n                            }\n                        }\n                    }\n                }\n                return to;\n            },\n            writable: true,\n            configurable: true\n        });\n    }\n\n}\n","\nimport Polyfills from \"./polyfills\";\nPolyfills();\n\n\nimport LoadingControl from './control/loading';\nimport MeasureControl from './control/measure';\nimport MousePositionControl from './control/mouse-position';\nimport FeatureEditor from './control/feature-editor';\n\nimport DefaultBaseLayer from './layer/baselayer-default';\nimport LayerFactory from './layer/factory';\nimport OSMLayerFactory from './layer/osm-factory';\nimport BaseClusteredFeatureLayer from './layer/base-clustered-feature-layer';\nimport {\n    ClusteredFeatureLayer,\n    clusteredFeatures,\n    geoJsonFeed\n} from './layer/cluster-feature';\nimport FeatureLayer from './layer/feature';\nimport {WMS, wms} from './layer/wms';\nimport {WMST, wmst} from './layer/wmst';\nimport {WMTS, wmts} from './layer/wmts';\nimport ESRITileLayer from './layer/esri-tile-layer';\nimport OSM from './layer/osm';\nimport { mapBoxVectorTileLayer } from './layer/mbvt';\n\nimport MapInstance from './map/instance';\nimport MapFactory from './map/factory';\n\nimport ServiceTypes from './service/types';\n\nimport PopupTemplate from './shared/popup-template';\nimport StyleResolver from './shared/style-resolver';\nimport parseMapBoxStyle from './shared/mapbox-style';\n\n\n\nexport {\n    LoadingControl,\n    MeasureControl,\n    MousePositionControl,\n    FeatureEditor,\n    DefaultBaseLayer,\n    LayerFactory,\n    OSMLayerFactory,\n    BaseClusteredFeatureLayer,\n    ClusteredFeatureLayer,\n    clusteredFeatures,\n    geoJsonFeed,\n    FeatureLayer,\n    WMS, wms,\n    WMST, wmst,\n    WMTS, wmts,\n    ESRITileLayer,\n    OSM,\n    mapBoxVectorTileLayer,\n    MapInstance,\n    MapFactory,\n    ServiceTypes,\n    PopupTemplate,\n    StyleResolver,\n    parseMapBoxStyle\n};\n"]}