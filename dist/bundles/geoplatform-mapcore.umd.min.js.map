{"version":3,"sources":["ng://@geoplatform/mapcore/control/loading.ts","ng://@geoplatform/mapcore/control/measure.ts","ng://@geoplatform/mapcore/control/mouse-position.ts","node_modules/tslib/tslib.es6.js","ng://@geoplatform/mapcore/control/feature-editor.ts","ng://@geoplatform/mapcore/service/types.ts","ng://@geoplatform/mapcore/layer/osm.ts","ng://@geoplatform/mapcore/layer/baselayer-default.ts","ng://@geoplatform/mapcore/layer/base-clustered-feature-layer.ts","ng://@geoplatform/mapcore/shared/style-resolver.ts","ng://@geoplatform/mapcore/shared/popup-template.ts","ng://@geoplatform/mapcore/layer/cluster-feature.ts","ng://@geoplatform/mapcore/layer/wms.ts","ng://@geoplatform/mapcore/layer/wmst.ts","ng://@geoplatform/mapcore/layer/wmts.ts","ng://@geoplatform/mapcore/layer/esri-tile-layer.ts","ng://@geoplatform/mapcore/layer/osm-factory.ts","ng://@geoplatform/mapcore/layer/factory.ts","ng://@geoplatform/mapcore/layer/feature.ts","ng://@geoplatform/mapcore/map/instance.ts","ng://@geoplatform/mapcore/map/factory.ts","ng://@geoplatform/mapcore/polyfills.ts","ng://@geoplatform/mapcore/index.ts"],"names":["loadingControl","Control","extend","options","position","separate","zoomControl","spinjs","spin","lines","length","width","radius","rotate","top","initialize","Util","setOptions","this","_dataLoaders","onAdd","map","_addLayerListeners","_addMapListeners","zoomsliderControl","container","classes","_container","DomUtil","create","_indicator","onRemove","_removeLayerListeners","_removeMapListeners","removeFrom","removeChild","_map","prototype","remove","call","addLoader","id","updateIndicator","removeLoader","isLoading","_showIndicator","_hideIndicator","_countLoaders","key","size","hasOwnProperty","addClass","Zoom","removeClass","_zoomOutButton","_handleLoading","e","getEventId","_handleLoad","layer","_leaflet_id","target","_layerAdd","on","loading","load","exception","console","warn","eachLayer","off","dataloading","dataload","layerremove","L","L_1","Loading","Map","addInitHook","addControl","measureControl","_createButton","_toggleMeasure","html","title","className","fn","context","link","innerHTML","href","DomEvent","stopPropagation","preventDefault","_measuring","_startMeasuring","_stopMeasuring","_oldCursor","style","cursor","_doubleClickZoom","doubleClickZoom","enabled","disable","_mouseMove","_mouseClick","_finishPath","_layerPaint","layerGroup","addTo","_points","enable","clearLayers","_restartPath","latlng","_lastPoint","_layerPaintPathTemp","spliceLatLngs","polyline","color","weight","clickable","dashArray","_tooltip","_distance","_updateTooltipPosition","distance","distanceTo","_updateTooltipDistance","_createTooltip","_layerPaintPath","addLatLng","_lastCircle","removeLayer","markerOpts","opacity","fill","fillOpacity","CircleMarker","undefined","icon","divIcon","iconAnchor","marker","setLatLng","total","difference","totalRound","_round","differenceRound","text","_icon","val","Math","round","_onKeyDown","keyCode","Measure","control","measure","mergeOptions","positionControl","separator","emptyString","lngFirst","numDigits","lngFormatter","latFormatter","prefix","disableClickPropagation","_onMouseMove","lng","formatNum","lat","value","prefixAndValue","MousePosition","mousePosition","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","__extends","__","constructor","FeatureEditor","doneEditing","unregisterTool","tool","deactivate","getMap","removeControl","editingLayer","showOriginalLayer","bool","feature","properties","getFeatureLayer","setFeatureVisibility","beginEditing","visible","originalFeature","GeoJSON","geometryToLayer","toGeoJSON","FeatureGroup","geometry","type","indexOf","type_1","replace","coordinates","each","childCoords","shape","onEachFeature","addLayer","geometries","childGeometry","EditFeature","featureGroup","activate","save","hasBeenEdited","isMulti_1","isGeomColl_1","geoms_1","coords_1","geometry_1","replaceFeature","updateFeature","addProperty","highlightFeature","focusFeature","deleteFeature","removeFeature","style_1","setStyle","cancelEditing","_super","tslib_1.__extends","opts","selectedPathOptions","fillColor","maintainColor","handler","Draw","EditToolbar","Edit","result","edited","assign","draw","edit","keyFn","expr","str","m","exec","OSM","test","resourceTypes","get","layerService","query","QueryFactory","fields","LayerService","Config","ualUrl","XHRHttpClient","search","then","response","results","catch","Q.reject","DefaultBaseLayer","baseLayerId","set","defaultBaseLayerId","ogcExpr","esriExpr","types","ESRI_FEATURE_SERVER","uri","description","label","ESRI_IMAGE_SERVER","ESRI_MAP_SERVER","ESRI_TILE_SERVER","KML","CSW","WCS","WFS","WMS","WMTS","WMST","FEED","refresh","updateList","service","url","pageSize","ItemService","data","i","supported","toUpperCase","error","log","message","BaseClusteredFeatureLayer","esri.FeatureManager","statics","EVENTS","CLUSTEREVENTS","_layers","_leafletIds","cluster","MarkerClusterGroup","_key","random","toString","addEventParent","createLayers","features","markers","geojson","newLayer","asFeature","defaultOptions","resetStyle","fire","timeField","_featureWithinTimeRange","push","addLayers","ids","layersToAdd","removeLayers","permanent","layersToRemove","setFeatureStyle","eachFeature","getFeature","jQuery","jquery","featureStyleResolver","deferred","Q.defer","ajax","dataType","success","resolve","xhr","status","Error","reject","promise","featurePopupTemplate","pFn","list","names","find","name","lc","toLowerCase","date","props","keys","titleProp","descProp","modified","Date","toDateString","toTimeString","linkProp","prop","ClusteredFeatureLayer","currentVisibility","currentOpacity","_gpStyle","pointToLayerFn","stroke","renderer","height","mopts","iconFn","iconUrl","content","iconSize","popupAnchor","pane","markerFn","circleMarkerFn","popupTemplate","bindPopup","eachFeatureFn","_this","pointToLayer","bind","spiderfyDistanceMultiplier","styleResolver","svgOpts","SVG","svg","Canvas","canvas","zIndex","setZIndex","layerId","loadStyle","setVisibility","setOpacity","index","lyr","_updateZIndex","_renderer","toggleVisibility","_featureGroup","display","isNaN","css","gpLayerId","styleLoader","json","styles","styleFn","property","field1","v","wrapper","sw","JSON","stringify","featureFn_1","setTimeout","obj","clusteredFeatures","services","supportedFormats","layerName","leafletPane","geoJsonFeed","layerUrl","styleUrl","isModern","TileLayer","enableGetFeatureInfo","getFeatureInfo","_enabled","disableGetFeatureInfo","isGetFeatureInfoEnabled","evt","getFeatureInfoUrl","parseGetFeatureInfo","point","latLngToContainerPoint","getSize","params","srs","bbox","getBounds","toBBoxString","y","x","info_format","j","wmvId","getParamString","field","join","showGetFeatureInfo","err","popup","maxWidth","setContent","openOn","wms","formats","format","version","api","filter","accessURL","layers","transparent","tileLayer","L.TimeDimension","Layer","_parseTimeDimensionFromCapabilities","xml","querySelectorAll","_baseLayer","wmsParams","times","forEach","current","querySelector","_getTimesFromLayerCapabilities","parentNode","dimensions","textContent","trim","extents","toISOString","wmst","gpLayer","leafletLayer","proxyUrl","tdOpts","temporal","d1","startDate","d2","endDate","timeDimension","( /** @type {?} */(L)).TimeDimension","proxy","paramRe","_url","defaultWmtsParams","request","tileMatrixSet","wmtsParams","tileSize","detectRetina","Browser","retina","matrixIds","getDefaultMatrix","_crs","crs","getTileUrl","coords","nwPoint","multiplyBy","sePoint","add","Point","zoom","_tileZoom","nw","project","unproject","tilewidth","ident","identifier","X0","topLeftCorner","Y0","tilecol","floor","tilerow","isTileMatrixTemplated","isTileRowTemplated","isTileColTemplated","o","s","_getSubdomain","k","TileMatrix","TileRow","TileCol","qsi","template","setParams","noRedraw","redraw","matrixIds3857","LatLng","tilePoint","abs","subdomains","wmts","distro","distributions","dist","mediaType","parameters","param","plc","defaultValue","values","EsriTileLayer","defaultESRIParams","f","qidx","substring","dim","esriParams","imagesr","bboxsr","code","z","se","ESRI","esri","OSMLayerFactory","minZoom","maxZoom","attribution","LayerFactory","factories","init","include","LayerFactory$1","register","setLayerService","getStyleResolver","styleResolverFactory","msg","typeUri","serviceType","supportedCRS","checkUrl","ServiceTypes","ESRITileLayer","useCors","esri.tiledMapLayer","esri.imageMapLayer","FeatureLayer","esri.FeatureLayer","Listener","listener","_listeners","idx","splice","notify","_i","arguments","args","slice","l","apply","MapInstance","dispose","destroyMap","svcCache","serviceFactory","httpClient","_mapId","_mapDef","_mapInstance","_defaultExtent","_baseLayerDef","_layerStates","_layerCache","_layerErrors","_featureLayer","_featureLayerVisible","_tools","state","_geoJsonLayerOpts","getKey","setService","mapService","setServiceFactory","factory","setHttpClient","getService","setErrorHandler","_layerErrorHandler","getLayerStateIndex","getLayerState","initializeMapDefinition","ItemTypes","MAP","createdBy","baseLayer","keywords","themes","getMapResourceContent","metadata","annotations","geoJSON","extent","minx","getWest","miny","getSouth","maxx","getEast","maxy","getNorth","getDrawControlToolbar","drawControl","toolbars","_toolbars","toolbar","_modes","handleLayerError","processLayerError","finder","obj_1","logLayerError","tile","src","split","LAYER","validate","def","errorMsg","touch","event","dirty","clean","setMap","getMapDefinition","getMapId","setView","getZoom","getView","latLng","getCenter","zoomToDefault","fitBounds","setExtent","setBaseLayer","Q.resolve","svc","oldBaseLayer","getBaseLayer","getLayers","getLayerErrors","clearLayerErrors","clearOverlays","layerInstance","visibility","parse","addLayerWithState","setLayerVisibility","setLayerOpacity","moveLayer","from","to","copy","layerState","toggleLayerVisibility","_currentImage","getOpacity","updateLayerOpacity","getLeafletLayerFor","toggleGetFeatureInfo","getFeatures","addFeatures","addFeature","fireEvent","addFeatureLayer","featureJson","bindTooltip","featureId","getLatLng","panTo","removeFeatures","toggleFeaturesLayer","setFeatureLayerVisibility","getFeaturesLayerVisibility","_addFeatureLayer","LayerGroup","child","_path","saveMap","md","gpMapType","fetchMap","mapId","loadMap","patch","op","path","statistics","numViews","updated","loadMapFromObj","t","west","east","south","north","min","max","fc","setAsNewMap","mapToUse","registerTool","enableTool","finish","cacheMap","restoreMap","ServiceFactory","ceil","desc","circleMarker","cache","instance","Polyfills","defineProperty","varArgs","TypeError","nextSource","nextKey","writable","configurable"],"mappings":"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","sourcesContent":["\nimport { Control, Util, DomUtil, Map } from 'leaflet';\n\nvar loadingControl = Control.extend({\n    options: {\n        position: 'topleft',\n        separate: false,\n        zoomControl: null,\n        spinjs: false,\n        spin: {\n          lines: 7,\n          length: 3,\n          width: 3,\n          radius: 5,\n          rotate: 13,\n          top: \"83%\"\n        }\n    },\n\n    initialize: function(options) {\n        Util.setOptions(this, options);\n        this._dataLoaders = {};\n\n        // Try to set the zoom control this control is attached to from the\n        // options\n        if (this.options.zoomControl !== null) {\n            this.zoomControl = this.options.zoomControl;\n        }\n    },\n\n    onAdd: function(map) {\n\n        this._addLayerListeners(map);\n        this._addMapListeners(map);\n\n        // Try to set the zoom control this control is attached to from the map\n        // the control is being added to\n        if (!this.options.separate && !this.zoomControl) {\n            if (map.zoomControl) {\n                this.zoomControl = map.zoomControl;\n            } else if (map.zoomsliderControl) {\n                this.zoomControl = map.zoomsliderControl;\n            }\n        }\n\n        // Create the loading indicator\n        var classes = 'leaflet-control-loading';\n        var container;\n        if (this.zoomControl && !this.options.separate) {\n            // If there is a zoom control, hook into the bottom of it\n            container = this.zoomControl._container;\n            // These classes are no longer used as of Leaflet 0.6\n            classes += ' leaflet-bar-part-bottom leaflet-bar-part last';\n        }\n        else {\n            // Otherwise, create a container for the indicator\n            container = DomUtil.create('div', 'leaflet-control-zoom leaflet-bar');\n        }\n        this._indicator = DomUtil.create('a', classes, container);\n        return container;\n    },\n\n    onRemove: function(map) {\n        this._removeLayerListeners(map);\n        this._removeMapListeners(map);\n    },\n\n    removeFrom: function (map) {\n        if (this.zoomControl && !this.options.separate) {\n            // Override Control.removeFrom() to avoid clobbering the entire\n            // _container, which is the same as zoomControl's\n            this._container.removeChild(this._indicator);\n            this._map = null;\n            this.onRemove(map);\n            return this;\n        }\n        else {\n            // If this control is separate from the zoomControl, call the\n            // parent method so we don't leave behind an empty container\n            return Control.prototype.remove.call(this);\n        }\n    },\n\n    addLoader: function(id) {\n        this._dataLoaders[id] = true;\n        this.updateIndicator();\n    },\n\n    removeLoader: function(id) {\n        delete this._dataLoaders[id];\n        this.updateIndicator();\n    },\n\n    updateIndicator: function() {\n        if (this.isLoading()) {\n            this._showIndicator();\n        }\n        else {\n            this._hideIndicator();\n        }\n    },\n\n    isLoading: function() {\n        return this._countLoaders() > 0;\n    },\n\n    _countLoaders: function() {\n        var size = 0, key;\n        for (key in this._dataLoaders) {\n            if (this._dataLoaders.hasOwnProperty(key)) size++;\n        }\n        return size;\n    },\n\n    _showIndicator: function() {\n        // Show loading indicator\n        DomUtil.addClass(this._indicator, 'is-loading');\n\n        // If zoomControl exists, make the zoom-out button not last\n        if (!this.options.separate) {\n            if (this.zoomControl instanceof Control.Zoom) {\n                DomUtil.removeClass(this.zoomControl._zoomOutButton, 'leaflet-bar-part-bottom');\n            }\n        }\n    },\n\n    _hideIndicator: function() {\n        // Hide loading indicator\n        DomUtil.removeClass(this._indicator, 'is-loading');\n\n        // If zoomControl exists, make the zoom-out button last\n        if (!this.options.separate) {\n            if (this.zoomControl instanceof Control.Zoom) {\n                DomUtil.addClass(this.zoomControl._zoomOutButton, 'leaflet-bar-part-bottom');\n            }\n        }\n    },\n\n    _handleLoading: function(e) {\n        this.addLoader(this.getEventId(e));\n    },\n\n    _handleLoad: function(e) {\n        this.removeLoader(this.getEventId(e));\n    },\n\n    getEventId: function(e) {\n        if (e.id) {\n            return e.id;\n        }\n        else if (e.layer) {\n            return e.layer._leaflet_id;\n        }\n        return e.target._leaflet_id;\n    },\n\n    _layerAdd: function(e) {\n        if (!e.layer || !e.layer.on) return;\n        try {\n            e.layer.on({\n                loading: this._handleLoading,\n                load: this._handleLoad\n            }, this);\n        }\n        catch (exception) {\n            console.warn('L.Control.Loading: Tried and failed to add ' +\n                         ' event handlers to layer', e.layer);\n            console.warn('L.Control.Loading: Full details', exception);\n        }\n    },\n\n    _addLayerListeners: function(map) {\n        // Add listeners for begin and end of load to any layers already on the\n        // map\n        map.eachLayer(function(layer) {\n            if (!layer.on) return;\n            layer.on({\n                loading: this._handleLoading,\n                load: this._handleLoad\n            }, this);\n        }, this);\n\n        // When a layer is added to the map, add listeners for begin and end\n        // of load\n        map.on('layeradd', this._layerAdd, this);\n    },\n\n    _removeLayerListeners: function(map) {\n        // Remove listeners for begin and end of load from all layers\n        map.eachLayer(function(layer) {\n            if (!layer.off) return;\n            layer.off({\n                loading: this._handleLoading,\n                load: this._handleLoad\n            }, this);\n        }, this);\n\n        // Remove layeradd listener from map\n        map.off('layeradd', this._layerAdd, this);\n    },\n\n    _addMapListeners: function(map) {\n        // Add listeners to the map for (custom) dataloading and dataload\n        // events, eg, for AJAX calls that affect the map but will not be\n        // reflected in the above layer events.\n        map.on({\n            dataloading: this._handleLoading,\n            dataload: this._handleLoad,\n            layerremove: this._handleLoad\n        }, this);\n    },\n\n    _removeMapListeners: function(map) {\n        map.off({\n            dataloading: this._handleLoading,\n            dataload: this._handleLoad,\n            layerremove: this._handleLoad\n        }, this);\n    }\n});\n\n\nif( (window as any).L) {\n    const L = (window as any).L;\n    L.Control.Loading = loadingControl;\n    L.Control.loading = function(options) {\n        return new L.Control.Loading(options);\n    };\n}\n\nMap.addInitHook(function () {\n    if (this.options.loadingControl) {\n        this.loadingControl = new loadingControl();\n        this.addControl(this.loadingControl);\n    }\n});\n\nexport default loadingControl;\n","\nimport {\n    Control, control,\n    Map,\n    DomUtil, DomEvent,\n    layerGroup,\n    polyline, CircleMarker, divIcon, marker,\n    PolylineOptions, CircleMarkerOptions\n} from 'leaflet';\n\n\nvar measureControl = Control.extend({\n    options: {\n        position: 'topleft'\n    },\n\n    onAdd: function (map) {\n        var className = 'leaflet-control-zoom leaflet-bar leaflet-control',\n            container = DomUtil.create('div', className);\n\n        this._createButton('&#8674;', 'Measure', 'leaflet-control-measure leaflet-bar-part leaflet-bar-part-top-and-bottom', container, this._toggleMeasure, this);\n\n        return container;\n    },\n\n    _createButton: function (html, title, className, container, fn, context) {\n        var link = DomUtil.create('a', className, container);\n        link.innerHTML = html;\n        (link as HTMLAnchorElement).href = '#';\n        link.title = title;\n\n        DomEvent\n            .on(link, 'click', DomEvent.stopPropagation)\n            .on(link, 'click', DomEvent.preventDefault)\n            .on(link, 'click', fn, context)\n            .on(link, 'dblclick', DomEvent.stopPropagation);\n\n        return link;\n    },\n\n    _toggleMeasure: function () {\n        this._measuring = !this._measuring;\n\n        if(this._measuring) {\n            DomUtil.addClass(this._container, 'leaflet-control-measure-on');\n            this._startMeasuring();\n        } else {\n            DomUtil.removeClass(this._container, 'leaflet-control-measure-on');\n            this._stopMeasuring();\n        }\n    },\n\n    _startMeasuring: function() {\n        this._oldCursor = this._map._container.style.cursor;\n        this._map._container.style.cursor = 'crosshair';\n\n        this._doubleClickZoom = this._map.doubleClickZoom.enabled();\n        this._map.doubleClickZoom.disable();\n\n        DomEvent\n            .on(this._map, 'mousemove', this._mouseMove, this)\n            .on(this._map, 'click', this._mouseClick, this)\n            .on(this._map, 'dblclick', this._finishPath, this)\n            //.on( (document as Document), 'keydown', this._onKeyDown, this);\n\n        if(!this._layerPaint) {\n            this._layerPaint = layerGroup().addTo(this._map);\n        }\n\n        if(!this._points) {\n            this._points = [];\n        }\n    },\n\n    _stopMeasuring: function() {\n        this._map._container.style.cursor = this._oldCursor;\n\n        DomEvent\n            //.off((document as Document), 'keydown', this._onKeyDown, this)\n            .off(this._map, 'mousemove', this._mouseMove, this)\n            .off(this._map, 'click', this._mouseClick, this)\n            .off(this._map, 'dblclick', this._mouseClick, this);\n\n        if(this._doubleClickZoom) {\n            this._map.doubleClickZoom.enable();\n        }\n\n        if(this._layerPaint) {\n            this._layerPaint.clearLayers();\n        }\n\n        this._restartPath();\n    },\n\n    _mouseMove: function(e) {\n        if(!e.latlng || !this._lastPoint) {\n            return;\n        }\n\n        if(!this._layerPaintPathTemp) {\n            let opts = {\n                color: 'black',\n                weight: 1.5,\n                clickable: false,\n                dashArray: '6,3'\n            } as PolylineOptions;\n            this._layerPaintPathTemp = polyline([this._lastPoint, e.latlng], opts)\n                .addTo(this._layerPaint);\n        } else {\n            this._layerPaintPathTemp.spliceLatLngs(0, 2, this._lastPoint, e.latlng);\n        }\n\n        if(this._tooltip) {\n            if(!this._distance) {\n                this._distance = 0;\n            }\n\n            this._updateTooltipPosition(e.latlng);\n\n            var distance = e.latlng.distanceTo(this._lastPoint);\n            this._updateTooltipDistance(this._distance + distance, distance);\n        }\n    },\n\n    _mouseClick: function(e) {\n        // Skip if no coordinates\n        if(!e.latlng) {\n            return;\n        }\n\n        // If we have a tooltip, update the distance and create a new tooltip, leaving the old one exactly where it is (i.e. where the user has clicked)\n        if(this._lastPoint && this._tooltip) {\n            if(!this._distance) {\n                this._distance = 0;\n            }\n\n            this._updateTooltipPosition(e.latlng);\n\n            var distance = e.latlng.distanceTo(this._lastPoint);\n            this._updateTooltipDistance(this._distance + distance, distance);\n\n            this._distance += distance;\n        }\n        this._createTooltip(e.latlng);\n\n\n        // If this is already the second click, add the location to the fix path (create one first if we don't have one)\n        if(this._lastPoint && !this._layerPaintPath) {\n            let opts = {\n                color: 'black',\n                weight: 2,\n                clickable: false\n            } as PolylineOptions;\n            this._layerPaintPath = polyline([this._lastPoint], opts).addTo(this._layerPaint);\n        }\n\n        if(this._layerPaintPath) {\n            this._layerPaintPath.addLatLng(e.latlng);\n        }\n\n        // Upate the end marker to the current location\n        if(this._lastCircle) {\n            this._layerPaint.removeLayer(this._lastCircle);\n        }\n\n        let markerOpts = {\n            color: 'black',\n            opacity: 1,\n            weight: 1,\n            fill: true,\n            fillOpacity: 1,\n            radius:2,\n            clickable: this._lastCircle ? true : false\n        } as CircleMarkerOptions;\n        this._lastCircle = new CircleMarker(e.latlng, markerOpts).addTo(this._layerPaint);\n\n        this._lastCircle.on('click', function() { this._finishPath(); }, this);\n\n        // Save current location as last location\n        this._lastPoint = e.latlng;\n    },\n\n    _finishPath: function() {\n        // Remove the last end marker as well as the last (moving tooltip)\n        if(this._lastCircle) {\n            this._layerPaint.removeLayer(this._lastCircle);\n        }\n        if(this._tooltip) {\n            this._layerPaint.removeLayer(this._tooltip);\n        }\n        if(this._layerPaint && this._layerPaintPathTemp) {\n            this._layerPaint.removeLayer(this._layerPaintPathTemp);\n        }\n\n        // Reset everything\n        this._restartPath();\n    },\n\n    _restartPath: function() {\n        this._distance = 0;\n        this._tooltip = undefined;\n        this._lastCircle = undefined;\n        this._lastPoint = undefined;\n        this._layerPaintPath = undefined;\n        this._layerPaintPathTemp = undefined;\n    },\n\n    _createTooltip: function(position) {\n        var icon = divIcon({\n            className: 'leaflet-measure-tooltip',\n            iconAnchor: [-5, -5]\n        });\n        this._tooltip = marker(position, {\n            icon: icon,\n            clickable: false\n        }).addTo(this._layerPaint);\n    },\n\n    _updateTooltipPosition: function(position) {\n        this._tooltip.setLatLng(position);\n    },\n\n    _updateTooltipDistance: function(total, difference) {\n        var totalRound = this._round(total),\n            differenceRound = this._round(difference);\n\n        var text = '<div class=\"leaflet-measure-tooltip-total\">' + totalRound + ' nm</div>';\n        if(differenceRound > 0 && totalRound != differenceRound) {\n            text += '<div class=\"leaflet-measure-tooltip-difference\">(+' + differenceRound + ' nm)</div>';\n        }\n\n        this._tooltip._icon.innerHTML = text;\n    },\n\n    _round: function(val) {\n        return Math.round((val / 1852) * 10) / 10;\n    },\n\n    _onKeyDown: function (e) {\n        if(e.keyCode == 27) {\n            // If not in path exit measuring mode, else just finish path\n            if(!this._lastPoint) {\n                this._toggleMeasure();\n            } else {\n                this._finishPath();\n            }\n        }\n    }\n});\n\n\nif( (window as any).L) {\n    const L = (window as any).L;\n    L.Control.Measure = measureControl;\n    L.control.measure = function (options) {\n        return new L.Control.Measure(options);\n    };\n}\n\nMap.mergeOptions({\n    measureControl: false\n});\n\nMap.addInitHook(function () {\n    if (this.options.measureControl) {\n        this.measureControl = new measureControl();\n        this.addControl(this.measureControl);\n    }\n});\n\n\nexport default measureControl;\n","\nimport {\n    Control, control, DomUtil, DomEvent, Util, Map\n} from 'leaflet';\n\n\nvar positionControl = Control.extend({\n  options: {\n    position: 'bottomleft',\n    separator: ' : ',\n    emptyString: 'Unavailable',\n    lngFirst: false,\n    numDigits: 6,\n    lngFormatter: undefined,\n    latFormatter: undefined,\n    prefix: \"\"\n  },\n\n  onAdd: function (map) {\n    this._container = DomUtil.create('div', 'leaflet-control-mouseposition');\n    DomEvent.disableClickPropagation(this._container);\n    map.on('mousemove', this._onMouseMove, this);\n    this._container.innerHTML=this.options.emptyString;\n    return this._container;\n  },\n\n  onRemove: function (map) {\n    map.off('mousemove', this._onMouseMove);\n  },\n\n  _onMouseMove: function (e) {\n    var lng = this.options.lngFormatter ? this.options.lngFormatter(e.latlng.lng) : Util.formatNum(e.latlng.lng, this.options.numDigits);\n    var lat = this.options.latFormatter ? this.options.latFormatter(e.latlng.lat) : Util.formatNum(e.latlng.lat, this.options.numDigits);\n    var value = this.options.lngFirst ? lng + this.options.separator + lat : lat + this.options.separator + lng;\n    var prefixAndValue = this.options.prefix + ' ' + value;\n    this._container.innerHTML = prefixAndValue;\n  }\n\n});\n\n// if( (window as any).L) {\n//     const L = (window as any).L;\n//     L.Control.MousePosition =  positionControl;\n//     L.control.mousePosition = function (options) {\n//         return new L.Control.MousePosition(options);\n//     };\n// }\n(Control as any).MousePosition =  positionControl;\n(control as any).mousePosition = function (options) {\n    return new (Control as any).MousePosition(options);\n};\n\nMap.mergeOptions({\n    positionControl: false\n});\n\nMap.addInitHook(function () {\n    if (this.options.positionControl) {\n        this.positionControl = new positionControl();\n        this.addControl(this.positionControl);\n    }\n});\n\nexport default positionControl;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","\n\nimport {\n    Map, Layer, FeatureGroup, Control, GeoJSON, popup,\n    Util, DomUtil, DomEvent, Evented, ControlOptions\n} from 'leaflet';\nimport { Draw } from 'leaflet-draw';\n// import * as L from 'leaflet';   //for Leaflet.Draw\n// const Draw = L.Draw;\n// const EditHandler = Draw.EditToolbar.Edit;\n\n\n\nimport MapInstance from '../map/instance';\n\n\n\ninterface EditControlOptions extends ControlOptions {\n    featureGroup : FeatureGroup\n}\n\ninterface FeatureLayer extends Layer {\n    feature : any;\n    geometry : any;\n    properties : {\n        [key:string]: any;\n        id : string;\n    }\n    toGeoJSON() : any;\n    setStyle( args : any );\n}\n\n\nexport default class FeatureEditor {\n\n\n    private map : MapInstance;\n    private feature : FeatureLayer;\n    private originalFeature: FeatureLayer;\n    private editingLayer : FeatureGroup;\n    private tool : EditFeature;\n    private visible : boolean;\n\n\n    constructor( map : MapInstance, feature : FeatureLayer, options ?: any ) {\n        this.map = map;\n        this.feature = feature;\n        this.visible = false;\n    }\n\n\n    /**\n     *\n     */\n    disable () {\n        this.doneEditing(false);\n        this.unregisterTool();\n    }\n\n    /**\n     *\n     */\n    unregisterTool() {\n        if(this.tool) {\n            this.tool.deactivate();\n            let map = this.map.getMap();\n            map.removeControl(this.tool);\n            map.removeLayer(this.editingLayer);\n        }\n    }\n\n    /**\n     * @param bool - flag specifying the visibility of the original feature being edited\n     */\n    showOriginalLayer(bool) {\n        if(!this.feature) return;\n        let id = this.feature.properties.id;\n        let layer = this.map.getFeatureLayer(id);\n        this.map.setFeatureVisibility(layer, bool);\n    }\n\n    /**\n     *\n     */\n    beginEditing() {\n\n        if(!this.visible) return;\n\n        this.originalFeature = GeoJSON.geometryToLayer(this.feature.toGeoJSON()) as FeatureLayer;\n        this.feature.properties._editing=true;\n\n        // get Leaflet.Map from instance\n        let map = this.map.getMap();\n\n        // find feature layer for specific feature\n        let feature = this.map.getFeatureLayer(this.feature.properties.id);\n        if(!feature) return;\n\n        //clone feature layer and wrap with FeatureGroup\n        // because Leaflet.Draw requires edited features\n        // be within a FeatureGroup\n        let editingLayer = this.editingLayer = new FeatureGroup().addTo(map);\n\n        //if the feature being edited is a multi-geometry\n        // (\"MultiPoint\", \"MultiLineString\", \"MultiPolygon\", \"GeometryCollection\")\n        // then we need to split them up into individual geometries and\n        // add them as separate layers which will all be editable\n        if (this.feature.geometry.type.indexOf(\"Multi\")===0) {\n            let type = this.feature.geometry.type.replace(\"Multi\",\"\");\n            this.feature.geometry.coordinates.each( (childCoords) => {\n                let shape = {type:type, coordinates: childCoords};\n                new GeoJSON(shape, {\n                    onEachFeature: (feature, layer) => {\n                        editingLayer.addLayer(layer);\n                    }\n                });\n            });\n\n        } else if(this.feature.geometry.type === 'GeometryCollection') {\n            this.feature.geometry.geometries.each( (childGeometry) => {\n                new GeoJSON(childGeometry, {\n                    onEachFeature:   (feature, layer) => {\n                        editingLayer.addLayer(layer);\n                    }\n                });\n            });\n\n        } else {\n            new GeoJSON(feature.toGeoJSON()).eachLayer( (layer) => {\n                editingLayer.addLayer(layer);\n            });\n        }\n\n        //make this feature invisible\n        this.showOriginalLayer(false);\n\n        //register LeafletDraw control with Edit mode only\n        // using just the feature layer identified\n        this.tool = new EditFeature({\n            featureGroup: editingLayer\n        } as ControlOptions).addTo(map);\n        this.tool.activate();\n\n    }\n\n    /**\n     * @param save - flag specifying whether to persist changes to the feature\n     */\n    doneEditing( save ?: boolean ) {\n\n        this.feature.properties._editing = false;\n\n        if(typeof(save) === 'undefined' || save) {\n\n            //if geometry changed\n            if(this.tool && this.tool.hasBeenEdited()) {\n\n                let isMulti = ~this.feature.geometry.type.indexOf(\"Multi\");\n                let isGeomColl = this.feature.geometry.type === 'GeometryCollection';\n                let geoms = [], coords = [], geometry;\n                this.editingLayer.eachLayer( (layer : Layer) => {\n                    let feature = (layer as FeatureLayer).toGeoJSON();\n                    geometry = feature.geometry;\n                    if(isMulti) {\n                        coords[coords.length] = geometry.coordinates;\n                    } else if(isGeomColl) {\n                        geoms[geoms.length] = feature;\n                    }\n                });\n\n                //update existing feature with edited information\n                if(isMulti)\n                    this.feature.geometry.coordinates = coords;\n                else if(isGeomColl)\n                    this.feature.geometry.geometries = geoms;\n                else\n                    this.feature.geometry = geometry;\n\n                //inform Map of change\n                this.map.replaceFeature(this.feature);\n\n            } else {\n                //restore original layer\n                this.showOriginalLayer(true);\n\n                //redraw feature with new style info\n                this.map.updateFeature(this.feature);\n            }\n\n        } else {\n            //restore original layer (only if feature is to be visible)\n            this.showOriginalLayer(this.visible);\n\n            //Redraw feature which has been updated with\n            // original style information (reset)\n            this.map.updateFeature(this.feature);\n        }\n\n        //lastly, break down the editing tool\n        if(this.tool) this.unregisterTool();\n\n    }\n\n    /**\n     *\n     */\n    addProperty() {\n\n    }\n\n    /**\n     *\n     */\n    highlightFeature() {\n        this.map.focusFeature(this.feature.properties.id);\n    }\n\n    /**\n     *\n     */\n    deleteFeature() {\n        this.map.removeFeature(this.feature.properties.id);\n    }\n\n    /**\n     * update rendered feature with latest info\n     */\n    updateFeature() {\n\n        //if not editing a temporary feature...\n        if(!this.editingLayer)\n            this.map.updateFeature(this.feature);\n\n        else {\n\n            //don't need to update existing rendered feature\n            // because it's been hidden and a temporary 'editing' version\n            // is on the map. So we need to update that instead.\n            // this.map.updateFeature(this.feature);\n\n\n            //update 'editing' version of the feature in question\n\n            let style = this.feature.properties.style;\n            this.editingLayer.eachLayer( (layer : Layer) => {\n                //do nothing for markers\n                if((layer as FeatureLayer).feature.geometry.type !== 'Point') {\n                    (layer as FeatureLayer).setStyle(style);\n                }\n            });\n\n        }\n\n    }\n\n    /**\n     *\n     */\n    cancelEditing () {\n        this.feature = this.originalFeature;\n        this.doneEditing(false);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n/**\n *\n */\nclass EditFeature extends Control {\n\n    private map : Map;\n    private enabled : boolean;\n    private handler : Draw.EditToolbar.Edit;\n\n    constructor( options ?: any ) {\n        super( Object.assign( {\n                position: 'bottomright',\n                draw: false,\n                edit: false\n            }, options || {})\n        );\n    }\n\n    onAdd (map : Map) {\n        this.map = map;\n        this.enabled = false;\n\n        let opts = { };\n        //needed or else L.EditToolbar.Edit fails to addHooks for PolyLine features\n        (opts as any).selectedPathOptions = {\n            dashArray: '10, 10',\n            fill: true,\n            fillColor: '#fe57a1',\n            fillOpacity: 0.1,\n            // Whether to user the existing layers color\n            maintainColor: false\n        };\n        (opts as any).featureGroup = (this.options as any).featureGroup;\n\n        this.handler = new Draw.EditToolbar.Edit(map, opts);\n\n        var container = DomUtil.create('div', 'leaflet-edit-feature');\n        return container;\n    }\n\n    onRemove (map : Map) {\n        this.deactivate();\n    }\n\n    activate() {\n        this.enabled = true;\n        this.handler.enable();\n    }\n\n    deactivate() {\n        this.enabled = false;\n        this.handler.disable();\n    }\n\n    hasBeenEdited() {\n        var result = false;\n        if((this.options as any).featureGroup) {\n            (this.options as any).featureGroup.eachLayer(function(layer) {\n                result = result || layer.edited;\n            });\n        }\n        return result;\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n// import {\n//     Map, Layer, FeatureGroup, Control, GeoJSON, popup,\n//     Util, DomUtil, DomEvent, Evented\n// } from 'leaflet';\n// import * as Editable from \"leaflet-editable\";\n//\n// import MapInstance from '../map/instance';\n//\n//\n//\n//\n//\n// const CALLBACKS = {\n//     'marker'    : 'startMarker',\n//     'line'      : 'startPolyline',\n//     'polygon'   : 'startPolygon',\n//     'rectangle' : 'startRectangle',\n//     'circle'    : 'startCircle'\n// };\n//\n//\n// export const Events = {\n//     FEATURE_CREATED: 'feature:created',\n//     FEATURE_REMOVED: 'feature:removed',\n//     FEATURE_EDITED: 'feature:edited'\n// };\n//\n//\n// export default class FeatureEditor extends Evented {\n//\n//     private map : MapInstance;\n//     private editor : Editable;\n//     private editLayer : FeatureGroup;\n//     private featuresLayer : FeatureGroup;\n//\n//     constructor(map : MapInstance, options ?: any) {\n//         super();\n//\n//         this.map = map;\n//\n//         let leafletMap : Map = map.getMap();\n//         if(!leafletMap) throw new Error(\"No Leaflet map is configured\");\n//\n//         this.featuresLayer = map.getFeatureLayer();\n//\n//         this.editLayer = new FeatureGroup();\n//         this.editLayer.addTo(leafletMap);\n//\n//         let opts : any = {};\n//         Object.assign(opts, options||{}, {\n//             //editLayer : ...\n//             featuresLayer : this.editLayer //map.getFeatureLayer()\n//             // drawingCSSClass: 'leaflet-editable-drawing',\n//             // drawingCursor: 'crosshair',\n//             // skipMiddleMarkers: true\n//         });\n//\n//         //create and register editable instance on leaflet map\n//         let editor = new Editable(leafletMap, opts);\n//         (leafletMap as any).editTools = editor;\n//         this.editor = editor;\n//\n//         this.editor.on('editable:drawing:end', (event : any) => {\n//             //have to wrap handler in a timeout in order to not inadvertently\n//             // block the clean up of event handlers within Editable\n//             setTimeout(() => { this.onFeatureCreated(event) },50);\n//         });\n//         // this.editor.on('editable:editing', (event : any) => { this.onFeatureEdited(event) })\n//\n//         this.editor.on('editable:drawing:start', (event: any) => console.log(\"Drawing Start\") );\n//         this.editor.on('editable:drawing:end', (event: any) => console.log(\"Drawing End\") );\n//         this.editor.on('editable:drawing:cancel', (event: any) => console.log(\"Drawing Cancel\") );\n//         this.editor.on('editable:drawing:commit', (event: any) => console.log(\"Drawing Commit\") );\n//\n//         this.editor.on(\n//             'editable:drawing:start editable:drawing:end ' +\n//             'editable:drawing:cancel editable:drawing:commit ' +\n//             'editable:drawing:mousedown editable:drawing:mouseup ' +\n//             'editable:drawing:click editable:drawing:move ' +\n//             'editable:drawing:clicked',\n//             (event : any) => {\n//                 console.log(\"Editor event: \" + event.type);\n//                 if(event.layer && event.layer.options.popup) {\n//                     this.updateFeaturePopup(event.layer, event.layer.options.popup);\n//                 }\n//             }\n//         );\n//\n//         this.editor.on(\n//             'editable:vertex:new editable:vertex:click ' +\n//             'editable:vertex:clicked editable:vertex:rawclick ' +\n//             'editable:vertex:deleted editable:vertex:ctrlclick ' +\n//             'editable:vertex:shiftclick editable:vertex:metakeyclick ' +\n//             'editable:vertex:altclick editable:vertex:contextmenu ' +\n//             'editable:vertex:mousedown editable:vertex:drag ' +\n//             'editable:vertex:dragstart editable:vertex:dragend ' +\n//             'editable:middlemarker:mousedown',\n//             (event : any) => {\n//                 console.log(\"Vertex event: \" + event.type);\n//                 // if(event.layer && event.layer.options.popup) {\n//                 //     this.updateFeaturePopup(event.layer, event.layer.options.popup);\n//                 // }\n//             }\n//         );\n//\n//         if(opts.marker) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.marker],\n//                 kind: 'marker',\n//                 html: opts.marker.icon ? opts.marker.icon : 'ð'\n//             }));\n//         }\n//         if(opts.line) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.line],\n//                 kind: 'line',\n//                 html: opts.line.icon ? opts.line.icon : '\\\\/\\\\'\n//             }));\n//         }\n//         if(opts.polygon) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.polygon],\n//                 kind: 'polygon',\n//                 html: opts.polygon.icon ? opts.polygon.icon : 'â°'\n//             }));\n//         }\n//         if(opts.rectangle) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.rectangle],\n//                 kind: 'rectangle',\n//                 html: opts.rectangle.icon ? opts.rectangle.icon : 'â¬'\n//             }));\n//         }\n//         if(opts.circle) {\n//             leafletMap.addControl(new EditControl({\n//                 position: opts.position || 'topleft',\n//                 callback: editor[CALLBACKS.circle],\n//                 kind: 'circle',\n//                 html: opts.circle.icon ? opts.circle.icon : 'â¬¤'\n//             }));\n//         }\n//     }\n//\n//     isDrawing() : boolean {\n//         return this.editor ? this.editor.drawing() : false;\n//     }\n//\n//     cancel() {\n//         if(this.editor) this.editor.stopDrawing();\n//     }\n//\n//     /**\n//      * @param feature Feature to be edited\n//      */\n//     enableFeatureEdit( feature : any ) {\n//         if(!feature) return;\n//\n//         if(!feature.properties) feature.properties = {};\n//\n//         let fid =  this.getFeatureId(feature, true);\n//\n//         //make a clone of the feature to be edited\n//         let json = (feature as any).toGeoJSON();\n//         let editedLayer = GeoJSON.geometryToLayer(json);\n//         Util.setOptions(editedLayer, { originalLayerId : fid });\n//\n//         //hide that feature on featuresLayer\n//         this.map.setFeatureVisibility(feature, false);\n//\n//         //and add the editble clone of it to the edit layer\n//         this.editLayer.addLayer(editedLayer);\n//         (editedLayer as any).toggleEdit();\n//     }\n//\n//     /**\n//      * @param feature Feature being edited\n//      */\n//     applyFeatureEdit( feature : any ) {\n//\n//         let editedLayer = this.findEditedFeatureLayer(feature);\n//         if(!editedLayer) return;\n//\n//         (editedLayer as any).toggleEdit();                   //turn off editor\n//\n//         let json = (editedLayer as any).toGeoJSON();\n//         this.editLayer.removeLayer(editedLayer);    //remove from edit layer\n//\n//         // let updatedLayer = GeoJSON.geometryToLayer(json);\n//         this.map.replaceFeature(json);\n//         this.map.setFeatureVisibility(feature, true);\n//\n//     }\n//\n//     /**\n//      * @param feature Feature being edited\n//      */\n//     cancelFeatureEdit( feature : any ) {\n//\n//         let editedLayer = this.findEditedFeatureLayer(feature);\n//         if(!editedLayer) return;\n//\n//         (editedLayer as any).toggleEdit();                   //turn off editor\n//         this.editLayer.removeLayer(editedLayer);    //and remove from edit layer\n//\n//         //re-show the original feature layer\n//         this.map.setFeatureVisibility(feature, true);\n//\n//     }\n//\n//     /**\n//      * @param feature Feature Layer associated with an editable feature\n//      * @return editable Feature Layer assocaited with the specified parameter Feature Layer\n//      */\n//     findEditedFeatureLayer( feature : any ) : Layer {\n//         let editedLayer : Layer = null;\n//         this.editLayer.eachLayer( (layer : any) => {\n//             let fid = this.getFeatureId(layer);\n//             if( !editedLayer && fid == layer.originalLayerId ) {\n//                 editedLayer = layer as Layer;\n//             }\n//         });\n//         return editedLayer;\n//     }\n//\n//     /**\n//      * @param feature Feature\n//      * @param createAsNeeded flag indicating whether to create an ID if feature has none\n//      * @return feature id or null\n//      */\n//     getFeatureId( feature : any , createAsNeeded ?: boolean) : string {\n//         if(!feature) return null;\n//         if(!feature.properties) feature.properties = {};\n//         let featureId = feature.properties.id || null;\n//         if(!featureId && true === createAsNeeded)\n//             featureId = feature.properties.id = Math.round(Math.random()*9999);\n//         return featureId;\n//     }\n//\n//\n//\n//\n//     onFeatureCreated(event : any) {\n//         let feature : any = event.layer;\n//\n//         if( typeof(feature.editEnabled) !== 'undefined' && feature.editEnabled() ) {\n//             feature.toggleEdit();\n//         }\n//\n//         this.editLayer.removeLayer(feature);\n//         if(this.featuresLayer) {\n//             this.featuresLayer.addLayer(feature);\n//             feature.on('dblclick', DomEvent.stop).on('dblclick', () => {\n//\n//                 (feature as any).toggleEdit();\n//\n//                 if(feature.editEnabled()) { //'editable:enable'\n//                     //add a save and cancel btn...\n//\n//                     let latLng = null;\n//                     if(typeof(feature.getLatLng) !== 'undefined') {\n//                         latLng = feature.getLatLng();\n//                     } else if(typeof(feature.getCenter()) !== 'undefined') {\n//                         latLng = feature.getCenter();\n//                     }\n//\n//                     let fp = popup({\n//                         autoClose: false,\n//                         closeButton: false,\n//                         closeOnEscapeKey: false,\n//                         closeOnClick: false\n//                     }).setLatLng(latLng)\n//                     .setContent('<button type=\"button\">Save</button> &nbsp;&nbsp;&nbsp; <button type=\"button\">Cancel</button>')\n//                     .openOn(this.map.getMap());\n//\n//                     Util.setOptions(feature, {popup : fp});\n//\n//                 } else if( feature.options.popup ) {\n//                     feature.options.popup.remove();\n//                     // feature.editor.off('editable:drawing:start,editable:drawing:end,editable:drawing:cancel,editable:drawing:commit,editable:drawing:mousedown,editable:drawing:mouseup,editable:drawing:click,editable:drawing:move,editable:drawing:clicked');\n//\n//                 }\n//             });\n//         }\n//         this.fire(Events.FEATURE_CREATED, feature);\n//     }\n//\n//     onFeatureEdited(event : any) {\n//         let feature = event.layer;\n//         this.fire(Events.FEATURE_EDITED, feature);\n//     }\n//\n//\n//     updateFeaturePopup(feature, popup) {\n//         let latLng = null;\n//         if(typeof(feature.getLatLng) !== 'undefined') {\n//             latLng = feature.getLatLng();\n//         } else if(typeof(feature.getCenter()) !== 'undefined') {\n//             latLng = feature.getCenter();\n//         }\n//         if(latLng)\n//             popup.setLatLng(latLng);\n//     }\n// }\n//\n//\n//\n//\n//\n// class EditControl extends Control {\n//\n//     constructor(options ?: any) {\n//         super(options);\n//     }\n//\n//     initialize (options ?: any) {\n// \t\tUtil.setOptions(this, options);\n//     }\n//\n//     onAdd (map : Map) {\n//         let container : HTMLElement = DomUtil.create('div', 'leaflet-control leaflet-bar'),\n//             activateBtn : HTMLAnchorElement = DomUtil.create('a', '', container) as HTMLAnchorElement;\n//\n//         activateBtn.href = '#';\n//         activateBtn.title = 'Create a new ' + (this.options as any).kind;\n//         activateBtn.innerHTML = (this.options as any).html;\n//\n//         DomEvent.on(activateBtn, 'click', DomEvent.stop)\n//         .on(activateBtn, 'click', function () {\n//             (window as any).LAYER = this.options.callback.call( (map as any).editTools );\n//         }, this);\n//\n//         return container;\n//     }\n//\n// }\n","\nimport * as Q from \"q\";\nimport {\n    ItemService, XHRHttpClient, QueryFactory, Config\n} from '@geoplatform/client';\n\n\n\nconst ogcExpr = /OGC.+\\(([A-Z\\-]+)\\)/;\nconst esriExpr = /Esri REST ([A-Za-z]+) Service/;\nconst keyFn = (expr, str) => {\n    let m = expr.exec(str);\n    return (m && m.length) ? m[1] : null;\n};\n\nvar types = {\n\n    ESRI_FEATURE_SERVER: {\n        \"id\":\"48980c5bad0c8d4666b393874eb5279a\",\n        \"uri\":\"http://www.geoplatform.gov/spec/esri-feature-rest\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"Esri ArcGIS Feature Server REST API\",\n        \"label\":\"Esri REST Feature Service\"\n    },\n\n    ESRI_IMAGE_SERVER: {\n        \"id\":\"bcdf764e52064c84323f3f1baea7e245\",\n        \"uri\":\"http://www.geoplatform.gov/spec/esri-image-rest\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"Esri ArcGIS Image Server REST API\",\n        \"label\":\"Esri REST Image Service\"\n    },\n\n    ESRI_MAP_SERVER: {\n        \"id\":\"370cf6ca5d91c07b63329b8384fe76c7\",\n        \"uri\":\"http://www.geoplatform.gov/spec/esri-map-rest\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"Esri ArcGIS Map Server REST API\",\n        \"label\":\"Esri REST Map Service\"\n    },\n\n    ESRI_TILE_SERVER: {\n        \"id\": \"c75570ff2523b1a1631afe7ddac27beb\",\n        \"uri\": \"http://www.geoplatform.gov/spec/esri-tile-rest\",\n        \"type\": \"dct:Standard\",\n        \"description\": \"Esri ArcGIS Tile Server REST API\",\n        \"label\": \"Esri REST Tile Service\"\n    },\n\n    KML: {\n        \"id\":\"c0b39ca2049ba2184472ff27408ffd7e\",\n        \"uri\":\"http://opengis.net/spec/kml\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Keyhole Markup Language (KML)\",\n        \"label\":\"OGC Keyhole Markup Language (KML)\"\n    },\n\n    CSW: {\n        \"id\":\"60de6a422475493b7901ae453d6f4562\",\n        \"uri\":\"http://opengis.net/spec/csw\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Catalog Service (CSW)\",\n        \"label\":\"OGC Web Catalog Service (CSW)\"\n    },\n\n    WCS: {\n        \"id\":\"a7e5a2d81a83d4eae9bf9138f24d0a32\",\n        \"uri\":\"http://opengis.net/spec/wcs\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Coverage Service (WCS)\",\n        \"label\":\"OGC Web Coverage Service (WCS)\"\n    },\n\n    WFS: {\n        \"id\":\"e70e43ed52f83634285a09e959734bff\",\n        \"uri\":\"http://opengis.net/spec/wfs\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Feature Service (WFS)\",\n        \"label\":\"OGC Web Feature Service (WFS)\"\n    },\n\n    WMS: {\n        \"id\":\"abed5a00c536fb2d7019092c37ed634c\",\n        \"uri\":\"http://opengis.net/spec/wms\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Map Service (WMS)\",\n        \"label\":\"OGC Web Map Service (WMS)\"\n    },\n\n    WMTS: {\n        \"id\":\"757858ae77cf8c602b39294c27632dd7\",\n        \"uri\":\"http://opengis.net/spec/wmts\",\n        \"type\":\"dct:Standard\",\n        \"description\":\"OGC Web Map Tile Service (WMTS)\",\n        \"label\":\"OGC Web Map Tile Service (WMTS)\"\n    },\n\n    WMST: {\n        \"id\": \"faae5bff49b1144d500380cbc055c1e5\",\n        \"uri\": \"http://www.geoplatform.gov/spec/ogc-wms-t\",\n        \"type\": \"dct:Standard\",\n        \"description\": \"OGC WMS support for temporal according to OGC Best Practice guidance\",\n        \"label\": \"OGC WMS-T Service\"\n    },\n\n    FEED: {\n        \"id\": \"8edc61870e534a1f23dc967753da3b72\",\n        \"uri\": \"http://www.geoplatform.gov/spec/feed\",\n        \"type\": \"dct:Standard\",\n        \"description\": \"GeoPlatform GeoJSON Feed Service converts an Atom/RSS feed (including GeoRSS and CAP extensions) to GeoJSON\",\n        \"label\": \"GeoPlatform GeoJSON Feed Service\"\n    },\n\n    //\n    //method to allow refreshing list later\n    refresh: updateList\n};\n\nfunction updateList(service : ItemService) {\n\n    let url = Config.ualUrl;\n    if(!url) {\n        console.log(\"WARN : ServiceTypes - no GeoPlatform API URL configured, unable to load service types\");\n    } else {\n\n        let query = QueryFactory()\n            .types('dct:Standard')\n            .resourceTypes('ServiceType')\n            .pageSize(50);\n\n\n        let svc = null;\n        //if a service was provided to be used, use it\n        if(service && typeof(service.search) !== 'undefined') {\n            svc = service;\n        } else { // otherwise, use defaults\n            svc = new ItemService(url, new XHRHttpClient());\n        }\n\n        svc.search(query).then( data => {\n\n            for(let i=0; i<data.results.length; ++i) {\n\n                let type = data.results[i],\n                    key = null,\n                    label = type.label;\n\n                if(~label.indexOf(\"WMS-T\")) {\n                    key = 'WMST';\n                    type.supported = true;\n\n                } else if(~label.indexOf('OGC')) {\n                    key = keyFn(ogcExpr, label);\n                    type.supported = 'WMS' === key || 'WMTS' === key;\n\n                } else if(~label.indexOf('Esri')) {\n                    key = keyFn(esriExpr, label);\n                    type.supported = true;\n                    key = 'ESRI_' + key.toUpperCase() + '_SERVER';\n\n                } else if(~label.indexOf(\"Feed\")) {\n                    key = \"FEED\";\n                    type.supported = true;\n\n                } else {\n                    key = label;\n\n                }\n\n                types[key] = type;\n            }\n            // console.log(types);\n        })\n        .catch( error => {\n            console.log(\"Error loading supported service types: \" + error.message);\n        });\n    }\n}\n\nexport default types;\n","\nimport * as Q from \"q\";\nimport {\n    QueryFactory, LayerService, XHRHttpClient, Config\n}  from '@geoplatform/client';\n\n\n/**\n * @param {LayerService} layerService - optional, GeoPlatform Layer service to use to fetch the layer\n * @return {Promise} resolving OpenStreet Map GeoPlatform Layer\n */\nexport default {\n\n    /**\n     * @param {Object} layer - GeoPlatform Layer object\n     * @return {boolean} true if is an OSM layer\n     */\n    test : function(layer) {\n        return  layer &&\n                layer.resourceTypes &&\n                layer.resourceTypes.length &&\n                ~layer.resourceTypes.indexOf(\"http://www.geoplatform.gov/ont/openlayer/OSMLayer\");\n    },\n\n    get : function(layerService ?: LayerService) : Q.Promise<any> {\n        let query = QueryFactory()\n            .fields('*')\n            .resourceTypes(\"http://www.geoplatform.gov/ont/openlayer/OSMLayer\");\n        if(!layerService)\n            layerService = new LayerService(Config.ualUrl, new XHRHttpClient());\n        return layerService.search(query)\n        .then( response => response.results.length ? response.results[0] : null)\n        .catch( e => Q.reject(e));\n    }\n\n};\n","\nimport * as Q from 'q';\nimport OSM from './osm';\nimport { Config, LayerService, XHRHttpClient } from '@geoplatform/client';\n\n\nconst WORLD_STREET_LAYER = '86a8babde086689e21248669ba4ed579';\n\nvar DefaultBaseLayer = {\n\n    get: function(layerService : LayerService) {\n        if(!layerService) {\n            layerService = new LayerService(Config.ualUrl, new XHRHttpClient());\n        }\n        let baseLayerId = Config.defaultBaseLayerId || WORLD_STREET_LAYER;\n        return layerService.get(baseLayerId)\n            .catch( (e : Error) => {\n                return OSM.get();\n            });\n    },\n\n    set: function(layer : any) {\n        let id = null;\n        if(layer && layer.id) id = layer.id;\n        else if(layer && typeof(layer) === 'string') id = layer;\n        if(id) {\n            Config.configure({'defaultBaseLayerId': layer.id});\n        }\n    }\n};\n\nexport default DefaultBaseLayer;\n","\n/* jshint ignore:start */\nimport * as MarkerCluster from 'leaflet.markercluster';\nimport \"leaflet.markercluster\";\nimport { Util, MarkerClusterGroup, GeoJSON } from 'leaflet';\nimport * as esri from \"esri-leaflet\";\n\n/* esri-leaflet-cluster - v2.0.0 - Thu Aug 18 2016 17:12:43 GMT-0700 (PDT)\n * Copyright (c) 2016 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nvar version = \"2.0.0\";\n\nvar BaseClusteredFeatureLayer = esri.FeatureManager.extend({\n\n  statics: {\n    EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose',\n    CLUSTEREVENTS: 'clusterclick clusterdblclick clustermouseover clustermouseout clustermousemove clustercontextmenu'\n  },\n\n  /**\n   * Constructor\n   */\n\n  initialize: function (options) {\n    esri.FeatureManager.prototype.initialize.call(this, options);\n\n    options = Util.setOptions(this, options);\n\n    this._layers = {};\n    this._leafletIds = {};\n\n    this.cluster = new MarkerClusterGroup(options);\n    this._key = 'c' + (Math.random() * 1e9).toString(36).replace('.', '_');\n\n    this.cluster.addEventParent(this);\n  },\n\n  /**\n   * Layer Interface\n   */\n\n  onAdd: function (map) {\n    esri.FeatureManager.prototype.onAdd.call(this, map);\n    this._map.addLayer(this.cluster);\n\n    // NOTE !!!!!!!\n    // Using this type of layer requires map.maxZoom to be set during map creation!\n    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  },\n\n  onRemove: function (map) {\n    esri.FeatureManager.prototype.onRemove.call(this, map);\n    this._map.removeLayer(this.cluster);\n  },\n\n  /**\n   * Feature Management Methods\n   */\n\n  createLayers: function (features) {\n    var markers = [];\n\n    for (var i = features.length - 1; i >= 0; i--) {\n      var geojson = features[i];\n      var layer = this._layers[geojson.id];\n\n      if (!layer) {\n        var newLayer : any = GeoJSON.geometryToLayer(geojson, this.options);\n        newLayer.feature = GeoJSON.asFeature(geojson);\n        newLayer.defaultOptions = newLayer.options;\n        newLayer._leaflet_id = this._key + '_' + geojson.id;\n\n        this.resetStyle(newLayer.feature.id);\n\n        // cache the layer\n        this._layers[newLayer.feature.id] = newLayer;\n\n        this._leafletIds[newLayer._leaflet_id] = geojson.id;\n\n        if (this.options.onEachFeature) {\n          this.options.onEachFeature(newLayer.feature, newLayer);\n        }\n\n        this.fire('createfeature', {\n          feature: newLayer.feature\n        });\n\n        // add the layer if it is within the time bounds or our layer is not time enabled\n        if (!this.options.timeField || (this.options.timeField && this._featureWithinTimeRange(geojson))) {\n          markers.push(newLayer);\n        }\n      }\n    }\n\n    if (markers.length) {\n      this.cluster.addLayers(markers);\n    }\n  },\n\n  addLayers: function (ids) {\n    var layersToAdd = [];\n    for (var i = ids.length - 1; i >= 0; i--) {\n      var layer = this._layers[ids[i]];\n      this.fire('addfeature', {\n        feature: layer.feature\n      });\n      layersToAdd.push(layer);\n    }\n    this.cluster.addLayers(layersToAdd);\n  },\n\n  removeLayers: function (ids, permanent) {\n    var layersToRemove = [];\n    for (var i = ids.length - 1; i >= 0; i--) {\n      var id = ids[i];\n      var layer = this._layers[id];\n      this.fire('removefeature', {\n        feature: layer.feature,\n        permanent: permanent\n      });\n      layersToRemove.push(layer);\n      if (this._layers[id] && permanent) {\n        delete this._layers[id];\n      }\n    }\n    this.cluster.removeLayers(layersToRemove);\n  },\n\n  /**\n   * Styling Methods\n   */\n\n  resetStyle: function (id) {\n    var layer = this._layers[id];\n\n    if (layer) {\n      layer.options = layer.defaultOptions;\n      this.setFeatureStyle(layer.feature.id, this.options.style);\n    }\n\n    return this;\n  },\n\n  setStyle: function (style) {\n    this.eachFeature(function (layer) {\n      this.setFeatureStyle(layer.feature.id, style);\n    }, this);\n    return this;\n  },\n\n  setFeatureStyle: function (id, style) {\n    var layer = this._layers[id];\n\n    if (typeof style === 'function') {\n      style = style(layer.feature);\n    }\n    if (layer.setStyle) {\n      layer.setStyle(style);\n    }\n  },\n\n  /**\n   * Utility Methods\n   */\n\n  eachFeature: function (fn, context) {\n    for (var i in this._layers) {\n      fn.call(context, this._layers[i]);\n    }\n    return this;\n  },\n\n  getFeature: function (id) {\n    return this._layers[id];\n  }\n});\n\n// function featureLayer (options) {\n//   return new FeatureLayer(options);\n// }\n//\n// export {\n//     FeatureLayer,\n//     featureLayer as default,\n//     version as VERSION\n// }\n\nexport default BaseClusteredFeatureLayer;\n","\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport * as Q from \"q\";\nimport { Config } from '@geoplatform/client';\n\n/**\n * Fetches style information from GeoPlatform UAL\n * @param  id - identifier of layer to resolve style for\n */\nfunction featureStyleResolver(id : string) : Q.Promise<{}> {\n    let deferred = Q.defer();\n    if(!jQuery) {\n        deferred.reject(new Error(\"Unable to load feature layer style, jQuery is not installed\"));\n        return deferred.promise;\n    }\n    jQuery.ajax({\n       url: Config.ualUrl + '/api/layers/' + id + '/style',\n       dataType: 'json',\n       success: function(data) {\n           deferred.resolve(data);\n       },\n       error: function(xhr, status, message) {\n           let em = `FeatureStyleResolver() -\n               Error loading style information for layer ${id} : ${message}`;\n           let error = new Error(em);\n           deferred.reject(error);\n       }\n    });\n    return deferred.promise;\n}\n\nexport default featureStyleResolver;\n","\n\nfunction featurePopupTemplate(feature) {\n\n    let props = Object.keys(feature.properties);\n\n    const pFn = function(list, names) {\n        if(!list || !list.find) return null;\n        let match = list.find( name => {\n            let lc = name.toLowerCase();\n            return names.indexOf(lc)>=0;\n        });\n        return match;\n    };\n\n    let titleProp = pFn(props, ['title','name','label']);\n    let title = titleProp ? feature.properties[titleProp] : \"Untitled\";\n\n    let descProp = pFn(props, ['description', 'summary', 'descript']);\n    let description = descProp ? feature.properties[descProp] : \"No description provided\";\n\n    let result = '<div class=\"feature-popup\">' +\n        '<h5>' + title + '</h5>' +\n        '<p>' + description + '</p>';\n\n    if(feature.properties.modified) {\n        let modified = new Date(feature.properties.modified);\n        result += '<div><span class=\"label\">Updated</span><span class=\"value\">' +\n            modified.toDateString() + '</span></div>';\n    }\n\n    if(feature.properties['cap:effective']) {\n        let date = new Date(feature.properties['cap:effective']);\n        result += '<div>' +\n            '<span class=\"label\">Effective</span>' +\n            '<span class=\"value\">' +\n            date.toDateString() + ' ' + date.toTimeString() +\n            '</span>' +\n            '</div>';\n    }\n    if(feature.properties['cap:expires']) {\n        let date = new Date(feature.properties['cap:expires']);\n        result += '<div>' +\n            '<span class=\"label\">Expires</span>' +\n            '<span class=\"value\">' +\n            date.toDateString() + ' ' + date.toTimeString() +\n            '</span>' +\n            '</div>';\n    }\n\n    let linkProp = pFn(props, ['landingpage','link','website']);\n    if(linkProp) {\n        result += '<br>';\n        result += '<a href=\"' + feature.properties[linkProp] + '\" target=\"_blank\">link</a>';\n    }\n\n    result += '<hr>';\n\n    for(let prop in feature.properties) {\n        if(titleProp === prop || descProp === prop ||\n            linkProp === prop || 'modified' === prop)\n            continue;\n        let value = feature.properties[prop];\n        if(typeof(value) === 'object') {\n            for(let p in value) {\n                result += '<div>' +\n                    '<span class=\"label\">' + prop + '.' + p + '</span>' +\n                    '<span class=\"value\">' + value[p] + '</span>' +\n                    '</div>';\n            }\n        } else {\n            result += '<div>' +\n                '<span class=\"label\">' + prop + '</span>' +\n                '<span class=\"value\">' + value + '</span>' +\n                '</div>';\n        }\n    }\n    result += '</div>';\n    return result;\n}\n\nexport default featurePopupTemplate;\n","\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport * as Q from  \"q\";\nimport { Config } from '@geoplatform/client';\n\nimport {\n    Control,\n    icon as iconFn,\n    marker as markerFn,\n    circleMarker as circleMarkerFn,\n    SVG, svg, Canvas, canvas,\n    Util,\n    Layer\n} from 'leaflet';\n\nimport BaseClusteredFeatureLayer from './base-clustered-feature-layer';\nimport featureStyleResolver from '../shared/style-resolver';\nimport featurePopupTemplate from '../shared/popup-template';\n\n\n/**\n * Clustered Feature Layer\n * Provides custom style loading and point-ilization as well\n * as adding visibility and opacity manipulation methods\n */\nvar ClusteredFeatureLayer = BaseClusteredFeatureLayer.extend({\n\n    currentVisibility: true,\n    currentOpacity: 1.0,\n\n    _gpStyle : { color: \"#00f\", weight: 2, fillColor: '#00f', fillOpacity: 0.3 },\n\n    /**\n     * @param {object} feature - GeoJSON Point Feature\n     * @param {L.LatLng} latlng\n     * @return {L.Marker}\n     */\n    pointToLayerFn: function (feature, latlng) {\n\n        var style = feature && feature.properties ? feature.properties.style : null;\n        if(!style && typeof this.options.style === 'function') {\n            // console.log(\"Using local style function\");\n            try {\n                style = this.options.style(feature);\n            } catch(e) {\n                console.log(\"error using style function in ClusteredFeatureLayer: \" + e.message);\n            }\n        }\n\n        style = style || this.options.style || {};\n        style.radius      = style['stroke-width'] || style.radius || 4;\n        style.weight      = style['stroke-width'] || style.weight || 2;\n        style.color       = style.stroke || style.color || '#03f';\n        style.opacity     = style['stroke-opacity'] || style.opacity || 0.9;\n        style.fillOpacity = style['fill-opacity'] || style.opacity || 0.3;\n        style.fillColor   = style.fill || style.color || '#03f';\n        style.renderer    = this.options.renderer;  //important for pane!\n\n        let marker = null;\n        if(style.shape === 'image') {\n            let width = style.width || 16;\n            let height = style.height || 16;\n            var icon = iconFn( {\n                iconUrl: style.content, //base64 encoded string\n                iconSize: [width, height],\n                iconAnchor: [width*0.5, height*0.5],\n                popupAnchor: [0, -11],\n            });\n            let mopts = { icon: icon };\n            if(Config.leafletPane) (mopts as any).pane = Config.leafletPane;\n            marker = markerFn( latlng, mopts);\n        } else {\n            marker = circleMarkerFn(latlng, style);\n        }\n\n        let popupTemplate = this.options.popupTemplate || featurePopupTemplate;\n        marker.bindPopup(popupTemplate(feature));\n\n        return marker;\n    },\n\n    /**\n     * for all non-point features, bind a popup\n     * @param {object} feature - GeoJSON feature\n     * @param {L.Layer} layer - layer representing feature\n     */\n    eachFeatureFn: function(feature, layer) {\n        if(!feature || !feature.geometry || feature.geometry.type === 'Point') {\n            return;\n        }\n        layer.bindPopup(featurePopupTemplate(feature));\n    },\n\n\n\n    initialize: function (options) {\n\n        var self = this;\n\n        options = options || {};\n\n        if(Config.leafletPane)\n            options.pane = Config.leafletPane;\n\n        options.pointToLayer = Util.bind(this.pointToLayerFn, this);\n        options.onEachFeature = Util.bind(this.eachFeatureFn, this);\n        // options.fields = ['FID', 'type', 'title', 'geometry'];\n\n        //Increase from 1 to increase the distance away from the center that spiderfied markers are placed.\n        // This needs to be increased to ensure all markers can be clicked\n        // when spiderfied (some get stuck under the spider legs)\n        options.spiderfyDistanceMultiplier = 2;\n\n        let getGPStyle = () => { return this._gpStyle; };\n        options.style = options.style || getGPStyle;\n        if(options.styleResolver) {\n            this.styleResolver = options.styleResolver;\n        }\n\n        //in order to put features-based layers into same pane as tile layers,\n        // must specify renderer and set desired pane on that\n        let svgOpts = { };\n        if(Config.leafletPane)\n            (svgOpts as any).pane = Config.leafletPane;\n        var renderer = (SVG && svg(svgOpts)) || (Canvas && canvas());\n        options.renderer = renderer;\n\n        BaseClusteredFeatureLayer.prototype.initialize.call(this, options);\n\n        this.on('load', function() {\n            if(typeof this.options.zIndex !== 'undefined')\n                this.setZIndex(this.options.zIndex);\n        });\n\n    },\n\n    onAdd: function(map) {\n        BaseClusteredFeatureLayer.prototype.onAdd.call(this, map);\n\n        if(this.options.layerId) {\n            this.loadStyle(this.options.layerId);\n        }\n    },\n\n    /** override super class' method to set viz/opac after sub layers created */\n    createLayers: function (features) {\n        BaseClusteredFeatureLayer.prototype.createLayers.call(this, features);\n        this.setVisibility(this.currentVisibility);\n        this.setOpacity(this.currentOpacity);\n    },\n\n    /**\n     * @param {integer} index\n     */\n    setZIndex : function (index) {\n        this.options.zIndex = index;\n        for(var id in this._layers) {\n\n            let lyr = this._layers[id];\n            if(lyr.setZIndex)\n                lyr.setZIndex(index);\n            else if(lyr._updateZIndex)\n                lyr._updateZIndex(index);\n            else if(lyr._renderer && lyr._renderer._container){\n                lyr._renderer._container.style.zIndex = index;\n            } else {\n                // console.log(\"Clustered feature layer child \" + id + \" does not support ordering using z-index\");\n            }\n        }\n    },\n\n    /** */\n    toggleVisibility: function() {\n\n        this.currentVisibility = !this.currentVisibility;\n        this.setVisibility(this.currentVisibility);\n\n        // //clustered features\n        // if(this.cluster && this.cluster._featureGroup && this.cluster._featureGroup._layers) {\n        //     for(let id in this.cluster._featureGroup._layers) {\n        //         let layer = this.cluster._featureGroup._layers[id];\n        //         if(layer._icon) {\n        //             jQuery(layer._icon).toggleClass('invisible');\n        //         }\n        //     }\n        // }\n        //\n        // //non-clustered features\n        // if(this._layers) {\n        //     for(let id in this._layers)\n        //         this._layers[id].toggleVisibility();\n        // }\n    },\n\n    /**\n     * @param {boolean} bool - flag\n     */\n    setVisibility: function(bool) {\n\n        this.currentVisibility = !!bool;\n\n        //clustered features\n        if(this.cluster && this.cluster._featureGroup && this.cluster._featureGroup._layers) {\n            for(let id in this.cluster._featureGroup._layers) {\n                let layer = this.cluster._featureGroup._layers[id];\n                if(layer._icon) {\n                    //probably is a more efficient way to do this,\n                    // but this works currently.\n                    // TODO look at using\n                    //  markerCluster.refreshIconOptions({className:'invisible'});\n                    var icon = jQuery(layer._icon);\n                    if(bool) icon.removeClass('invisible');\n                    else icon.addClass('invisible');\n                }\n            }\n        }\n\n        //non-clustered features\n        if(this._layers) {\n            for(let id in this._layers) {\n                let layer = this._layers[id];\n                if(layer.setVisibility)\n                    layer.setVisibility(bool);\n                else if(layer.setStyle)\n                    layer.setStyle({display: bool ? '':'none'});\n            }\n        }\n    },\n\n    /**\n     * @param {number} opacity\n     */\n    setOpacity: function(opacity) {\n\n        this.currentOpacity = isNaN(opacity) ? 1.0 : opacity*1;\n\n        //clustered features\n        if(this.cluster && this.cluster._featureGroup && this.cluster._featureGroup._layers) {\n            for(let id in this.cluster._featureGroup._layers) {\n                let layer = this.cluster._featureGroup._layers[id];\n                if(layer._icon) {\n                    jQuery(layer._icon).css({opacity: opacity});\n                }\n            }\n        }\n\n        //non-clustered features\n        if(this._layers) {\n            for(let id in this._layers) {\n                let layer = this._layers[id];\n                if(layer.setOpacity)\n                    layer.setOpacity(opacity);\n            }\n        }\n    },\n\n    setStyle: function(style) {\n        this.eachFeature(function (layer) {\n            this.setFeatureStyle(layer.feature.id, style);\n        }, this);\n    },\n\n    loadStyle: function(gpLayerId) {\n\n        if(this.options.styleLoader) {\n            this.options.styleLoader(gpLayerId)\n            .then( json => {\n\n                if(!json) return;\n\n                let style = null;\n\n                if(json && json.styles) {\n\n                    let featureFn = function(feature) {\n\n                        let property = this.property || this.field1;\n                        let v = feature[property] || (feature.properties ? feature.properties[property] : null);\n                        let style = null;\n                        if(this.styles) {\n                            let wrapper = this.styles.find( sw => sw.value === v );\n                            if(wrapper) {\n                                style = wrapper.style;\n                                style.radius = style['stroke-width'] || style.radius || 4;\n                                style.weight = style['stroke-width'] || style.weight || 2;\n                                style.color = style.stroke || style.color || '#03f';\n                                style.opacity = style['stroke-opacity'] || style.opacity || 0.9;\n                                style.fillOpacity = style['fill-opacity'] || style.opacity || 0.3;\n                                style.fillColor = style.fill || style.color || '#03f';\n                            } else {\n                                console.log(\"No matching style for \" + JSON.stringify(feature.properties));\n                            }\n                        }\n                        // console.log(\"Using style: \" + JSON.stringify(style));\n                        return style;\n                    };\n                    let styleFn = () => { return featureFn(json); };\n                    this.options.style = styleFn;\n                    setTimeout( (layer, style) => { layer.setStyle(style); }, 1000, this, styleFn);\n                    return;\n\n                } else if(json && typeof(json.push) !== 'undefined') {\n                    //multiple styles returned\n                    style = json[0];  //use first for now\n\n                } else if(json) {\n                    style = json;\n\n                } else {\n                    return; //unrecognizable style\n                }\n\n                if(style.shape) {\n                    var obj = jQuery.extend({}, style);\n                    obj.style = style;\n                    this._gpStyle = style;\n\n                    //setStyle on Cluster.FeatureLayer doesn't appear to work consistently for\n                    // non-clustered features.\n                    // this.setStyle(obj);\n                    //So instead, we manually set it on all features of the layer (that aren't clustered)\n                    for(let id in this._layers)\n                        this._layers[id].setStyle(obj);\n\n                }\n            })\n            .catch( e => {\n                console.log(\"Error fetching feature layer style\");\n                console.log(e);\n            });\n        }\n    }\n});\n\n\n\n\n/**\n * @param layer - GeoPlatform Layer object\n * @param options - optional properties\n * @return leaflet layer instance or null\n */\nfunction clusteredFeatures(layer, options) : Layer {\n\n    let service = layer.services && layer.services.length ?\n        layer.services[0] : null;\n    if(!service) {\n        let msg = `clusteredFeatures() -\n                  Cannot create leaflet layer for GP Layer:\n                  layer has no service`;\n        throw new Error(msg);\n    }\n\n    let url     = service.href,\n        format  = layer.supportedFormats ? layer.supportedFormats[0] : null;\n\n    let styleResolver = options && options.styleResolver ?\n        options.styleResolver : featureStyleResolver;\n\n    let opts = {\n        url: url + '/' + layer.layerName,\n        styleLoader: styleResolver,\n        layerId: layer.id\n    };\n\n    if(Config.leafletPane) (opts as any).pane = Config.leafletPane;\n    if(options && options.leafletPane) (opts as any).pane = options.leafletPane;\n\n    return new ClusteredFeatureLayer(opts);\n}\n\n\n\n/**\n * @param  layer - GeoPlatform Layer object\n * @param  options - optional properties\n * @return leaflet layer instance or null\n */\nfunction geoJsonFeed(layer, options) : Layer {\n\n    let service = layer.services && layer.services.length ?\n        layer.services[0] : null;\n    if(!service) {\n        let msg = `geoJsonFeed() -\n                  Cannot create leaflet layer for GP Layer:\n                  layer has no service`;\n        throw new Error(msg);\n    }\n\n    let url     = service.href,\n        format  = layer.supportedFormats ? layer.supportedFormats[0] : null;\n\n    let layerUrl = url + (url[url.length-1]==='/'?'':'/') +\n        layer.id + '/FeatureServer/' + layer.layerName;\n\n    let styleUrl = url.replace('feeds','styles') +\n        (url[url.length-1]==='/'?'':'/') + layer.id;\n\n    let styleLoaderFactory = function(url) {\n        return function (layerId) {\n            let deferred = Q.defer();\n            if(!jQuery) {\n                deferred.reject(new Error(\"Unable to load GeoJSON feed style, jQuery is not installed\"));\n                return deferred.promise;\n            }\n            jQuery.ajax(url, {\n                dataType:'json',\n                success: function(data) {\n                    deferred.resolve(data);\n                },\n                error: function(xhr, status, message) {\n                    let em = `geoJsonFeed() -\n                        Error loading style information for layer ${layerId} : ${message}`;\n                    let error = new Error(em);\n                    deferred.reject(error);\n                }\n            });\n            return deferred.promise;          //uses jQuery promise\n        };\n    };\n\n    let opts = {\n        url: layerUrl,\n        isModern: true,         //force to use GeoJSON\n        layerId: layer.id,    //used by style loader\n        styleLoader: styleLoaderFactory(styleUrl)\n    };\n\n    if(Config.leafletPane) (opts as any).pane = Config.leafletPane;\n    if(options && options.leafletPane) (opts as any).pane = options.leafletPane;\n\n    return new ClusteredFeatureLayer(opts);\n\n}\n\n\nexport {\n    ClusteredFeatureLayer as default,\n    ClusteredFeatureLayer,\n    clusteredFeatures,\n    geoJsonFeed\n};\n","\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport * as Q from \"q\";\nimport { Map, TileLayer, tileLayer, LatLng, Util, popup } from 'leaflet';\n\nimport {Config} from '@geoplatform/client';\n\n\n\nclass WMS extends TileLayer.WMS {\n\n    private _enabled : boolean = false;\n\n    constructor(url : string, opts ?: any) {\n        super(url, opts);\n        this._enabled = false;\n    }\n\n    enableGetFeatureInfo  () {\n        this._map.on('click', this.getFeatureInfo, this);\n        this._enabled = true;\n    }\n\n    disableGetFeatureInfo () {\n        this._map.off('click', this.getFeatureInfo, this);\n        this._enabled = false;\n    }\n\n    isGetFeatureInfoEnabled () {\n        return this._enabled;\n    }\n\n    onRemove (map : Map) : this {\n\n        //if GFI is enabled, disable it before removing\n        if(this.isGetFeatureInfoEnabled())\n        this.disableGetFeatureInfo();\n\n        // Triggered when the layer is removed from a map.\n        //   Unregister a click listener, then do all the upstream WMS things\n        return super.onRemove.call(this, map);\n\n    }\n\n    getFeatureInfo  (evt) {\n        // Make an AJAX request to the server and hope for the best\n        var url = this.getFeatureInfoUrl(evt.latlng),\n        parseGetFeatureInfo = this.parseGetFeatureInfo;\n        jQuery.ajax({\n            url: url,\n            success  (data, status, xhr) {\n                // var err = typeof data === 'string' ? null : data;\n                if(typeof(data) !== 'string')\n                data = parseGetFeatureInfo(data);\n                () => {\n                    this.showGetFeatureInfo(null, evt.latlng, data);\n                }\n            },\n            error  (xhr, status, error) {\n                () => { this.showGetFeatureInfo(error); }\n            }\n        });\n    }\n\n    getFeatureInfoUrl  (latlng : LatLng) {\n        // Construct a GetFeatureInfo request URL given a point\n        var point = this._map.latLngToContainerPoint(latlng),\n        size = this._map.getSize(),\n\n        params = {\n            srs: 'EPSG:4326',\n            bbox: this._map.getBounds().toBBoxString(),\n            height: size.y,\n            width: size.x,\n            // layers: this.wmsParams.layers,\n            // query_layers: this.wmsParams.layers,\n            info_format: 'text/xml',\n            x: point.x,\n            y: point.y,\n            i: point.x, //1.3.0\n            j: point.y  //1.3.0\n        };\n\n        let wmvId = (this.wmsParams as any).wmvId;\n\n        // return this._url + Util.getParamString(params, this._url, true);\n        var url = '/api/layers/' + wmvId + '/feature';\n        return Config.ualUrl + url + Util.getParamString(params, url, true);\n    }\n\n    parseGetFeatureInfo (content) {\n        var fields = [];\n        for(var field in content) {\n            fields.push(['<div><strong>', field, ': </strong>', content[field], '</div>'].join(' '));\n        }\n        if(fields.length == 0)\n        fields.push('<em>No data available</em>');\n        return '<div>' + fields.join(' ') + '</div>';\n    }\n\n    showGetFeatureInfo  (err : Error, latlng : LatLng, content: any) {\n        if (err) { console.log(err); return; } // do nothing if there's an error\n\n        // Otherwise show the content in a popup, or something.\n        popup({ maxWidth: 800})\n        .setLatLng(latlng)\n        .setContent(content)\n        .openOn(this._map);\n    }\n\n}\n\n\nfunction wms(layer) {\n\n    let service = layer.services && layer.services.length ?\n        layer.services[0] : null;\n    if(!service) {\n        let msg = `wms() -\n                  Cannot create leaflet layer for GP Layer:\n                  layer has no service`;\n        throw new Error(msg);\n    }\n\n    let url = service.href;\n    let formats = layer.supportedFormats || [];\n    let format  = formats.length ? formats[0] : \"image/png\";\n\n    if(!url) {\n        throw new Error(\"WMS layer's service does not defined a service url\");\n    }\n\n    let version = '1.1.1';\n    if(service.api && service.api.length) {\n        let is130 = service.api.filter(api => api.accessURL.indexOf('wms/1.3.0')>0 ).length > 0;\n        if(is130) version = '1.3.0';\n    }\n\n    let opts = {\n        layers: layer.layerName,\n        transparent: true,\n        format: format,\n        wmvId: layer.id,\n        version: version\n    };\n    if(Config.leafletPane)\n        (opts as any).pane = Config.leafletPane;\n\n    return new WMS(url, opts);\n\n}\n\nif( (window as any).L ) {\n    const L = (window as any).L;\n    L.TileLayer.WMS = WMS;\n    L.tileLayer.wms = wms;\n}\n\nexport {\n    WMS as default,\n    WMS,\n    wms\n};\n","\n\nimport * as Q from \"q\";\n\nimport * as L from 'leaflet';\nimport { TileLayer, tileLayer } from 'leaflet';\nimport 'leaflet-timedimension/dist/leaflet.timedimension.src';\n// import { TimeDimension, timeDimension } from \"../libs/L.TimeDimension\";\n\nimport {Config} from '@geoplatform/client';\n\nimport WMS from './wms';\n\n\n\nclass WMST extends (L as any).TimeDimension.Layer.WMS {\n\n    private _baseLayer : TileLayer.WMS\n\n    constructor(layer : TileLayer.WMS, opts ?: any) {\n        super(layer, opts);\n    }\n\n    //override default parser to query all Layers (whether queryable or not)\n    _parseTimeDimensionFromCapabilities (xml) {\n        var layers = xml.querySelectorAll('Layer');\n        var layerName = this._baseLayer.wmsParams.layers;\n        var layer = null;\n        var times = null;\n\n        layers.forEach(function(current) {\n            if (current.querySelector(\"Name\").innerHTML === layerName) {\n                layer = current;\n            }\n        });\n        if (layer) {\n            times = this._getTimesFromLayerCapabilities(layer);\n            if (!times) {\n                times = this._getTimesFromLayerCapabilities(layer.parentNode);\n            }\n        }\n\n        return times;\n    }\n\n    //override default parser to fall back if Dimension is provided but has no values\n    _getTimesFromLayerCapabilities (layer) {\n        var times = null;\n        var dimensions = layer.querySelectorAll(\"Dimension[name='time']\");\n        if (dimensions && dimensions.length && dimensions[0].textContent.length) {\n            times = dimensions[0].textContent.trim();\n        }\n        if(!times || !times.length) {\n            var extents = layer.querySelectorAll(\"Extent[name='time']\");\n            if (extents && extents.length && extents[0].textContent.length) {\n                times = extents[0].textContent.trim();\n            }\n        }\n        if(times && ~times.indexOf(\"current\")) {\n            times = times.replace('current', new Date().toISOString());\n        }\n        return times;\n    }\n\n}\n\n\n\n\nfunction wmst(gpLayer) {\n\n    let service = gpLayer.services[0];\n    let url = service.href;\n\n    if(!url) {\n        throw new Error(\"WMST Layer's service does not defined a service url\");\n    }\n\n    let opts = {\n        layers: gpLayer.layerName,\n        transparent: true,\n        format: \"image/png\",\n        wmvId: gpLayer.layerId\n    };\n    if(Config.leafletPane)\n        (opts as any).pane = Config.leafletPane;\n\n    let leafletLayer = new WMS( url, opts );\n\n    let proxyUrl = Config.ualUrl + '/api/services/' +\n        service.id + '/proxy/capabilities';\n\n    let tdOpts = { times : null };\n\n    if(gpLayer.temporal) {\n\n        let d1 = gpLayer.temporal.startDate ?\n            new Date(gpLayer.temporal.startDate) : new Date();\n        let d2 = gpLayer.temporal.endDate ?\n            new Date(gpLayer.temporal.endDate) : new Date();\n\n        tdOpts.times = d1.toISOString() + '/' + d2.toISOString() + '/P1D';\n    }\n\n    return new WMST(leafletLayer, {\n        timeDimension: new (L as any).TimeDimension(tdOpts),\n        proxy: proxyUrl\n    });\n}\n\nif( (window as any).L ) {\n    const L = (window as any).L;\n    L.TileLayer.WMST = WMST;\n    L.tileLayer.wmst = wmst;\n}\n\nexport {\n    WMST as default,\n    WMST,\n    wmst\n};\n","\n\nimport * as Q from \"q\";\nimport {\n    Map, TileLayer, tileLayer, Browser,\n    Point, Util, LatLng\n} from 'leaflet';\n\nimport { Config } from '@geoplatform/client';\n\n\n\n\nconst paramRe = /\\{ *([\\w_-]+) *\\}/g;\n\n// @function template(str: String, data: Object): String\n// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`\n// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string\n// `('Hello foo, bar')`. You can also specify functions instead of strings for\n// data values â they will be evaluated passing `data` as an argument.\nfunction template(str, data) {\n\treturn str.replace(paramRe, function (str, key) {\n\t\tvar value = data[key];\n        if (value === undefined) {\n            value = data[key.toLowerCase()];\n        }\n        if (value === undefined) {\n        \tthrow new Error('No value provided for variable ' + str);\n\t\t} else if (typeof value === 'function') {\n\t\t\tvalue = value(data);\n\t\t}\n\t\treturn value;\n\t});\n}\n\n\n/*\n * inspired by and uses code from https://github.com/mylen/leaflet.TileLayer.WMTS\n */\nclass WMTS extends TileLayer {\n\n    private _url: string;\n    private _crs: any;\n    private matrixIds : any;\n    private wmtsParams : any;\n\n    private defaultWmtsParams: any;\n\n    constructor(url : string, options ?: any) {\n        super(url, options);\n    }\n\n    initialize (url, options) { // (String, Object)\n        this._url = url;\n        this.defaultWmtsParams = {\n            service: 'WMTS',\n            request: 'GetTile',\n            version: '1.0.0',\n            layers: '',\n            styles: '',\n            tileMatrixSet: '',\n            format: 'image/png'\n        };\n        var wmtsParams = Util.extend({}, this.defaultWmtsParams);\n        var tileSize = options.tileSize || this.options.tileSize;\n        if (options.detectRetina && Browser.retina) {\n            wmtsParams.width = wmtsParams.height = tileSize * 2;\n        } else {\n            wmtsParams.width = wmtsParams.height = tileSize;\n        }\n        for (var i in options) {\n            // all keys that are not TileLayer options go to WMTS params\n            if (!this.options.hasOwnProperty(i) && i!=\"matrixIds\") {\n                wmtsParams[i] = options[i];\n            }\n        }\n        this.wmtsParams = wmtsParams;\n        this.matrixIds = options.matrixIds||this.getDefaultMatrix();\n        Util.setOptions(this, options);\n    }\n\n    onAdd ( map: Map ) : this {\n        this._crs = (this.options as any).crs || (map.options as any).crs;\n        return super.onAdd(map);\n    }\n\n    getTileUrl (coords : Point) : string { // (Point, Number) -> String\n        var tileSize = this.options.tileSize as number;\n        var nwPoint = coords.multiplyBy(tileSize);\n        nwPoint.x+=1;\n        nwPoint.y-=1;\n        var sePoint = nwPoint.add( new Point(tileSize, tileSize) );\n        var zoom = this._tileZoom;\n        var nw = this._crs.project(this._map.unproject(nwPoint, zoom));\n        var se = this._crs.project(this._map.unproject(sePoint, zoom));\n        var tilewidth = se.x-nw.x;\n        //zoom = this._map.getZoom();\n        var ident = this.matrixIds[zoom].identifier;\n        var tileMatrix = this.wmtsParams.tileMatrixSet + \":\" + ident;\n        var X0 = this.matrixIds[zoom].topLeftCorner.lng;\n        var Y0 = this.matrixIds[zoom].topLeftCorner.lat;\n        var tilecol=Math.floor((nw.x-X0)/tilewidth);\n        var tilerow=-Math.floor((nw.y-Y0)/tilewidth);\n\n\n        let url = this._url;\n        let isTileMatrixTemplated = url.indexOf('{TileMatrix}');\n        let isTileRowTemplated = url.indexOf('{TileRow}');\n        let isTileColTemplated = url.indexOf('{TileCol}');\n\n        let o = Object.assign({s: this._getSubdomain(coords)}, this.wmtsParams);\n        if(isTileMatrixTemplated>0) o.TileMatrix = ident;\n        if(isTileRowTemplated>0) o.TileRow = tilerow;\n        if(isTileColTemplated>0) o.TileCol = tilecol;\n        for(let k in o) {\n            o[k.toLowerCase()] = o[k];\n        }\n        // url = Util.template(url.toLowerCase(), o);\n        url = template(url, o);\n\n        let qsi = url.indexOf(\"?\");\n        if(qsi<0 || (isTileMatrixTemplated<qsi && isTileRowTemplated<qsi || isTileColTemplated<qsi)) {\n            //if the TM,TR,TC variables are templated but not as querystring parameters\n            // (ie, no '?' present or those params are before the '?'),\n            // then the URL must not be OGC WMTS, so no need for WMTS parameters\n\n        } else {\n            url = url + Util.getParamString(this.wmtsParams, url);\n            if(isTileMatrixTemplated<0)\n                url += \"&TileMatrix=\" + ident; //tileMatrixSet\n            if(isTileRowTemplated<0)\n                url += \"&TileRow=\" + tilerow;\n            if(isTileColTemplated<0)\n                url += \"&TileCol=\" + tilecol;\n        }\n\n        return url;\n    }\n\n    setParams (params, noRedraw) {\n        Util.extend(this.wmtsParams, params);\n        if (!noRedraw) {\n            this.redraw();\n        }\n        return this;\n    }\n\n    getDefaultMatrix  () {\n        /**\n         * the matrix3857 represents the projection\n         * for in the IGN WMTS for the google coordinates.\n         */\n        var matrixIds3857 = new Array(22);\n        for (var i= 0; i<22; i++) {\n            matrixIds3857[i]= {\n                identifier    : \"\" + i,\n                topLeftCorner : new LatLng(20037508.3428,-20037508.3428)\n            };\n        }\n        return matrixIds3857;\n    }\n\n    _getSubdomain (tilePoint : Point) : string {\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n\t\treturn this.options.subdomains[index];\n\t}\n\n}\n\n\n\n\nfunction wmts(layer) {\n\n    let url = layer.services && layer.services.length ? layer.services[0].href : null;\n\n    let options = {\n        layer: layer.layerName,\n        style: 'default',\n        tileMatrixSet: \"default\",\n        format: \"image/png\"\n    };\n    if(Config.leafletPane)\n        (options as any).pane = Config.leafletPane;\n\n    let distro = (layer.distributions || []).find( dist => {\n        //ensure dist isn't 'null'\n        return dist && dist.href && ( dist.mediaType==='image/png' || dist.mediaType==='image/jpeg' );\n    });\n    if(distro) {\n        url = distro.href;\n        options.format = distro.mediaType;\n\n        let params = distro.parameters || [];\n        params.forEach( param => {\n\n            //ignore wmts specific parameters, WMTS layer will populate those values\n            // based upon map state.\n            let plc = param.name.toLowerCase();\n            if(\"tilematrix\" === plc || \"tilerow\" === plc || \"tilecol\" === plc)\n                return;\n\n            //for all other parameters, try to fill in default or initial values\n            let value = param.defaultValue || param.values && param.values.length && param.values[0];\n            if(value !== null && value !== undefined) {\n                url = url.replace('{' + param.name + '}', value);\n            }\n        });\n    } else {\n        throw new Error(\"WTMS Layer - layer \" + layer.id +\n            \" has no distribution(s) usable to make WMTS requests\");\n    }\n\n    if(!url) throw new Error(\"Unable to determine WMTS URL for layer \" + layer.id +\n        \". Please make sure it is defined by either the service or a distribution on the layer itself.\");\n\n    return new WMTS( url, options );\n\n}\n\n\nif((window as any).L) {\n    const L = (window as any).L;\n    L.TileLayer.WMTS = WMTS;\n    L.tileLayer.wmts = wmts;\n}\n\nexport {\n    WMTS as default,\n    WMTS,\n    wmts\n};\n","\nimport * as Q from \"q\";\nimport { Map, TileLayer, tileLayer, Point, Coords, Browser, Util } from 'leaflet';\n\nimport {Config} from '@geoplatform/client';\n\n\nclass EsriTileLayer extends TileLayer {\n\n    private _url : string;\n    private _crs : any;\n    private esriParams : any;\n    private defaultESRIParams : any;\n\n    constructor(url, options) {\n        super(url, options);\n    }\n\n    initialize (url, options) { // (String, Object)\n\n        if(!url) throw new Error(\"Layer was not configured with a URL\");\n\n        this.defaultESRIParams = {\n            layers:       '', //=show:0,1,2\n            transparent:  true,\n            format:       'png32',\n            f:            'image'\n            // srs:          '4326',\n            // bboxsr:       '4326',\n            // bbox:         null,\n            // size:         '256,256',\n            // imagesr:      '4326'\n        };\n\n        if(url.indexOf(\"/export\") < 0) {\n            let qidx = url.indexOf(\"?\");\n            if(qidx > 0) {\n                url = url.substring(0, qidx) + '/export' + url.substring(qidx);\n            } else {\n                url += '/export';\n            }\n        }\n        this._url = url;\n\n        let esriParams : any = Util.extend({}, this.defaultESRIParams),\n            tileSize = options.tileSize || this.options.tileSize;\n\n        let dim;\n        if (options.detectRetina && Browser.retina) {\n            dim = esriParams.height = tileSize * 2;\n        } else {\n            dim = esriParams.height = tileSize;\n        }\n        esriParams.size = dim + ',' + dim;\n\n        for (var i in options) {\n            // all keys that are not TileLayer options go to WMS params\n            if (!this.options.hasOwnProperty(i) && i !== 'crs') {\n                esriParams[i] = options[i];\n            }\n        }\n\n        //layer ids\n        // esriParams.layers = \"show:\" + esriParams.layers;\n\n        this.esriParams = esriParams;\n\n        Util.setOptions(this, options);\n\n    }\n\n    onAdd (map : Map) : this {\n        this._crs = (this.options as any).crs || (map.options as any).crs;\n        this.esriParams.srs = this.esriParams.imagesr = this.esriParams.bboxsr = this._crs.code;\n        return super.onAdd(map);\n    }\n\n    getTileUrl (tilePoint : Coords ) : string { // (Point, Number) -> String\n\n        let map = this._map,\n            tileSize = this.options.tileSize as number,\n\n        nwPoint = tilePoint.multiplyBy(tileSize),\n        sePoint = nwPoint.add([tileSize, tileSize]),\n\n        nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\n        se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\n        bbox = [nw.x, se.y, se.x, nw.y].join(','),\n\n        url = Util.template(this._url, {s: this._getSubdomain(tilePoint)});\n\n        let params = Util.extend({}, this.esriParams);\n        params.layers = \"show:\" + params.layers;\n\n        //convert to esri-special SR for spherical mercator\n        if(params.bboxsr === 'EPSG:3857')\n            params.bboxsr = '102100';\n        if(params.imagesr === 'EPSG:3857')\n            params.imagesr = '102100';\n\n        return url + Util.getParamString(params, url, true) + '&BBOX=' + bbox;\n    }\n\n    setParams (params, noRedraw) {\n        Util.extend(this.esriParams, params);\n        if (!noRedraw) {\n            this.redraw();\n        }\n        return this;\n    }\n\n    _getSubdomain (tilePoint : Point) : string {\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\n\t\treturn this.options.subdomains[index];\n\t}\n}\n\nif((window as any).L) {\n    const L = (window as any).L;\n    L.TileLayer.ESRI = EsriTileLayer;\n    L.tileLayer.esri = function (url, options) {\n        return new L.TileLayer.ESRI(url, options);\n    };\n}\n\nexport default EsriTileLayer;\n","\nimport { TileLayer } from 'leaflet';\n\n\n/**\n * @param layer - GeoPlatform Layer\n * @return\n */\nfunction OSMLayerFactory() : TileLayer {\n\n    return new TileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n        minZoom: 1, maxZoom: 19,\n        attribution: 'Map data (c) <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors'\n    });\n}\n\nexport default OSMLayerFactory;\n","\nimport * as Q from \"q\";\n\nimport { Layer } from \"leaflet\";\nimport * as esri from \"esri-leaflet\";\nimport ServiceTypes from \"../service/types\";\nimport OSM from \"./osm\";\nimport FeatureLayer from './feature';\nimport {\n    ClusteredFeatureLayer,\n    clusteredFeatures,\n    geoJsonFeed\n} from './cluster-feature';\n\nimport {WMS, wms} from './wms';\nimport {WMST, wmst} from './wmst';\nimport {WMTS, wmts} from './wmts';\nimport ESRITileLayer from './esri-tile-layer';\nimport OSMLayerFactory from './osm-factory';\nimport { Config, ItemTypes, LayerService, XHRHttpClient } from '@geoplatform/client';\n\ninterface LayerOptions {\n    layers ?: string|string[],\n    transparent ?: boolean,\n    format ?: string,\n    pane ?: string,\n    srs ?: string,\n    url ?: string,\n    useCors ?: boolean\n};\n\n\n\n\n/*\n * Extend base Leaflet layer class to ensure there's always a function\n * available for modifying zindex and opacity, even if nothing actually\n * happens inside.\n */\nLayer.include({\n\n    // Redefining a method\n    setZIndex: function(value : number) {\n        //do nothing in this abstract class, let impls do the work\n    },\n\n    setOpacity: function(value : number) {\n        //do nothing in this abstract class, let impls do the work\n    }\n\n});\n\n\n\n\n/**\n * Fetches style information from GeoPlatform UAL\n * @param id - identifier of layer to resolve style for\n */\nfunction styleResolverFactory(service ?: LayerService) : any {\n\n    if(!service || typeof(service.style) !== 'function') {\n        throw new Error(\"Must provide a LayerService instance\");\n    }\n\n    return function featureStyleResolver(id) {\n        return service.style(id).catch(e => {\n            let msg = `Error loading style information for layer ${id} : ${e.message}`;\n            return Q.reject( new Error(msg) );\n        });\n    };\n}\n\n\n\n\n\n\n\n\n/**\n * Layer Factory\n *\n * Used to instantiate GeoPlatform Layer objects as Leaflet layer instances\n * capable of being rendered on Leaflet maps.\n *\n * Usage:\n *      let leafletLayer = LayerFactory.create(gpLayerObj);\n *\n *\n * Basic layer support is built in, but additional layer types can be supported\n * by registering new factory methods.\n *\n * Example:\n *      LayerFactory.register( (gpLayerObj) => {\n *          let isSupported = false;\n *          //implement test to verify supported layer type\n *          // ...\n *          if(isSupported) {\n *              return new MyCustomLayerClass(gpLayerObj);\n *          }\n *          return null;\n *      });\n *\n */\nclass LayerFactory {\n\n    private factories : Function[];\n    private service : LayerService;\n\n    constructor() {\n        this.factories = [];    // A list of configured factory functors to instantiate layers\n        this.init();\n    }\n\n    register(fn : Function) {\n        if(typeof(fn) === 'function') {\n            this.factories.push(fn);\n        }\n    }\n\n    setLayerService(service : LayerService) {\n        this.service = service;\n    }\n\n    /**\n     */\n    getStyleResolver() : Function {\n        if(!this.service || typeof(this.service.style) === 'undefined') {\n            this.service = new LayerService(Config.ualUrl, new XHRHttpClient());\n        }\n        return styleResolverFactory(this.service);\n    }\n\n    /**\n     * @param layer - GP Layer object\n     * @return leaflet layer instance or null\n     */\n    create(layer : any) : Layer {\n        if(!layer) {\n            throw new Error(\"LayerFactory expects a layer object\");\n        }\n        for(let i=0; i<this.factories.length; ++i) {\n            let fn = this.factories[i];\n            let result = fn && typeof(fn)==='function' && fn(layer);\n            if(result) return result;\n        }\n        return null;\n    }\n\n\n    init () {\n\n        //OSM factory\n        this.register((layer : any)=> {\n            if(layer && layer.resourceTypes &&\n                layer.resourceTypes.length &&\n                ~layer.resourceTypes.indexOf(\"http://www.geoplatform.gov/ont/openlayer/OSMLayer\")) {\n                return OSMLayerFactory();\n            }\n        });\n\n        // ESRI factory\n        this.register( (layer : any) => {\n            if(!layer || !layer.services || !layer.services.length) return null;\n            let service = layer.services[0],\n                url     = service.href,\n                typeUri = service.serviceType ? service.serviceType.uri : null,\n                srs     = layer.supportedCRS ? layer.supportedCRS[0] : null,\n                format  = layer.supportedFormats ? layer.supportedFormats[0] : null,\n                opts : LayerOptions;\n\n            function checkUrl(url) {\n                if(!url) throw new Error(\"Layer's service does not define a service url\");\n            }\n\n            if(ServiceTypes.ESRI_MAP_SERVER &&\n                ServiceTypes.ESRI_MAP_SERVER.uri === typeUri) {\n                checkUrl(url);\n                opts = {\n                    layers: layer.layerName,\n                    transparent: true,\n                    format: format || \"png32\"\n                } as LayerOptions;\n                if(srs) opts.srs = srs;\n                if(Config.leafletPane)\n                    opts.pane = Config.leafletPane;\n                return new ESRITileLayer(url, opts);\n\n            } else if(ServiceTypes.ESRI_FEATURE_SERVER &&\n                ServiceTypes.ESRI_FEATURE_SERVER.uri === typeUri) {\n                checkUrl(url);\n                return clusteredFeatures(layer, {\n                    styleResolver: this.getStyleResolver()\n                });\n\n            } else if(ServiceTypes.ESRI_TILE_SERVER &&\n                ServiceTypes.ESRI_TILE_SERVER.uri === typeUri) {\n                checkUrl(url);\n                opts = { url: url, useCors: true };\n                if(Config.leafletPane)\n                    opts.pane = Config.leafletPane;\n                return esri.tiledMapLayer(opts);\n\n            } else if(ServiceTypes.ESRI_IMAGE_SERVER &&\n                ServiceTypes.ESRI_IMAGE_SERVER.uri === typeUri) {\n                opts = { url: url, useCors: true };\n                if(Config.leafletPane)\n                    opts.pane = Config.leafletPane;\n                return esri.imageMapLayer(opts);\n\n            }\n            return null;\n        });\n\n        // OGC factory\n        this.register( (layer : any) => {\n            if(!layer || !layer.services || !layer.services.length) return null;\n            let service = layer.services[0],\n                typeUri = service.serviceType ? service.serviceType.uri : null;\n            if(ServiceTypes.WMS && ServiceTypes.WMS.uri === typeUri) {\n                return wms(layer);\n            } else if(ServiceTypes.WMST && ServiceTypes.WMST.uri === typeUri) {\n                return wmst(layer);\n            } else if(ServiceTypes.WMTS && ServiceTypes.WMTS.uri === typeUri) {\n                return wmts(layer);\n            }\n            return null;\n        });\n\n\n        this.register( (layer : any) => {\n            if(!layer || !layer.services || !layer.services.length) return null;\n            let service = layer.services[0],\n                typeUri = service.serviceType ? service.serviceType.uri : null;\n            if(ServiceTypes.FEED && ServiceTypes.FEED.uri === typeUri) {\n                return geoJsonFeed(layer, {\n                    styleResolver: this.getStyleResolver()\n                });\n            }\n            return null;\n        });\n\n\n\n    }\n}\n\nexport default new LayerFactory();\n","\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport * as Q from \"q\";\n\nimport {\n    icon as iconFn, marker as markerFn, circleMarker as circleMarkerFn,\n    SVG, svg, Canvas, canvas,\n    Util\n} from 'leaflet';\n\nimport * as esri from \"esri-leaflet\";\nvar EsriFeatureLayer = esri.FeatureLayer;\n\nimport { Config } from \"@geoplatform/client\";\nimport featurePopupTemplate from '../shared/popup-template';\n\n/**\n * Feature Layer\n * Provides custom style loading and point-ilization as well\n * as adding visibility and opacity manipulation methods\n */\nvar FeatureLayer = EsriFeatureLayer.extend({\n\n    _gpStyle : { color: \"#00f\", weight: 2, fillColor: '#00f', fillOpacity: 0.3 },\n\n    /**\n     * @param {object} feature - GeoJSON Point Feature\n     * @param {L.LatLng} latlng\n     * @return {L.Marker}\n     */\n    pointToLayerFn: function (feature, latlng) {\n\n        // console.log(\"Feature: \" + feature.id);\n\n        var style = feature && feature.properties ? feature.properties.style : null;\n        if(!style && typeof this.options.style === 'function') {\n            // console.log(\"Using local style function\");\n            try {\n                style = this.options.style(feature);\n            } catch(e) {\n                console.log(\"error using style function in ClusteredFeatureLayer: \" + e.message);\n            }\n        }\n\n        style = style || this.options.style || {};\n\n        let marker = null;\n        if(style.shape === 'image') {\n            let width = style.width || 16;\n            let height = style.height || 16;\n            var icon = iconFn( {\n                iconUrl: style.content, //base64 encoded string\n                iconSize: [width, height],\n                iconAnchor: [width*0.5, height*0.5],\n                popupAnchor: [0, -11],\n            });\n            let mopts = { icon: icon };\n            if(Config.leafletPane) (mopts as any).pane = Config.leafletPane;\n            marker = markerFn( latlng, mopts);\n\n        } else {\n            style.radius = style.radius || style['stroke-width'] || 4;\n            style.weight = style.weight || style['stroke-width'] || 2;\n            style.color = style.color || style.stroke || '#03f';\n            style.opacity = style.opacity || style['stroke-opacity'] || 0.9;\n            style.fillOpacity = style.opacity || style['fill-opacity'] || 0.3;\n            style.fillColor = style.color || style.fill;\n            style.renderer = this.options.renderer;  //important for pane!\n            marker = circleMarkerFn(latlng, style);\n        }\n\n        let popupTemplate = this.options.popupTemplate || featurePopupTemplate;\n        marker.bindPopup(popupTemplate(feature));\n        return marker;\n    },\n\n    /**\n     * for all non-point features, bind a popup\n     * @param {object} feature - GeoJSON feature\n     * @param {L.Layer} layer - layer representing feature\n     */\n    eachFeatureFn: function(feature, layer) {\n        if(!feature || !feature.geometry || feature.geometry.type === 'Point') {\n            return;\n        }\n        layer.bindPopup(featurePopupTemplate(feature));\n    },\n\n\n\n    initialize: function (options) {\n\n        var self = this;\n        options = options || {};\n\n        if(Config.leafletPane)\n            options.pane = Config.leafletPane;\n\n        let getGPStyle = () => { return this._gpStyle; };\n        options.style = options.style || getGPStyle();\n\n        //in order to put features-based layers into same pane as tile layers,\n        // must specify renderer and set desired pane on that\n        let svgOpts = { };\n        if(Config.leafletPane)\n            (svgOpts as any).pane = Config.leafletPane;\n        var renderer = (SVG && svg(svgOpts)) || (Canvas && canvas());\n        options.renderer = renderer;\n\n        options.pointToLayer = Util.bind(this.pointToLayerFn, this);\n        options.onEachFeature = Util.bind(this.eachFeatureFn, this);\n\n        // options.fields = ['FID', 'type', 'title', 'geometry'];\n\n        FeatureLayer.prototype.initialize.call(this, options);\n\n        this.on('load', function() {\n            if(typeof this.options.zIndex !== 'undefined')\n                this.setZIndex(this.options.zIndex);\n        });\n\n    },\n\n    setZIndex : function (index) {\n        this.options.zIndex = index;\n        for(var id in this._layers)\n            this._layers[id].setZIndex(index);\n    },\n\n    toggleVisibility: function() {\n        for(var id in this._layers) {\n            let layer = this._layers[id];\n            if(layer.toggleVisibility)\n                this._layers[id].toggleVisibility();\n        }\n    },\n\n    setOpacity: function(opacity) {\n        for(var id in this._layers) {\n            let layer = this._layers[id];\n            if(layer.setOpacity)\n                layer.setOpacity(opacity);\n        }\n    },\n\n    loadStyle: function(gpLayerId) {\n        var self = this;\n\n        if(this.options.styleLoader) {\n            this.options.styleLoader(gpLayerId)\n            .then( json => {\n\n                if(!json) return;\n\n                let style = null;\n\n                if(json && json.styles) {\n\n                    let featureFn = function(feature : any) : any {\n\n                        let property = this.property || this.field1;\n                        let v = feature[property] || (feature.properties ? feature.properties[property] : null);\n                        let style = null;\n                        if(this.styles) {\n                            let wrapper = this.styles.find( sw => sw.value === v );\n                            if(wrapper) {\n                                style = wrapper.style;\n                                style.radius = style.radius || style['stroke-width'] || 4;\n                                style.weight = style.weight || style['stroke-width'] || 2;\n                                style.color = style.color   || style.stroke || '#03f';\n                                style.opacity = style.opacity || style['stroke-opacity'] || 0.9;\n                                style.fillOpacity = style.opacity || style['fill-opacity'] || 0.3;\n                                style.fillColor = style.color || style.fill;\n                            }\n                        }\n                        // console.log(\"Using style: \" + JSON.stringify(style));\n                        return style;\n                    }\n\n                    let styleFn = () => { return featureFn(json); }\n                    this.options.style = styleFn;\n                    this.setStyle(styleFn);\n                    return;\n\n                } else if(json && typeof(json.push) !== 'undefined') {\n                    //multiple styles returned\n                    style = json[0];  //use first for now\n\n                } else if(json) {\n                    style = json;\n\n                } else {\n                    return; //unrecognizable style\n                }\n\n                if(style.shape) {\n                    var obj = jQuery.extend({}, style);\n                    obj.style = style;\n                    this._gpStyle = style;\n\n                    //setStyle on Cluster.FeatureLayer doesn't appear to work consistently for\n                    // non-clustered features.\n                    // this.setStyle(obj);\n                    //So instead, we manually set it on all features of the layer (that aren't clustered)\n                    for(let id in this._layers)\n                        this._layers[id].setStyle(obj);\n\n                }\n            })\n            .catch( e => {\n                console.log(\"Error fetching feature layer style\");\n                console.log(e);\n            });\n        }\n    }\n\n});\n\nexport default FeatureLayer;\n","\n\nimport * as jquery from \"jquery\";\nconst jQuery = jquery;\n\nimport * as Q from \"q\";\nimport * as geojson from 'geojson';\nimport {\n    Map, Layer, LatLng, LatLngBounds,\n    circleMarker, geoJSON,\n    featureGroup, FeatureGroup, LayerGroup\n} from 'leaflet';\n\nimport {\n    Config, ItemTypes,\n    ServiceFactory, ItemService, MapService, LayerService,\n    XHRHttpClient\n} from '@geoplatform/client';\n\nimport LayerFactory from '../layer/factory';\nimport OSM from \"../layer/osm\";\nimport DefaultBaseLayer from '../layer/baselayer-default';\n\n\nclass Listener {\n\n    _listeners : any;\n\n    constructor() {\n        //listeners to be unregistered upon destroy\n        this._listeners = {};\n    }\n\n    on (type, listener) {\n        if(!this._listeners[type])\n            this._listeners[type] = [];\n        this._listeners[type].push(listener);\n    }\n\n    off (type, listener) {\n        if(!type) this._listeners = {};\n        if(!this._listeners[type]) return;\n        if(!listener) this._listeners[type] = [];\n        else {\n            var idx = this._listeners[type].indexOf(listener);\n            if(idx >= 0)\n                this._listeners[type].splice(idx, 1);\n        }\n    }\n\n    notify(type, ...options) {\n        if(!this._listeners[type]) return;\n        var args = Array.prototype.slice.call(arguments, 1);\n        this._listeners[type].forEach(function(l) { l.apply(null, args); });\n    }\n\n}\n\n\n\nexport default class MapInstance extends Listener {\n\n    private svcCache        : any;\n    private serviceFactory  : any;\n    private httpClient      : any;\n    public _key            : string;\n    private _mapId          : string;\n    private _mapDef         : any;\n    private _mapInstance    : Map;\n    private _defaultExtent  : any;\n    private _baseLayerDef   : any;\n    private _baseLayer      : Layer;\n    private _layerStates    : any;\n    private _layerCache     : any;\n    private _layerErrors    : any[];\n    private _layerErrorHandler : Function;\n    private _featureLayer   : FeatureGroup;\n    private _featureLayerVisible  : boolean;\n    private _tools          : any[];\n    private state           : any;\n    private _geoJsonLayerOpts : any;\n\n\n\n\n    constructor(key) {\n        super();\n\n        this.setHttpClient(new XHRHttpClient());\n        this.setServiceFactory(ServiceFactory);\n\n        //generate random key (see factory below)\n        this._key = key || Math.ceil(Math.random()*9999);\n\n        //registry id of current map if available\n        this._mapId = null,\n\n        //definition of map (ie, from server)\n        this._mapDef = this.initializeMapDefinition(),\n\n        //primary map instance (ie, leaflet)\n        this._mapInstance = null,\n\n        //default map extent (if map doesn't have one for being saved)\n        this._defaultExtent = null,\n\n        //current base layer object and leaflet instance\n        this._baseLayerDef = null,\n        this._baseLayer = null,\n\n        //set definitions of layer states (including layer info) on map\n        this._layerStates = [],\n\n        //map layer def ids with leaflet instances\n        this._layerCache = {},\n\n        //errors generated by layers loading\n        this._layerErrors= [],\n        this._layerErrorHandler = function(e) {\n            console.log(`MapInstance.defaultLayerErrorHandler() - ${e.id} : ${e.message}`);\n        },\n\n        //layer used to store features on map\n        this._featureLayer = null,\n        this._featureLayerVisible = true,\n\n        //set of registered map tools\n        this._tools = [],\n\n        //state management\n        this.state = { dirty: false }; // jshint ignore:line\n\n        this._geoJsonLayerOpts  = {\n            style: function(feature) {\n                if(feature.properties.style)\n                    return feature.properties.style;\n            },\n            onEachFeature: function(feature, layer) {\n\n                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };\n                if(~feature.geometry.type.indexOf('Point')) {\n                    style.fillOpacity = 0.9;\n                }\n\n                var props = feature.properties = feature.properties || {};\n                if(feature.properties.id === undefined || feature.properties.id === null)\n                    feature.properties.id = Math.floor(Math.random()*999999);\n                feature.properties.label = props.label || props.title || props.name || \"Untitled \" + feature.geometry.type + \" Feature\";\n                feature.properties.description = props.description || props.desc || \"This feature needs a description!\";\n                feature.properties.style = props.style || style;\n\n                layer.bindTooltip(props.label);\n                /*\n                toggle: setLabelNoHide(bool)\n                it may only exist on markers!\n                */\n            },\n            pointToLayer: function (feature : any, latlng : LatLng ) {\n                var style = feature.properties.style || {};\n                style.radius = style.radius || 4;\n                style.weight = style.weight || 2;\n                style.color = style.color || '#03f';\n                style.opacity = style.opacity || 0.9;\n                style.fillOpacity = style.opacity;\n                style.fillColor = style.color;\n                return circleMarker(latlng, style);\n            }\n        };\n    }\n\n    dispose () {\n        this.destroyMap();\n        this.svcCache = null;\n        this.serviceFactory = null;\n        this.httpClient = null;\n        this._key = null;\n        this._mapId = null;\n        this._mapDef = null;\n        this._mapInstance = null;\n        this._defaultExtent = null;\n        this._baseLayerDef = null;\n        this._baseLayer = null;\n        this._layerStates = null;\n        this._layerCache = null;\n        this._layerErrors= null;\n        this._featureLayer = null;\n        this._featureLayerVisible = true;\n        this._tools = null;\n        this.state = null;\n        this._geoJsonLayerOpts = null;\n    }\n\n\n    getKey () {\n        return this._key;\n    }\n\n    /**\n     * Override default (JQuery-based) map service used by this instance\n     * @param mapService - service to use to CRUD map objects\n     * @deprecated use setServiceFactory instead\n     */\n    setService(mapService : MapService) {\n        // this.mapService = mapService;\n    }\n\n    /**\n     * @param factory - GeoPlatform ServiceFactory to instantiate services for maps and layers\n     */\n    setServiceFactory(factory : any) {\n        this.svcCache = {}; //wipe out cached services\n        this.serviceFactory = factory;\n    }\n\n    /**\n     * @param httpClient - HttpClient impl to use with the new factory\n     */\n    setHttpClient(httpClient : any) {\n        this.svcCache = {}; //wipe out cached services\n        this.httpClient = httpClient;\n    }\n\n    /**\n     * @param type - GeoPlatform Object model type to support (\"Map\", \"Layer\", etc)\n     * @return item service implementation for the requested type\n     */\n    getService(type : string) : ItemService {\n        if(!this.svcCache[type])\n            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);\n        return this.svcCache[type];\n    }\n\n    /**\n     * @param fn - callback when an error is encountered\n     */\n    setErrorHandler(fn) {\n        this._layerErrorHandler = fn;\n    }\n\n\n    //-----------------\n    getLayerStateIndex (layerId) {\n        if(!layerId) return -1;\n        for(let i=0; i<this._layerStates.length; ++i) {\n            if(this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {\n                return i;\n            }\n        }\n        return -1;\n        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );\n    }\n\n    getLayerState (layerId) {\n        let index = this.getLayerStateIndex(layerId);\n        return index >= 0 ? this._layerStates[index] : null;\n    }\n    //-----------------\n\n\n    initializeMapDefinition() {\n        return {\n            type: ItemTypes.MAP,\n            title: \"My New Map\",\n            label: \"My New Map\",\n            description: \"This map needs a description\",\n            createdBy: null,\n            baseLayer: this._baseLayerDef,\n            layers: [],\n            keywords: [],\n            themes: [],\n            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']\n        };\n    }\n\n    /**\n     * @param metadata object\n     * @return object definition of the current map suitable for sending to WMVR\n     */\n    getMapResourceContent(metadata ?: any) {\n\n        metadata = metadata || {};\n\n        //map layers\n        metadata.layers = this._layerStates.slice(0);\n        // ... UAL should support accepting just an id here, so we'll do just that\n        metadata.baseLayer = this._baseLayerDef;\n\n        metadata.annotations = this._featureLayer ?\n            { title: \"Map Features\", geoJSON: this._featureLayer.toGeoJSON() } : null;\n\n        //geographic extent\n        let extent = this._mapInstance.getBounds();\n        metadata.extent = {\n            minx: extent.getWest(),\n            miny: extent.getSouth(),\n            maxx: extent.getEast(),\n            maxy: extent.getNorth()\n        };\n\n        return metadata;\n    }\n\n    /**\n     * @return Leaflet toolbar\n     */\n    getDrawControlToolbar() {\n        if(!(this._mapInstance as any).drawControl) return null;\n        var toolbars = (this._mapInstance as any).drawControl._toolbars;\n        var toolbar = null;\n        for(var key in toolbars) {\n            if(toolbars.hasOwnProperty(key)) {\n                if(toolbars[key]._modes) {\n                    toolbar = toolbars[key];\n                    break;\n                }\n            }\n        }\n        return toolbar;\n    }\n\n    /**\n     * @param error Leaflet tile load error (.target is layer, .tile is image)\n     */\n    handleLayerError(error) {\n        // console.log(\"MapInstance.handleLayerError() - \" +\n        //     \"Layer's tile failed to load: \" + error.tile.src);\n        if(!this._layerCache) {\n            console.log(\"Unable to find layer in layer cache. Layer error is \" + error);\n            return;\n        }\n        var layer = error.target;\n        for(var id in this._layerCache) {\n            if(this._layerCache[id] === layer) {\n                this.processLayerError(error, id);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Given a Leaflet tile load error and the responsible layer id,\n     * Try to isolate the cause of the error using the proxy\n     * and notify listeners that an error has occurred\n     */\n    processLayerError(error : Error, id : string) {\n\n        var finder = (l) => { return l.id === id || (l.layer && l.layer.id === id); };\n\n        if(!this._layerErrors.find(finder)) {\n\n            let obj = this.logLayerError(id, \"Layer ('\" + id + \"') failed to completely load. \" +\n                \"It may be inaccessible or misconfigured.\");\n\n            var url = (error as any).tile.src;\n            var params = {id:id};\n            url.substring(url.indexOf(\"?\")+1, url.length).split('&').forEach(function(param) {\n                var p = param.split('=');\n                params[p[0]] = p[1];\n            });\n\n            let layerService = this.getService(ItemTypes.LAYER) as LayerService;\n            if(layerService) {\n                layerService.validate(id, params)\n                .catch(e => {\n                    var def = this._layerStates.find(finder);\n                    if(def) {\n                        obj.message = \"Layer '\" + def.layer.label + \"' failed to completely load. \" +\n                                \"Reported cause: \" + e.message;\n                    }\n                    this.notify('layer:error', obj);\n                });\n            }\n        }\n    }\n\n    /**\n     * @param layerId - identifier of layer generating the error\n     * @param errorMsg - message of the error\n     */\n    logLayerError(layerId, errorMsg) {\n        // console.log(\"MapInstance.logLayerError() - layer \"  + id +\n        //     \" generated error '\" + errorMsg + \"'\");\n        let err = { id: layerId, message: errorMsg };\n        this._layerErrors.push(err);\n        if(this._layerErrorHandler) {\n            this._layerErrorHandler(err);\n        }\n        return err;\n    }\n\n    /* -- State Management of internal model -- */\n\n    touch (event ?: any, ...options) {\n        this.state.dirty = true;\n        if(event) {\n            if(arguments.length > 1) {\n                this.notify.apply(this, Array.prototype.slice.call(arguments));\n            } else\n                this.notify(event);\n            // console.log(\"Dirtying map for \" + event);\n        }\n        // else console.log(\"Dirtying map\");\n    }\n    clean() {\n        // console.log(\"Cleaning map\");\n        this.state.dirty = false;\n    }\n    /* --------------------------------------- */\n\n\n\n\n    /* ==============================================\n        Map manipulation operations\n       ============================================== */\n\n    setMap (map : Map) { this._mapInstance = map; }\n\n    /**\n     * @return  map instance\n     */\n    getMap () : Map { return this._mapInstance; }\n\n    /** @return definition of map */\n    getMapDefinition () : any { return this._mapDef; }\n\n    /** @return identifier of map */\n    getMapId () : string { return this._mapId; }\n\n    /**\n     * Focuses the map on the specified lat/lng coordinate\n     * @param lat number\n     * @param lng number\n     * @param zoom number (optional)\n     */\n    setView (lat : number, lng : number, zoom ?: number) {\n        let z = zoom;\n        if(typeof(z) === 'undefined')\n            z = this._mapInstance.getZoom();\n        this._mapInstance.setView([lat,lng], z);\n        this.touch('map:view:changed');\n    }\n\n    /**\n     * Retrieve the current center of the map\n     * @return [lat,lng]\n     */\n    getView () : number[] {\n        var latLng = this._mapInstance.getCenter();\n        return [latLng.lat, latLng.lng];\n    }\n\n    /**\n     * @return integer current zoom level of the map\n     */\n    getZoom () : number {\n        return this._mapInstance.getZoom();\n    }\n\n    /**\n     * Zoom to the map's default extent\n     * If the map is saved, this will be the saved viewport\n     * otherwise, it will be CONUS\n     */\n    zoomToDefault () {\n        if(!this._mapInstance) return;\n        if(this._defaultExtent) {\n            this._mapInstance.fitBounds([\n                [this._defaultExtent.miny, this._defaultExtent.minx],\n                [this._defaultExtent.maxy, this._defaultExtent.maxx]\n            ]);\n        } else {\n            console.log(\"MapInstance.zoomToDefault() - No default extent specified\");\n            this._mapInstance.setView([38, -96], 5);\n        }\n        try {\n            this.touch('map:view:changed');\n        } catch(e) { }\n    }\n\n    /**\n     * @param extent - either a GP extent object or Leaflet LatLngBounds object\n     */\n    setExtent(extent : LatLngBounds|any) {\n        if(!extent) return;\n        if( typeof(extent.minx) !== 'undefined' &&\n            typeof(extent.miny) !== 'undefined' &&\n            typeof(extent.maxx) !== 'undefined' &&\n            typeof(extent.maxy) !== 'undefined' ) {\n            //GP model extent\n            this._mapInstance.fitBounds([\n                [extent.miny, extent.minx],\n                [extent.maxy, extent.maxx]\n            ]);\n        } else if(typeof(extent.getWest) !== 'undefined') {\n            //L.LatLngBounds\n            this._mapInstance.fitBounds(extent);\n        } else {\n\n        }\n    }\n\n\n    /* ==============================================\n        Layer operations\n       ============================================== */\n\n\n    /**\n     * @param layer Leaflet Layer instance or object definition\n     */\n    setBaseLayer (layer : any) {\n\n        let promise = null;\n        if(!layer) {\n            let svc = this.getService(ItemTypes.LAYER) as LayerService;\n            promise = DefaultBaseLayer.get(svc);\n        } else\n            promise = Q.resolve(layer);\n\n        promise.then( layer => {\n\n            let leafletLayer = LayerFactory.create(layer);\n            if(!leafletLayer) {\n                console.log(\"Warning: MapInstance could not create base \" +\n                    \"layer for '\" + layer.id + \"'\");\n                return;\n            }\n\n            this._mapInstance.addLayer(leafletLayer);\n\n            (leafletLayer as any).setZIndex(0);  //set at bottom\n\n            let oldBaseLayer = this._baseLayer;\n            if(oldBaseLayer) {\n                this._mapInstance.removeLayer(oldBaseLayer);\n            }\n\n            //remember new base layer\n            this._baseLayer = leafletLayer;\n            this._baseLayerDef = layer;\n\n            //will notify listeners\n            this.touch('baselayer:changed', layer, leafletLayer);\n            // this.notify('baselayer:changed', layer, leafletLayer);\n\n        })\n        .catch(e => {\n            console.log(`MapInstance.setBaseLayer() - Error getting base layer for map : ${e.message}`);\n            this.logLayerError( layer.id, \"Error setting baselayer on map \" +\n                \"because of the following error(s): \" + e.message );\n        });\n    }\n\n    /**\n     * @return array of base layers definitions that can be used\n     */\n    // getBaseLayerOptions () {\n    //     return this._baseLayerOptions;\n    // },\n\n    getBaseLayer () : any { return this._baseLayerDef; }\n\n    /**\n     * @return list of layer states containing layer information\n     */\n    getLayers () : any[] { return this._layerStates; }\n\n    getLayerErrors () : any[] { return this._layerErrors; }\n\n    clearLayerErrors () {\n        this._layerErrors = [];\n        this.notify('layer:error');\n    }\n\n    clearOverlays () {\n        if(!this._layerCache) return;\n        for(var i=this._layerStates.length-1; i>=0; --i) {\n            var state = this._layerStates[i];\n            var layerInstance = this._layerCache[state.layer.id];\n            if(layerInstance) {\n                layerInstance.off(\"layer:error\");\n                this._layerCache[state.layer.id] = null;\n                this._mapInstance.removeLayer(layerInstance);\n            }\n        }\n        this._layerStates = [];\n        this.touch('layers:changed');\n\n        //TODO stop listening for layer events\n    }\n\n    /**\n     * @param layers - list of layers (NOTE: not wrapped by layer states, this method applies that)\n     */\n    addLayers (layers : any|any[] ) {\n        if(!this._layerCache) {\n            console.log(\"WARN: attempting to add layers to an empty cache\");\n            return;\n        }\n\n        if(!this._layerCache) {\n            console.log(\"WARN: Attempting to add layers to a map with no layer cache\");\n            return;\n        }\n\n        if(!layers) return;\n        if(typeof(layers.push) === 'undefined') {\n            layers = [layers];\n        }\n\n        layers.forEach( (obj,index) => {\n\n            let layer = null, state = null;\n\n            if(obj.type && obj.type===ItemTypes.LAYER) { //is a layer\n                layer = obj;\n            } else if(obj.layer) {  //is layer state\n                layer = obj.layer;  // containing a layer\n                state = obj;\n            }\n\n            if(!layer) {\n                console.log(\"MapInstance.addLayers() - layer (\" + index +\n                    \") is not a Layer or a Layer state. Ignoring...\");\n                return;  //layer info is missing, skip it\n            }\n\n            //DT-442 prevent adding layer that already exists on map\n            if(this._layerCache[layer.id]) return;\n\n            if(!state) {\n                try {\n                    //wrapped in try{}catch because layer may contain circular reference\n                    // which will cause error when used by JSON methods\n                    let layerCopy = JSON.parse(JSON.stringify(layer));\n                    state = {\n                        opacity: 1,\n                        visibility: true,\n                        layer: layerCopy\n                    };\n                } catch(e) {\n                    throw new Error(\"Unable to add layer to map because of \" + e.message);\n                }\n            }\n\n            let z = layers.length - index;\n            state.zIndex = z;\n\n            this.addLayerWithState(layer, state);\n\n        });\n\n        this.touch('layers:changed');\n    }\n\n    /**\n     * @param layer - GeoPlatform Layer instance\n     * @param state - GeoPlatform Layer State\n     */\n    addLayerWithState(layer, state) {\n\n        var leafletLayer = null;\n        try {\n            if(!layer || !state)\n                throw new Error(\"Invalid argument, missing layer and or state\");\n\n            leafletLayer = LayerFactory.create(layer);\n            if(!leafletLayer) {\n                throw new Error(\"Could not create leaflet layer for GP Layer '\" +\n                    layer.id + \"'\");\n            }\n\n        } catch(e) {\n            this.logLayerError( layer.id,\n                \"Layer '\" + layer.label + \"' could not be added to the \" +\n                \"map instance; \" + e.message);\n        }\n\n        if(!leafletLayer) return;\n\n        //cache leaflet object first\n        if(this._layerCache) this._layerCache[layer.id] = leafletLayer;\n\n        //listen for layer errors so we can inform the user\n        // that a layer hasn't been loaded in a useful way\n        leafletLayer.on('tileerror', (e) => { this.handleLayerError(e); });\n\n        this._mapInstance.addLayer(leafletLayer);\n\n        if( !isNaN(state.zIndex) && leafletLayer.setZIndex )\n            leafletLayer.setZIndex(state.zIndex);\n\n        this._layerStates.push(state);\n\n        this.notify('layer:added', layer, leafletLayer);\n\n\n        // if layer is initially \"off\" or...\n        // if layer is initially not 100% opaque\n        if(!state.visibility || state.opacity < 1) {\n            // initialize layer visibility and opacity async, or else\n            // some of the layers won't get properly initialized\n            setTimeout( (layer, state) => {\n                this.setLayerVisibility(layer, state.visibility);\n                this.setLayerOpacity(layer, state.opacity);\n                //TODO notify of change\n\n                //DT-2102 timeout needs to be large enough or else\n                // feature layers won't get opacity updated on map load\n            }, 2000, leafletLayer, state);\n        }\n    }\n\n    /**\n     * @param from - position of layer being moved\n     * @param to - desired position to move layer to\n     */\n    moveLayer (from : number, to : number) {\n        if(!this._layerCache) return;\n\n        if(!this._layerCache) return;\n\n        if(isNaN(from)) return;\n\n        //end of list\n        if(isNaN(to)) to = this._layerStates.length-1;\n\n        let copy = this._layerStates.splice(from, 1)[0];    //grab layer being moved\n        this._layerStates.splice(to, 0, copy);\n\n        for(let z=1, i=this._layerStates.length-1; i>=0; --i,++z) {\n            let layerState = this._layerStates[i];\n            let layerInstance = this._layerCache[ layerState.layer.id ];\n            if(layerInstance) {\n                layerInstance.setZIndex(z);\n                layerState.zIndex = z;\n            }\n        }\n\n        this.touch('layers:changed', this.getLayers());\n    }\n\n    /**\n     *\n     */\n    removeLayer (id) {\n\n        if(!this._layerCache) return;\n        var layerInstance = this._layerCache[id];\n        if(layerInstance) {\n\n            //remove layer from tracked defs array\n            let index = this.getLayerStateIndex(id);\n            // console.log(\"MapInstance.removeLayer(\" + id + \")\");\n            if(index >= 0 && index < this._layerStates.length)\n                this._layerStates.splice(index, 1);\n\n            //stop listening for errors\n            layerInstance.off(\"layer:error\");\n\n            //remove layer from map\n            this._mapInstance.removeLayer(layerInstance);\n\n            //remove layer from cache\n            this._layerCache[id] = null;\n        }\n        this.touch('layers:changed');\n    }\n\n    /**\n     *\n     */\n    toggleLayerVisibility (id) {\n        if(!this._layerCache) return;\n        var layerInstance = this._layerCache[id];\n        if(layerInstance) {\n            let state = this.getLayerState(id);\n            state.visibility = !state.visibility;\n\n            if(layerInstance._currentImage) {\n                //ESRI Image Service layers have an IMG element\n                // that gets modified and replaced every map event (zoom/pan)\n                // so we can't just toggle classes like on other layers.\n                //Instead, we need to use the ESRI setOpacity method to toggle\n                // but need to update layer state as well.\n                layerInstance.setOpacity(state.visibility ? 1 : 0);\n                state.opacity = layerInstance.getOpacity();\n                return;\n            }\n\n            this.setLayerVisibility(layerInstance, state.visibility);\n        }\n    }\n\n    /**\n     * Note: this does not update layer definition state. Use\n     * MapInstance.toggleLayerVisibility to do that and adjust\n     * rendered layer's visibility.\n     *\n     * @param layerInstance - leaflet layer instance\n     * @param visible - flag indicating visibility of layer\n     */\n    setLayerVisibility (layerInstance : Layer, visible : boolean) {\n\n        if((layerInstance as any).setVisibility) {\n            //using custom method provided in src/layer/module.js\n            (layerInstance as any).setVisibility(visible);\n\n        } else if((layerInstance as any)._container) {\n            //otherwise, using jquery on dom directly\n            let el = jQuery((layerInstance as any)._container);\n            // if(visible) el.removeClass(\"invisible\");\n            // else el.addClass('invisible');\n            el.css({'display': visible ? '' : 'none'});\n        }\n\n        this.touch('map:layer:changed');\n    }\n\n    /**\n     *\n     */\n    updateLayerOpacity (id : string, opacity : number) {\n\n        if(!this._layerCache) return;\n        var layerInstance = this._layerCache[id];\n\n        //if layer id is for base layer...\n        if(!layerInstance && this._baseLayerDef.id === id) {\n            layerInstance = this._baseLayer;\n        }\n\n        //adjust rendered leaflet layer\n        opacity = this.setLayerOpacity(layerInstance, opacity);\n\n        // if overlay layer, update state value\n        let state = this.getLayerState(id);\n        if(state) state.opacity = opacity;\n\n    }\n\n    /**\n     * Note: this method does not update the associated Layer Definition\n     * state value for opacity. Use MapInstance.updateLayerOpacity() to\n     * both update state and adjust rendered layer.\n     *\n     * @param layerInstance - leaflet layer instance\n     * @param opacity - value between 0 and 1.0 or 0 and 100\n     * @return normalized opacity value between 0 and 1.0\n     */\n    setLayerOpacity (layerInstance : Layer, opacity : number) : number {\n        if(layerInstance && (layerInstance as any).setOpacity) {\n            if(opacity > 1.0) opacity = opacity / 100.0;\n            (layerInstance as any).setOpacity(opacity);\n            this.touch('map:layer:changed');\n        }\n        return opacity;\n    }\n\n    /**\n     * @param GeoPlatform Layer instance\n     * @return Leaflet layer instance representing that layer or null\n     */\n    getLeafletLayerFor (gpLayer : any) : Layer {\n        if(!gpLayer || !this._layerCache) return null;\n        let leafletLayer = this._layerCache[gpLayer.id];\n        return leafletLayer || null;\n    }\n\n    /**\n     *\n     */\n    toggleGetFeatureInfo (layerId : string) {\n        if(!this._layerCache) return;\n        var layerInstance = this._layerCache[layerId];\n        if(layerInstance) {\n            if(typeof(layerInstance.enableGetFeatureInfo) !== 'undefined') {\n                if(layerInstance.isGetFeatureInfoEnabled()) {\n                    layerInstance.disableGetFeatureInfo();\n                    jQuery((this._mapInstance as any)._container).removeClass('selectable-cursor');\n                } else {\n                    layerInstance.enableGetFeatureInfo();\n                    jQuery((this._mapInstance as any)._container).addClass('selectable-cursor');\n                }\n            }\n\n        }\n    }\n\n\n    /* ==============================================\n       Feature operations\n       ============================================== */\n\n\n    /**\n     * @return array of features on the map\n     */\n    getFeatures () : any[] {\n        if(this._featureLayer) {\n            let geojson = this._featureLayer.toGeoJSON();\n            return (geojson as any).features;\n        }\n        return [];\n    }\n\n    /**\n     * @param json geojson object or array of geojson objects\n     */\n    addFeatures (json : any) {\n\n        if(!json) return;\n\n        if(typeof(json.push) !== 'undefined') {\n            //array of features\n            for(var i=0; i<json.length; ++i)\n                this.addFeature(json[i], false);\n            this.touch('features:changed');\n\n        } else if(json.features) {\n            this.addFeatures(json.features);\n\n        } else { //single feature\n            this.addFeature(json, true);\n        }\n\n    }\n\n    /**\n     * @param json geojson object\n     */\n    addFeature (json : any, fireEvent ?: boolean) {\n        // var type = json.type;\n        // var coordinates = json.coordinates;\n\n        if(!this._featureLayer) {\n\n            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);\n            this._featureLayer = featureGroup().addTo(this._mapInstance);\n\n        }\n\n        // _featureLayer.addData(json);\n        var opts = jQuery.extend({}, this._geoJsonLayerOpts);\n        geoJSON(json, opts).eachLayer((l)=>this.addFeatureLayer(l));\n\n        if(typeof(fireEvent) === 'undefined' || fireEvent === true)\n            this.touch('features:changed');\n        else this.touch();\n\n        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));\n\n    }\n\n    /**\n     * @param featureJson object defining a GeoJSON feature\n     */\n    updateFeature (featureJson : any) {\n        var layer = this.getFeatureLayer(featureJson.properties.id);\n        if(layer) {\n\n            (layer as any).feature = featureJson;\n\n            //update style\n            layer.setStyle(featureJson.properties.style);\n\n            //rebind label in case that changed\n            var label = featureJson.properties.label ||\n                \"Untitled \" + featureJson.geometry.type + \" Feature\";\n            layer.bindTooltip(label);\n\n            // layer.redraw();\n            this.touch(\"map:feature:changed\");\n        }\n    }\n\n    /**\n     * Replace an existing L.Path-based layer with one using\n     * the supplied Feature GeoJSON object.  Removes the existing\n     * layer and adds a new one created from the GeoJSON.\n     *\n     * @param featureJson object defining GeoJSON feature\n     */\n    replaceFeature (featureJson : any) {\n\n        //find existing layer for this feature\n        var layer = this.getFeatureLayer(featureJson.properties.id);\n        if(layer) {\n\n            //remove existing\n            this._featureLayer.removeLayer(layer);\n\n            //add replacement\n            geoJSON(featureJson, this._geoJsonLayerOpts)\n                .eachLayer((l)=>this.addFeatureLayer(l));\n\n            this.touch(\"map:feature:changed\");\n        }\n    }\n\n    /**\n     * @param featureId identifier of feature to focus the map on\n     */\n    focusFeature (featureId : string) {\n        var layer = this.getFeatureLayer(featureId);\n        if(layer) {\n            if( typeof(layer.getBounds) !== 'undefined') {\n                let extent = layer.getBounds();\n                this._mapInstance.fitBounds(extent);\n            } else if(typeof( (layer as any).getLatLng) !== 'undefined') {\n                let latLng = (layer as any).getLatLng();\n                this._mapInstance.panTo(latLng);\n            } else {\n                console.log(\"MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng\");\n            }\n        } else {\n            console.log(\"MapInstance.focusFeature() - Cannot focus feature because it has no layer\");\n        }\n    }\n\n    /**\n     * @param featureId : string\n     */\n    removeFeature (featureId) {\n        var layer = this.getFeatureLayer(featureId);\n        if(layer && this._featureLayer) {\n            this._featureLayer.removeLayer(layer);\n            this.touch('features:changed');\n        }\n    }\n\n    /**\n     *\n     */\n    removeFeatures () {\n        if(this._featureLayer) {\n            this._featureLayer.clearLayers();\n            this.touch(\"features:changed\");\n        }\n    }\n\n    /**\n     *\n     */\n    getFeatureLayer ( featureId ?: string ) : FeatureGroup {\n        //if no feature was specified, return root feature layer\n        if(!featureId) return this._featureLayer;\n\n        //otherwise, find feature...\n        if(!this._featureLayer) return null;\n\n        var features = this._featureLayer.getLayers();\n        for(var i=0; i<features.length; ++i) {\n            if( (features[i] as any).feature &&\n                (features[i] as any).feature.properties.id === featureId) {\n                return (features[i] as any);\n            }\n        }\n        return null;\n    }\n\n    toggleFeaturesLayer () {\n        if(!this._featureLayer) return false;    //ignore if not rendered yet\n\n        this._featureLayerVisible = !this._featureLayerVisible;\n        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);\n        return this._featureLayerVisible;\n    }\n\n    /**\n     * @param  feature - Leaflet feature instance\n     * @param  visibility - flag\n     */\n    setFeatureVisibility (feature, visibility : boolean) {\n        this.setFeatureLayerVisibility(feature, visibility);\n    }\n\n    getFeaturesLayerVisibility () {\n        return this._featureLayerVisible;\n    }\n\n\n    /*\n     * method for adding feature layers to the map\n     * when these layers may be layer groups.\n     * finds leaf node layers and adds them to the\n     * map's feature group\n     */\n    addFeatureLayer(layer) {\n        this._addFeatureLayer(layer);\n        this.touch(\"features:changed\");\n    }\n\n    /**\n     * Internal method, use 'addFeatureLayer' instead\n     * @param layer\n     */\n    _addFeatureLayer(layer : Layer) {\n        if(!(layer as any).feature && layer instanceof LayerGroup) {\n            layer.eachLayer( (child) => {\n                this._addFeatureLayer(child);\n            });\n        } else {\n            this._featureLayer.addLayer(layer);\n        }\n    }\n\n\n    //toggle visibility of parent feature layer\n    setFeatureLayerVisibility(layer, visibility) {\n        if(!layer) return;\n        this._featureLayerVisible = visibility;\n\n        if(layer.getLayers) {\n            layer.getLayers().forEach( (child) => {\n                this.setFeatureLayerVisibility(child, visibility);\n            });\n\n        } else {\n            let container = layer._container || layer._path;\n            if(container)\n                container.style.display = visibility ? '' : 'none';\n        }\n    }\n\n\n\n    /* ==============================================\n       Map lifecycle operations\n       ============================================== */\n\n    /**\n     * @param metadata\n     * @return resolving persisted map\n     */\n    save (metadata : any) : Q.Promise<any> {\n        return this.saveMap(metadata);\n    }\n\n    /**\n     * @param md object containing metadata properties for map\n     */\n    saveMap (md : any) : Q.Promise<any> {\n\n        let metadata = md || {};\n\n        //add GeoPlatformMap resource type if not already present\n        const gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';\n        metadata.resourceTypes = metadata.resourceTypes || [];\n        if(metadata.resourceTypes.indexOf(gpMapType) < 0)\n            metadata.resourceTypes.push(gpMapType);\n\n        var content = this.getMapResourceContent(metadata);\n\n        //ensure the two name properties line up\n        if(content.title && content.title !== content.label) {\n            content.label = content.title;\n        } else if(content.label && !content.title) {\n            content.title = content.label;\n        }\n\n        // console.log(\"Updating: \" + JSON.stringify(map));\n        return this.getService(ItemTypes.MAP)\n        .save(content)\n        .then( result => {\n\n            //track new map's info so we can update it with next save\n            if(!this._mapId)\n                this._mapId = result.id;\n\n            this._mapDef = result;\n            this._defaultExtent = result.extent;\n            this.clean();\n            return result;\n        })\n        .catch(err=>{\n            console.log(\"MapCore MapInstance.saveMap() - \" +\n                \"The requested map could not be saved because: \" + err.message);\n            let e = new Error(\"The requested map could not be saved because of the following error(s): \" +\n                err.message);\n            return Q.reject(e);\n        });\n\n    }\n\n    /**\n     * Retrieve a map's descriptor from the registry\n     * @param mapId identifier of map\n     * @return resolving the map object\n     */\n    fetchMap (mapId : string) : Q.Promise<any> {\n        //Having to send cache busting parameter to avoid CORS header cache\n        // not sending correct Origin value\n        return this.getService(ItemTypes.MAP).get(mapId);\n    }\n\n    /**\n     * Retrieve a map's descriptor and load it as the\n     * current map managed by this service\n     * @param mapId identifier of map\n     * @return resolving the map object\n     */\n    loadMap (mapId : string) : Q.Promise<any> {\n\n        return this.fetchMap(mapId).then(map => {\n\n            if(!map) {\n                throw new Error(\"The requested map ('\" + mapId +\n                    \"') came back null\");\n\n            } else if(typeof(map) === 'string') {\n                throw new Error(\"The requested map ('\" + mapId +\n                    \"') came back as a string\");\n\n            } else if((map as any).message) {\n                throw new Error(\"There was an error loading the requested map ('\" +\n                    mapId + \"'): \" + (map as any).message);\n            }\n\n\n            //loading a map by its ID, so we need to increment it's view count\n            if('development' !== Config.env) {\n\n                setTimeout( (map) => {\n                    //update view count\n                    let views = map.statistics ? (map.statistics.numViews||0) : 0;\n                    let patch = [ { op: 'replace', path: '/statistics/numViews', value: views+1 } ];\n                    this.getService(ItemTypes.MAP).patch(map.id, patch)\n                    // this.mapService.patch(map.id, patch)\n                    .then( updated => { map.statistics = updated.statistics; })\n                    .catch( e => {\n                        console.log(\"MapInstance.saveMap() - Error updating view \" +\n                            \"count for map ('\" + mapId + \"'): \" + e);\n                    });\n                }, 1000, map);\n\n            }\n\n            //load the map into the viewer\n            this.loadMapFromObj(map);\n\n            return map;\n        })\n        .catch( err => {\n            console.log(\"MapInstance.loadMap() - \" +\n                \"The requested map could not be loaded because \" + err.message);\n            let e = new Error(\"The requested map ('\" + mapId +\n                \"') could not be loaded because of the following error(s): \" +\n                err.message);\n            return Q.reject(e);\n        });\n    }\n\n    /**\n     * Load a map from its descriptor as the current\n     * map managed by this service\n     * @param map object\n     */\n    loadMapFromObj (map : any) {\n\n        // console.log(\"Loading Map Object\");\n        // console.log(map);\n\n        this._mapId = map.id;\n        this._mapDef = map;\n\n        map.extent = map.extent || {};\n        let west =  isNaN(map.extent.minx) ? -179.0 : map.extent.minx*1.0;\n        let east =  isNaN(map.extent.maxx) ?  179.0 : map.extent.maxx*1.0;\n        let south = isNaN(map.extent.miny) ?  -89.0 : map.extent.miny*1.0;\n        let north = isNaN(map.extent.maxy) ?   89.0 : map.extent.maxy*1.0;\n\n        //ensure x,y is ordered correctly\n        let t;\n        if(west > east) {\n            t = Math.min(west, east);\n            east = map.extent.maxx = Math.max(west, east);\n            west = map.extent.minx = t;\n        }\n        if(south > north) {\n            t = Math.min(south, north);\n            north = map.extent.maxy = Math.max(south, north);\n            south = map.extent.miny = t;\n        }\n\n        //prevent out-of-bounds extents\n        if(west < -180.0) west = -179.0;\n        if(east > 180.0)  east =  179.0;\n        if(south < -90.0) south = -89.0;\n        if(north > 90.0)  north =  89.0;\n\n        //set extent from loaded map\n        this._defaultExtent = map.extent;\n        var extent = map.extent;\n\n        //remove existing layers\n        this._mapInstance.eachLayer((l) => {\n            this._mapInstance.removeLayer(l);\n        });\n        this._layerCache = {};\n        this._layerStates = [];\n\n        //set new base layer\n        this.setBaseLayer(map.baseLayer);\n\n        //add layers from loaded map\n        this.addLayers(map.layers);\n\n        //add features\n        if(map.annotations && map.annotations.geoJSON) {\n            let fc = map.annotations.geoJSON;\n            if(fc.features)\n                this.addFeatures(fc.features);\n            else\n                this.addFeatures([fc]);\n        }\n\n        this._mapInstance.fitBounds([\n            [extent.miny, extent.minx],\n            [extent.maxy, extent.maxx]\n        ]);\n\n        this.clean();\n        this.notify('map:loaded', map);\n\n    }\n\n\n    /**\n     *\n     */\n    destroyMap () {\n        // console.log(\"Destroying Map\");\n        this._mapInstance = null;\n        this._layerCache = null;\n        this._layerStates = null;\n        this._featureLayer = null;\n    }\n\n\n    /**\n     * Used to take an existing map that is already persisted on the\n     * server and unlink it here in the client so that it will be saved\n     * as a completely new map when mapService.saveMap(...) is next called\n     */\n    setAsNewMap (mapToUse) {\n        this._mapId = null;\n        this._mapDef = mapToUse || this.initializeMapDefinition();\n    }\n\n\n    /* ==============================================\n        Tool operations\n       ============================================== */\n\n    registerTool (id, tool) {\n        this._tools[id] = tool;\n    }\n\n    unregisterTool (id) {\n        this._tools[id] = null;\n    }\n\n    enableTool (id, finish) {\n        if(!this._tools[id]) return false;\n        this._tools[id].activate(function() {\n            this.notify('tool:disabled', id);\n        });\n        this.notify('tool:enabled', id);\n    }\n\n\n    /* ----------- MISC ------------ */\n\n    //https://github.com/gsklee/ngStorage\n    cacheMap () {\n\n        if(this.state && this.state.dirty) {\n            var map = this.getMapResourceContent();\n            //use exploded layer info\n            map.layers = this._layerStates.slice(0);\n            // $sessionStorage.map = map;\n        }\n    }\n\n    restoreMap () {\n        // if($sessionStorage.map) {\n        //     console.log(\"Restoring cached map\");\n        //     let map = $sessionStorage.map;\n        //     // console.log(JSON.stringify(map));\n        //     $sessionStorage.map = null;\n        //     this.loadMapFromObj(map);\n        // }\n    }\n    /* ---------------------------- */\n}\n","\nimport MapInstance from './instance';\n\nvar cache = {};\n\nexport default {\n\n    get: function(key) {\n        if(key && cache[key])\n            return cache[key];\n\n        let instance = new MapInstance(key);\n        cache[instance._key] = instance;\n        return instance;\n    },\n\n    dispose: function(key) {\n        if(key) {\n            cache[key].dispose();\n            delete cache[key];\n        } else {\n            cache = null;\n        }\n    }\n};\n","\n\nexport default function() {\n\n    if (typeof Object.assign != 'function') {\n        // Must be writable: true, enumerable: false, configurable: true\n        Object.defineProperty(Object, \"assign\", {\n            value: function assign(target, varArgs) { // .length of function is 2\n                'use strict';\n                if (target == null) { // TypeError if undefined or null\n                    throw new TypeError('Cannot convert undefined or null to object');\n                }\n\n                var to = Object(target);\n\n                for (var index = 1; index < arguments.length; index++) {\n                    var nextSource = arguments[index];\n\n                    if (nextSource != null) { // Skip over if undefined or null\n                        for (var nextKey in nextSource) {\n                            // Avoid bugs when hasOwnProperty is shadowed\n                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                                to[nextKey] = nextSource[nextKey];\n                            }\n                        }\n                    }\n                }\n                return to;\n            },\n            writable: true,\n            configurable: true\n        });\n    }\n\n}\n","\nimport Polyfills from \"./polyfills\";\nPolyfills();\n\n\nimport LoadingControl from './control/loading';\nimport MeasureControl from './control/measure';\nimport MousePositionControl from './control/mouse-position';\nimport FeatureEditor from './control/feature-editor';\n\nimport DefaultBaseLayer from './layer/baselayer-default';\nimport LayerFactory from './layer/factory';\nimport OSMLayerFactory from './layer/osm-factory';\nimport BaseClusteredFeatureLayer from './layer/base-clustered-feature-layer';\nimport {\n    ClusteredFeatureLayer,\n    clusteredFeatures,\n    geoJsonFeed\n} from './layer/cluster-feature';\nimport FeatureLayer from './layer/feature';\nimport {WMS, wms} from './layer/wms';\nimport {WMST, wmst} from './layer/wmst';\nimport {WMTS, wmts} from './layer/wmts';\nimport ESRITileLayer from './layer/esri-tile-layer';\nimport OSM from './layer/osm';\n\nimport MapInstance from './map/instance';\nimport MapFactory from './map/factory';\n\nimport ServiceTypes from './service/types';\n\nimport PopupTemplate from './shared/popup-template';\nimport StyleResolver from './shared/style-resolver';\n\n\n\n\nexport {\n    LoadingControl,\n    MeasureControl,\n    MousePositionControl,\n    FeatureEditor,\n    DefaultBaseLayer,\n    LayerFactory,\n    OSMLayerFactory,\n    BaseClusteredFeatureLayer,\n    ClusteredFeatureLayer,\n    clusteredFeatures,\n    geoJsonFeed,\n    FeatureLayer,\n    WMS, wms,\n    WMST, wmst,\n    WMTS, wmts,\n    ESRITileLayer,\n    OSM,\n    MapInstance,\n    MapFactory,\n    ServiceTypes,\n    PopupTemplate,\n    StyleResolver\n};\n"]}