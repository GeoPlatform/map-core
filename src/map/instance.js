

import jQuery from "jquery";
import Q from "q";
import { circleMarker, geoJson, featureGroup, LayerGroup } from 'leaflet';

import GeoPlatformClient from 'geoplatform.client';

import LayerFactory from '../layer/factory';
import OSM from "../layer/osm";

const ItemTypes = GeoPlatformClient.ItemTypes;
const ServiceFactory = GeoPlatformClient.ServiceFactory;
const HttpClient = GeoPlatformClient.JQueryHttpClient;
const Config = GeoPlatformClient.Config;


class Listener {

    constructor() {
        //listeners to be unregistered upon destroy
        this._listeners = {};
    }

    on (type, listener) {
        if(!this._listeners[type])
            this._listeners[type] = [];
        this._listeners[type].push(listener);
    }

    off (type, listener) {
        if(!type) this._listeners = {};
        if(!this._listeners[type]) return;
        if(!listener) this._listeners[type] = [];
        else {
            var idx = this._listeners[type].indexOf(listener);
            if(idx >= 0)
                this._listeners[type].splice(idx, 1);
        }
    }

    notify(type) {
        if(!this._listeners[type]) return;
        var args = Array.prototype.slice.call(arguments, 1);
        this._listeners[type].each(function(l) { l.apply(null, args); });
    }

}



class MapInstance extends Listener {

    constructor(key) {
        super();

        this.setHttpClient(new HttpClient());
        this.setServiceFactory(ServiceFactory);

        //generate random key (see factory below)
        this._key = key || Math.ceil(Math.random()*9999);

        //registry id of current map if available
        this._mapId = null,

        //definition of map (ie, from server)
        this._mapDef = this.initializeMapDefinition(),

        //primary map instance (ie, leaflet)
        this._mapInstance = null,

        //default map extent (if map doesn't have one for being saved)
        this._defaultExtent = null,

        //current base layer object and leaflet instance
        this._baseLayerDef = null,
        this._baseLayer = null,

        //set definitions of layer states (including layer info) on map
        this._layerStates = [],

        //map layer def ids with leaflet instances
        this._layerCache = {},

        //errors generated by layers loading
        this._layerErrors= [],
        this._layerErrorHandler = function(e) {
            console.log(`MapInstance.defaultLayerErrorHandler() - ${e.id} : ${e.message}`);
        },

        //layer used to store features on map
        this._featureLayer = null,
        this._featureLayerVisible = true,

        //set of registered map tools
        this._tools = [],

        //state management
        this.state = { dirty: false }; // jshint ignore:line


        this._geoJsonLayerOpts = {
            style: function(feature) {
                if(feature.properties.style)
                    return feature.properties.style;
            },
            onEachFeature: function(feature, layer) {

                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };
                if(~feature.geometry.type.indexOf('Point')) {
                    style.fillOpacity = 0.9;
                }

                var props = feature.properties = feature.properties || {};
                if(feature.properties.id === undefined || feature.properties.id === null)
                    feature.properties.id = Math.floor(Math.random()*999999);
                feature.properties.label = props.label || props.title || props.name || "Untitled " + feature.geometry.type + " Feature";
                feature.properties.description = props.description || props.desc || "This feature needs a description!";
                feature.properties.style = props.style || style;

                layer.bindTooltip(props.label);
                /*
                toggle: setLabelNoHide(bool)
                it may only exist on markers!
                */
            },
            pointToLayer: function (feature, latlng) {

                var style = feature.properties.style || {};
                style.radius = style.radius || 4;
                style.weight = style.weight || 2;
                style.color = style.color || '#03f';
                style.opacity = style.opacity || 0.9;
                style.fillOpacity = style.opacity;
                style.fillColor = style.color;

                if(!L) {
                    throw new Error("Leaflet is not available");
                }
                return circleMarker(latlng, style);
            }
        };

    }

    dispose () {
        this.destroyMap();
        this.svcCache = null;
        this.serviceFactory = null;
        this.httpClient = null;
        this._key = null;
        this._mapId = null;
        this._mapDef = null;
        this._mapInstance = null;
        this._defaultExtent = null;
        this._baseLayerDef = null;
        this._baseLayer = null;
        this._layerStates = null;
        this._layerCache = null;
        this._layerErrors= null;
        this._featureLayer = null;
        this._featureLayerVisible = true;
        this._tools = null;
        this.state = null;
        this._geoJsonLayerOpts = null;
    }


    getKey () {
        return this._key;
    }

    /**
     * Override default (JQuery-based) map service used by this instance
     * @param {ItemService} mapService - service to use to CRUD map objects
     * @deprecated use setServiceFactory instead
     */
    setService(mapService) {
        // this.mapService = mapService;
    }

    /**
     * @param {ServiceFactory} factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     */
    setServiceFactory(factory) {
        this.svcCache = {}; //wipe out cached services
        this.serviceFactory = factory;
    }

    /**
     * @param {HttpClient} httpClient - HttpClient impl to use with the new factory
     */
    setHttpClient(httpClient) {
        this.svcCache = {}; //wipe out cached services
        this.httpClient = httpClient;
    }

    /**
     * @param {string} type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return {ItemService} item service implementation for the requested type
     */
    getService(type) {
        if(!this.svcCache[type])
            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);
        return this.svcCache[type];
    }

    /**
     * @param {Function} fn - callback when an error is encountered
     */
    setErrorHandler(fn) {
        this._layerErrorHandler = fn;
    }


    //-----------------
    getLayerStateIndex (layerId) {
        if(!layerId) return -1;
        for(let i=0; i<this._layerStates.length; ++i) {
            if(this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {
                return i;
            }
        }
        return -1;
        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );
    }

    getLayerState (layerId) {
        let index = this.getLayerStateIndex(layerId);
        return index >= 0 ? this._layerStates[index] : null;
    }
    //-----------------


    initializeMapDefinition() {
        return {
            type: ItemTypes.MAP,
            title: "My New Map",
            label: "My New Map",
            description: "This map needs a description",
            createdBy: null,
            baseLayer: this._baseLayerDef,
            layers: [],
            keywords: [],
            themes: [],
            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']
        };
    }

    /**
     * @param metadata object
     * @return object definition of the current map suitable for sending to WMVR
     */
    getMapResourceContent(metadata) {

        metadata = metadata || {};

        //map layers
        metadata.layers = this._layerStates.slice(0);
        // ... UAL should support accepting just an id here, so we'll do just that
        metadata.baseLayer = this._baseLayerDef;

        metadata.annotations = this._featureLayer ?
            { title: "Map Features", geoJSON: this._featureLayer.toGeoJSON() } : null;

        //geographic extent
        let extent = this._mapInstance.getBounds();
        metadata.extent = {
            minx: extent.getWest(),
            miny: extent.getSouth(),
            maxx: extent.getEast(),
            maxy: extent.getNorth()
        };

        return metadata;
    }

    /**
     * @return Leaflet toolbar
     */
    getDrawControlToolbar() {
        if(!this._mapInstance.drawControl) return null;
        var toolbars = this._mapInstance.drawControl._toolbars;
        var toolbar = null;
        for(var key in toolbars) {
            if(toolbars.hasOwnProperty(key)) {
                if(toolbars[key]._modes) {
                    toolbar = toolbars[key];
                    break;
                }
            }
        }
        return toolbar;
    }

    /**
     * @param error Leaflet tile load error (.target is layer, .tile is image)
     */
    handleLayerError(error) {
        // console.log("MapInstance.handleLayerError() - " +
        //     "Layer's tile failed to load: " + error.tile.src);
        var layer = error.target;
        for(var id in this._layerCache) {
            if(this._layerCache[id] === layer) {
                this.processLayerError(error, id);
                break;
            }
        }
    }

    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     */
    processLayerError(error, id) {

        var finder = function(l){return l.id === id;};

        if(!this._layerErrors.find(finder)) {

            this.logLayerError(id, "Layer failed to completely load. " +
                "It may be inaccessible or misconfigured.");

            var url = error.tile.src;
            var params = {id:id};
            url.substring(url.indexOf("?")+1, url.length).split('&').each(function(param) {
                var p = param.split('=');
                params[p[0]] = p[1];
            });

            this.layerService.validate(id, params)
            .catch(e => {
                var def = this._layerStates.find(finder);
                obj.message = "Layer '" + def.label + "' failed to completely load. " +
                        "It may be inaccessible or misconfigured. Reported cause: " + e.message;
                this.notify('layer:error', obj);
            });
        }
    }

    /**
     * @param {string} layerId - identifier of layer generating the error
     * @param {string} errorMsg - message of the error
     */
    logLayerError(layerId, errorMsg) {
        // console.log("MapInstance.logLayerError() - layer "  + id +
        //     " generated error '" + errorMsg + "'");
        let err = { id: layerId, message: errorMsg };
        this._layerErrors.push(err);
        if(this._layerErrorHandler) {
            this._layerErrorHandler(err);
        }
    }

    /* -- State Management of internal model -- */

    touch (event) {
        this.state.dirty = true;
        if(event) {
            if(arguments.length > 1) {
                this.notify.apply(this, Array.prototype.slice.call(arguments));
            } else
                this.notify(event);
            // console.log("Dirtying map for " + event);
        }
        // else console.log("Dirtying map");
    }
    clean() {
        // console.log("Cleaning map");
        this.state.dirty = false;
    }
    /* --------------------------------------- */




    /* ==============================================
        Map manipulation operations
       ============================================== */

    setMap (map) { this._mapInstance = map; }

    /**
     * @return {L.Map} map instance
     */
    getMap () { return this._mapInstance; }

    /** @return {object} definition of map */
    getMapDefinition () { return this._mapDef; }

    /** @return {string} identifier of map */
    getMapId () { return this._mapId; }

    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param lat number
     * @param lng number
     * @param zoom number (optional)
     */
    setView (lat, lng, zoom) {
        let z = zoom;
        if(typeof(z) === 'undefined')
            z = this._mapInstance.getZoom();
        this._mapInstance.setView([lat,lng], z);
        this.touch('map:view:changed');
    }

    /**
     * Retrieve the current center of the map
     * @return [lat,lng]
     */
    getView () {
        var latLng = this._mapInstance.getCenter();
        return [latLng.lat, latLng.lng];
    }

    /**
     * @return integer current zoom level of the map
     */
    getZoom () {
        return this._mapInstance.getZoom();
    }

    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     */
    zoomToDefault () {
        if(!this._mapInstance) return;
        if(this._defaultExtent) {
            this._mapInstance.fitBounds([
                [this._defaultExtent.miny, this._defaultExtent.minx],
                [this._defaultExtent.maxy, this._defaultExtent.maxx]
            ]);
        } else {
            console.log("MapInstance.zoomToDefault() - No default extent specified");
            this._mapInstance.setView([38, -96], 5);
        }
        try {
            this.touch('map:view:changed');
        } catch(e) { }
    }

    /**
     * @param {Object} extent - either a GP extent object or Leaflet LatLngBounds object
     */
    setExtent(extent) {
        if(!extent) return;
        if( typeof(extent.minx) !== 'undefined' &&
            typeof(extent.miny) !== 'undefined' &&
            typeof(extent.maxx) !== 'undefined' &&
            typeof(extent.maxy) !== 'undefined' ) {
            //GP model extent
            this._mapInstance.fitBounds([
                [extent.miny, extent.minx],
                [extent.maxy, extent.maxx]
            ]);
        } else if(typeof(extent.getWest) !== 'undefined') {
            //L.LatLngBounds
            this._mapInstance.fitBounds(extent);
        } else {

        }
    }


    /* ==============================================
        Layer operations
       ============================================== */


    /**
     * @param layer Leaflet Layer instance or object definition
     */
    setBaseLayer (layer) {

        let promise = null;
        if(!layer) {
            promise = OSM.get();
        } else
            promise = Q.resolve(layer);

        promise.then( layer => {

            let leafletLayer = LayerFactory(layer);
            if(!leafletLayer) return;

            this._mapInstance.addLayer(leafletLayer);
            leafletLayer.setZIndex(0);  //set at bottom

            let oldBaseLayer = this._baseLayer;
            if(oldBaseLayer) {
                this._mapInstance.removeLayer(oldBaseLayer);
            }

            //remember new base layer
            this._baseLayer = leafletLayer;
            this._baseLayerDef = layer;

            //will notify listeners
            this.touch('baselayer:changed', layer, leafletLayer);
            // this.notify('baselayer:changed', layer, leafletLayer);

        })
        .catch(e => {
            console.log(`MapInstance.setBaseLayer() - Error getting base layer for map : ${e.message}`);
            this.logLayerError( layer.id, e.message );
        });
    }

    /**
     * @return array of base layers definitions that can be used
     */
    // getBaseLayerOptions () {
    //     return this._baseLayerOptions;
    // },

    getBaseLayer () { return this._baseLayerDef; }

    /**
     * @return {array[object]} list of layer states containing layer information
     */
    getLayers () { return this._layerStates; }

    getLayerErrors () { return this._layerErrors; }

    clearLayerErrors () {
        this._layerErrors = [];
        this.notify('layer:error');
    }

    clearOverlays () {
        for(var i=this._layerStates.length-1; i>=0; --i) {
            var state = this._layerStates[i];
            var layerInstance = this._layerCache[state.layer.id];
            if(layerInstance) {
                layerInstance.off("layer:error");
                this._layerCache[state.layer.id] = null;
                this._mapInstance.removeLayer(layerInstance);
            }
        }
        this._layerStates = [];
        this.touch('layers:changed');

        //TODO stop listening for layer events
    }

    /**
     * @param {array[object]} layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     */
    addLayers (layers) {

        if(!layers) return;
        if(typeof(layers.push) === 'undefined') {
            layers = [layers];
        }

        layers.forEach( (obj,index) => {

            let layer = null, state = null;

            if(obj.type && obj.type===ItemTypes.LAYER) { //is a layer
                layer = obj;
            } else if(obj.layer) {  //is layer state
                layer = obj.layer;  // containing a layer
                state = obj;
            }

            if(!layer) {
                console.log("Warning: MapInstance.addLayers() - layer (" + index +
                    ") is not a Layer or a Layer state. Ignoring...");
                return;  //layer info is missing, skip it
            }

            //DT-442 prevent adding layer that already exists on map
            if(this._layerCache[layer.id]) return;

            if(!state) {
                try {
                    //wrapped in try{}catch because layer may contain circular reference
                    // which will cause error when used by JSON methods
                    let layerCopy = JSON.parse(JSON.stringify(layer));
                    state = {
                        opacity: 1,
                        visibility: true,
                        layer: layerCopy
                    };
                } catch(e) {
                    throw new Error("Unable to add layer to map because of " + e.message);
                }
            }

            let z = layers.length - index;
            state.zIndex = z;

            this.addLayerWithState(layer, state);

        });

        this.touch('layers:changed');
    }

    /**
     * @param {Object} layer - GeoPlatform Layer instance
     * @param {Object} state - GeoPlatform Layer State
     */
    addLayerWithState(layer, state) {

        var leafletLayer = null;
        try {
            if(!layer || !state)
                throw new Error("Invalid argument, missing layer and or state");

            leafletLayer = LayerFactory(layer);

            if(!leafletLayer)
                throw new Error("Layer factory returned nothing");

        } catch(e) {
            this.logLayerError( layer.id, 'MapInstance.addLayerWithState() - ' +
                'Could not create Leaflet layer because ' + e.message);
        }

        if(!leafletLayer) return;

        //listen for layer errors so we can inform the user
        // that a layer hasn't been loaded in a useful way
        leafletLayer.on('tileerror', this.handleLayerError);

        this._layerCache[layer.id] = leafletLayer;
        this._mapInstance.addLayer(leafletLayer);

        if( !isNaN(state.zIndex) && leafletLayer.setZIndex )
            leafletLayer.setZIndex(state.zIndex);

        this._layerStates.push(state);

        this.notify('layer:added', layer, leafletLayer);


        // if layer is initially "off" or...
        // if layer is initially not 100% opaque
        if(!state.visibility || state.opacity < 1) {
            // initialize layer visibility and opacity async, or else
            // some of the layers won't get properly initialized
            setTimeout( (layer, state) => {
                this.setLayerVisibility(layer, state.visibility);
                this.setLayerOpacity(layer, state.opacity);
                //TODO notify of change

                //DT-2102 timeout needs to be large enough or else
                // feature layers won't get opacity updated on map load
            }, 2000, leafletLayer, state);
        }
    }

    /**
     * @param {integer} from - position of layer being moved
     * @param {integer} to - desired position to move layer to
     */
    moveLayer (from, to) {

        if(isNaN(from)) return;

        //end of list
        if(isNaN(to)) to = this._layerStates.length-1;

        let copy = this._layerStates.splice(from, 1)[0];    //grab layer being moved
        this._layerStates.splice(to, 0, copy);

        for(let z=1, i=this._layerStates.length-1; i>=0; --i,++z) {
            let layerState = this._layerStates[i];
            let layerInstance = this._layerCache[ layerState.layer.id ];
            if(layerInstance) {
                layerInstance.setZIndex(z);
                layerState.zIndex = z;
            }
        }

        this.touch('layers:changed', this.getLayers());
    }

    /**
     *
     */
    removeLayer (id) {

        var layerInstance = this._layerCache[id];
        if(layerInstance) {

            //remove layer from tracked defs array
            let index = this.getLayerStateIndex(id);
            console.log("MapInstance.removeLayer(" + id + ")");
            if(index >= 0 && index < this._layerStates.length)
                this._layerStates.splice(index, 1);

            //stop listening for errors
            layerInstance.off("layer:error");

            //remove layer from map
            this._mapInstance.removeLayer(layerInstance);

            //remove layer from cache
            this._layerCache[id] = null;
        }
        this.touch('layers:changed');
    }

    /**
     *
     */
    toggleLayerVisibility (id) {
        var layerInstance = this._layerCache[id];
        if(layerInstance) {
            let state = this.getLayerState(id);
            state.visibility = !state.visibility;

            if(layerInstance._currentImage) {
                //ESRI Image Service layers have an IMG element
                // that gets modified and replaced every map event (zoom/pan)
                // so we can't just toggle classes like on other layers.
                //Instead, we need to use the ESRI setOpacity method to toggle
                // but need to update layer state as well.
                layerInstance.setOpacity(state.visibility ? 1 : 0);
                state.opacity = layerInstance.getOpacity();
                return;
            }

            this.setLayerVisibility(layerInstance, state.visibility);
        }
    }

    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param {L.Layer} layerInstance - leaflet layer instance
     * @param {boolean} visible - flag indicating visibility of layer
     */
    setLayerVisibility (layerInstance, visible) {

        if(layerInstance.setVisibility) {
            //using custom method provided in src/layer/module.js
            layerInstance.setVisibility(visible);

        } else if(layerInstance._container) {
            //otherwise, using jquery on dom directly
            let el = jQuery(layerInstance._container);
            // if(visible) el.removeClass("invisible");
            // else el.addClass('invisible');
            el.css({'display': visible ? '' : 'none'});
        }

        this.touch('map:layer:changed');
    }

    /**
     *
     */
    updateLayerOpacity (id, opacity) {

        var layerInstance = this._layerCache[id];

        //if layer id is for base layer...
        if(!layerInstance && this._baseLayerDef.id === id) {
            layerInstance = this._baseLayer;
        }

        //adjust rendered leaflet layer
        opacity = this.setLayerOpacity(layerInstance, opacity);

        // if overlay layer, update state value
        let state = this.getLayerState(id);
        if(state) state.opacity = opacity;

    }

    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param {L.Layer} layerInstance - leaflet layer instance
     * @param {number} opacity - value between 0 and 1.0 or 0 and 100
     * @return {number} normalized opacity value between 0 and 1.0
     */
    setLayerOpacity (layerInstance, opacity) {
        if(layerInstance && layerInstance.setOpacity) {
            if(opacity > 1.0) opacity = opacity / 100.0;
            layerInstance.setOpacity(opacity);
            this.touch('map:layer:changed');
        }
        return opacity;
    }

    /**
     * @param {Object} GeoPlatform Layer instance
     * @return {L.Layer} Leaflet layer instance representing that layer or null
     */
    getLeafletLayerFor (gpLayer) {
        if(!gpLayer) return null;
        let leafletLayer = this._layerCache[gpLayer.id];
        return leafletLayer || null;
    }

    /**
     *
     */
    toggleGetFeatureInfo (layerId) {
        var layerInstance = this._layerCache[layerId];
        if(layerInstance) {
            if(typeof(layerInstance.enableGetFeatureInfo) !== 'undefined') {
                if(layerInstance.isGetFeatureInfoEnabled()) {
                    layerInstance.disableGetFeatureInfo();
                    jQuery(_mapInstance._container).removeClass('selectable-cursor');
                } else {
                    layerInstance.enableGetFeatureInfo();
                    jQuery(_mapInstance._container).addClass('selectable-cursor');
                }
            }

        }
    }


    /* ==============================================
       Feature operations
       ============================================== */


    /**
     * @return array of features on the map
     */
    getFeatures () {
        if(this._featureLayer) {
            return this._featureLayer.toGeoJSON().features;
        }
        return [];
    }

    /**
     * @param json geojson object or array of geojson objects
     */
    addFeatures (json) {

        if(!json) return;

        if(typeof(json.push) !== 'undefined') {
            //array of features
            for(var i=0; i<json.length; ++i)
                this.addFeature(json[i], false);
            this.touch('features:changed');

        } else if(json.features) {
            this.addFeatures(json.features);

        } else { //single feature
            this.addFeature(json, true);
        }

    }

    /**
     * @param json geojson object
     */
    addFeature (json, fireEvent) {
        // var type = json.type;
        // var coordinates = json.coordinates;

        if(!L) {
            throw new Error("Leaflet is not available");
        }

        if(!this._featureLayer) {

            // _featureLayer = geoJson([], _geoJsonLayerOpts).addTo(_mapInstance);
            this._featureLayer = featureGroup().addTo(this._mapInstance);

        }

        // _featureLayer.addData(json);
        var opts = jQuery.extend({}, this._geoJsonLayerOpts);
        geoJson(json, opts).eachLayer((l)=>this.addFeatureLayer(l));

        if(typeof(fireEvent) === 'undefined' || fireEvent === true)
            this.touch('features:changed');
        else this.touch();

        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));

    }

    /**
     * @param featureJson object defining a GeoJSON feature
     */
    updateFeature (featureJson) {
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if(layer) {

            layer.feature = featureJson;

            //update style
            layer.setStyle(featureJson.properties.style);

            //rebind label in case that changed
            var label = featureJson.properties.label ||
                "Untitled " + featureJson.geometry.type + " Feature";
            layer.bindTooltip(label);

            // layer.redraw();
            this.touch("map:feature:changed");
        }
    }

    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param featureJson object defining GeoJSON feature
     */
    replaceFeature (featureJson) {

        if(!L) {
            throw new Error("Leaflet is not available");
        }

        //find existing layer for this feature
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if(layer) {

            //remove existing
            this._featureLayer.removeLayer(layer);

            //add replacement
            geoJson(featureJson, this._geoJsonLayerOpts)
                .eachLayer((l)=>this.addFeatureLayer(l));

            this.touch("map:feature:changed");
        }
    }

    /**
     * @param featureId identifier of feature to focus the map on
     */
    focusFeature (featureId) {
        var layer = this.getFeatureLayer(featureId);
        if(layer) {
            if( typeof(layer.getBounds) !== 'undefined') {
                let extent = layer.getBounds();
                this._mapInstance.fitBounds(extent);
            } else if(typeof(layer.getLatLng) !== 'undefined') {
                let latLng = layer.getLatLng();
                this._mapInstance.panTo(latLng);
            } else {
                console.log("MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng");
            }
        } else {
            console.log("MapInstance.focusFeature() - Cannot focus feature because it has no layer");
        }
    }

    /**
     * @param
     */
    removeFeature (featureId) {
        var layer = this.getFeatureLayer(featureId);
        if(layer && this._featureLayer) {
            this._featureLayer.removeLayer(layer);
            this.touch('features:changed');
        }
    }

    /**
     *
     */
    removeFeatures () {
        if(this._featureLayer) {
            this._featureLayer.clearLayers();
            this.touch("features:changed");
        }
    }

    /**
     *
     */
    getFeatureLayer (featureId) {
        if(!this._featureLayer) return null;

        var features = this._featureLayer.getLayers();
        for(var i=0; i<features.length; ++i) {
            if(features[i].feature.properties.id === featureId) {
                return features[i];
            }
        }
        return null;
    }

    toggleFeaturesLayer () {
        if(!this._featureLayer) return false;    //ignore if not rendered yet

        this._featureLayerVisible = !this._featureLayerVisible;
        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);
        return this._featureLayerVisible;
    }

    /**
     * @param {L.Feature} feature - Leaflet feature instance
     * @param {boolean} visibility - flag
     */
    setFeatureVisibility (feature, visibility) {
        this.setFeatureLayerVisibility(feature, visibility);
    }

    getFeaturesLayerVisibility () {
        return this._featureLayerVisible;
    }


    /*
     * method for adding feature layers to the map
     * when these layers may be layer groups.
     * finds leaf node layers and adds them to the
     * map's feature group
     */
    addFeatureLayer(layer) {
        this._addFeatureLayer(layer);
        this.touch("features:changed");
    }

    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param {Object} layer
     */
    _addFeatureLayer(layer) {
        if(!L) {
            throw new Error("Leaflet is not available");
        }
        if(!layer.feature && layer instanceof LayerGroup) {
            layer.eachLayer( (child) => {
                this._addFeatureLayer(child);
            });
        } else {
            this._featureLayer.addLayer(layer);
        }
    }


    //toggle visibility of parent feature layer
    setFeatureLayerVisibility(layer, visibility) {
        if(!layer) return;
        this._featureLayerVisible = visibility;

        if(layer.getLayers) {
            layer.getLayers().each( (child) => {
                this.setFeatureLayerVisibility(child, visibility);
            });

        } else {
            let container = layer._container || layer._path;
            if(container)
                container.style.display = visibility ? '' : 'none';
        }
    }



    /* ==============================================
       Map lifecycle operations
       ============================================== */

    /**
     * @param {Object} metadata
     * @return {Promise} resolving persisted map
     */
    save (metadata) {
        return this.saveMap(metadata);
    }

    /**
     * @param md object containing metadata properties for map
     */
    saveMap (md) {

        let metadata = md || {};

        //add GeoPlatformMap resource type if not already present
        const gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';
        metadata.resourceTypes = metadata.resourceTypes || [];
        if(metadata.resourceTypes.indexOf(gpMapType) < 0)
            metadata.resourceTypes.push(gpMapType);

        var content = this.getMapResourceContent(metadata);

        //ensure the two name properties line up
        if(content.title && content.title !== content.label) {
            content.label = content.title;
        } else if(content.label && !content.title) {
            content.title = content.label;
        }

        // console.log("Updating: " + JSON.stringify(map));
        return this.getService(ItemTypes.MAP)
        .save(content)
        .then( result => {

            //track new map's info so we can update it with next save
            if(!this._mapId)
                this._mapId = result.id;

            this._mapDef = result;
            this._defaultExtent = result.extent;
            this.clean();
            return result;
        })
        .catch(err=>{
            let e = new Error("MapInstance.saveMap() - " +
                "The requested map could not be saved because: " +
                err.message);
            return Q.reject(e);
        });

    }

    /**
     * Retrieve a map's descriptor from the registry
     * @param {string} mapId identifier of map
     * @return {Promise} resolving the map object
     */
    fetchMap (mapId) {
        //Having to send cache busting parameter to avoid CORS header cache
        // not sending correct Origin value
        return this.getService(ItemTypes.MAP).get(mapId);
    }

    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param {string} mapId identifier of map
     * @return {Promise} resolving the map object
     */
    loadMap (mapId) {

        return this.fetchMap(mapId).then(map => {

            if(!map) {
                throw new Error("The requested map came back null");

            } else if(typeof(map) === 'string') {
                throw new Error("The requested map came back as a string");

            } else if(map.message) {
                throw new Error("There was an error loading the requested map: " + map.message);
            }


            //loading a map by its ID, so we need to increment it's view count
            if('development' !== Config.env) {

                setTimeout( (map) => {
                    //update view count
                    let views = map.statistics ? (map.statistics.numViews||0) : 0;
                    let patch = [ { op: 'replace', path: '/statistics/numViews', value: views+1 } ];
                    this.getService(ItemTypes.MAP).patch(map.id, patch)
                    // this.mapService.patch(map.id, patch)
                    .then( updated => { map.statistics = updated.statistics; })
                    .catch( e => { console.log("Error updating view count for map: " + e); });
                }, 1000, map);

            }

            //load the map into the viewer
            this.loadMapFromObj(map);

            return map;
        })
        .catch( err => {
            let e = new Error("MapInstance.loadMap() - " +
                "The requested map could not be loaded because " + err.message);
            return Q.reject(e);
        });
    }

    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param map object
     */
    loadMapFromObj (map) {

        // console.log("Loading Map Object");
        // console.log(map);

        this._mapId = map.id;
        this._mapDef = map;

        map.extent = map.extent || {};
        let west =  isNaN(map.extent.minx) ? -179.0 : map.extent.minx*1.0;
        let east =  isNaN(map.extent.maxx) ?  179.0 : map.extent.maxx*1.0;
        let south = isNaN(map.extent.miny) ?  -89.0 : map.extent.miny*1.0;
        let north = isNaN(map.extent.maxy) ?   89.0 : map.extent.maxy*1.0;

        //ensure x,y is ordered correctly
        let t;
        if(west > east) {
            t = Math.min(west, east);
            east = map.extent.maxx = Math.max(west, east);
            west = map.extent.minx = t;
        }
        if(south > north) {
            t = Math.min(south, north);
            north = map.extent.maxy = Math.max(south, north);
            south = map.extent.miny = t;
        }

        //prevent out-of-bounds extents
        if(west < -180.0) west = -179.0;
        if(east > 180.0)  east =  179.0;
        if(south < -90.0) south = -89.0;
        if(north > 90.0)  north =  89.0;

        //set extent from loaded map
        this._defaultExtent = map.extent;
        var extent = map.extent;

        //remove existing layers
        this._mapInstance.eachLayer((l) => {
            this._mapInstance.removeLayer(l);
        });
        this._layerCache = {};
        this._layerStates = [];

        //set new base layer
        this.setBaseLayer(map.baseLayer);

        //add layers from loaded map
        this.addLayers(map.layers);

        //add features
        if(map.annotations && map.annotations.geoJSON) {
            let fc = map.annotations.geoJSON;
            if(fc.features)
                this.addFeatures(fc.features);
            else
                this.addFeatures([fc]);
        }

        this._mapInstance.fitBounds([
            [extent.miny, extent.minx],
            [extent.maxy, extent.maxx]
        ]);

        this.clean();
        this.notify('map:loaded', map);

    }


    /**
     *
     */
    destroyMap () {
        // console.log("Destroying Map");
        this._mapInstance = null;
        this._layerCache = null;
        this._layerStates = null;
        this._featureLayer = null;
    }

    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     */
    setAsNewMap (mapToUse) {
        this._mapId = null;
        this._mapDef = mapToUse || this.initializeMapDefinition();
    }


    /* ==============================================
        Tool operations
       ============================================== */

    registerTool (id, tool) {
        this._tools[id] = tool;
    }

    unregisterTool (id) {
        this._tools[id] = null;
    }

    enableTool (id, finish) {
        if(!this._tools[id]) return false;
        this._tools[id].activate(function() {
            this.notify('tool:disabled', id);
        });
        this.notify('tool:enabled', id);
    }


    /* ----------- MISC ------------ */

    //https://github.com/gsklee/ngStorage
    cacheMap () {

        if(state.dirty) {
            var map = this.getMapResourceContent();
            //use exploded layer info
            map.layers = this._layerStates.slice(0);
            // $sessionStorage.map = map;
        }
    }

    restoreMap () {
        // if($sessionStorage.map) {
        //     console.log("Restoring cached map");
        //     let map = $sessionStorage.map;
        //     // console.log(JSON.stringify(map));
        //     $sessionStorage.map = null;
        //     this.loadMapFromObj(map);
        // }
    }
    /* ---------------------------- */
}

export default MapInstance;
