

import * as jquery from "jquery";
const jQuery = jquery;

import * as Q from "q";
import * as geojson from 'geojson';
import {
    Map, Layer, LatLng, LatLngBounds,
    circleMarker, geoJSON,
    featureGroup, FeatureGroup, LayerGroup
} from 'leaflet';

import {
    Config, ItemTypes,
    ServiceFactory, ItemService, MapService, LayerService,
    XHRHttpClient
} from '@geoplatform/client';

import LayerFactory from '../layer/factory';
import OSM from "../layer/osm";
import DefaultBaseLayer from '../layer/baselayer-default';


class Listener {

    _listeners : any;

    constructor() {
        //listeners to be unregistered upon destroy
        this._listeners = {};
    }

    on (type, listener) {
        if(!this._listeners[type])
            this._listeners[type] = [];
        this._listeners[type].push(listener);
    }

    off (type, listener) {
        if(!type) this._listeners = {};
        if(!this._listeners[type]) return;
        if(!listener) this._listeners[type] = [];
        else {
            var idx = this._listeners[type].indexOf(listener);
            if(idx >= 0)
                this._listeners[type].splice(idx, 1);
        }
    }

    notify(type, ...options) {
        if(!this._listeners[type]) return;
        var args = Array.prototype.slice.call(arguments, 1);
        this._listeners[type].forEach(function(l) { l.apply(null, args); });
    }

}



export default class MapInstance extends Listener {

    private svcCache        : any;
    private serviceFactory  : any;
    private httpClient      : any;
    public _key            : string;
    private _mapId          : string;
    private _mapDef         : any;
    private _mapInstance    : Map;
    private _defaultExtent  : any;
    private _baseLayerDef   : any;
    private _baseLayer      : Layer;
    private _layerStates    : any;
    private _layerCache     : any;
    private _layerErrors    : any[];
    private _layerErrorHandler : Function;
    private _featureLayer   : FeatureGroup;
    private _featureLayerVisible  : boolean;
    private _tools          : any[];
    private state           : any;
    private _geoJsonLayerOpts : any;




    constructor(key) {
        super();

        this.setHttpClient(new XHRHttpClient());
        this.setServiceFactory(ServiceFactory);

        //generate random key (see factory below)
        this._key = key || Math.ceil(Math.random()*9999);

        //registry id of current map if available
        this._mapId = null,

        //definition of map (ie, from server)
        this._mapDef = this.initializeMapDefinition(),

        //primary map instance (ie, leaflet)
        this._mapInstance = null,

        //default map extent (if map doesn't have one for being saved)
        this._defaultExtent = null,

        //current base layer object and leaflet instance
        this._baseLayerDef = null,
        this._baseLayer = null,

        //set definitions of layer states (including layer info) on map
        this._layerStates = [],

        //map layer def ids with leaflet instances
        this._layerCache = {},

        //errors generated by layers loading
        this._layerErrors= [],
        this._layerErrorHandler = function(e) {
            console.log(`MapInstance.defaultLayerErrorHandler() - ${e.id} : ${e.message}`);
        },

        //layer used to store features on map
        this._featureLayer = null,
        this._featureLayerVisible = true,

        //set of registered map tools
        this._tools = [],

        //state management
        this.state = { dirty: false }; // jshint ignore:line

        this._geoJsonLayerOpts  = {
            style: function(feature) {
                if(feature.properties.style)
                    return feature.properties.style;
            },
            onEachFeature: function(feature, layer) {

                var style = { weight: 2, color: '#03f', opacity: 0.9, radius: 4, fillColor: '#03f', fillOpacity: 0.5 };
                if(~feature.geometry.type.indexOf('Point')) {
                    style.fillOpacity = 0.9;
                }

                var props = feature.properties = feature.properties || {};
                if(feature.properties.id === undefined || feature.properties.id === null)
                    feature.properties.id = Math.floor(Math.random()*999999);
                feature.properties.label = props.label || props.title || props.name || "Untitled " + feature.geometry.type + " Feature";
                feature.properties.description = props.description || props.desc || "This feature needs a description!";
                feature.properties.style = props.style || style;

                layer.bindTooltip(props.label);
                /*
                toggle: setLabelNoHide(bool)
                it may only exist on markers!
                */
            },
            pointToLayer: function (feature : any, latlng : LatLng ) {
                var style = feature.properties.style || {};
                style.radius = style.radius || 4;
                style.weight = style.weight || 2;
                style.color = style.color || '#03f';
                style.opacity = style.opacity || 0.9;
                style.fillOpacity = style.opacity;
                style.fillColor = style.color;
                return circleMarker(latlng, style);
            }
        };
    }

    dispose () {
        this.destroyMap();
        this.svcCache = null;
        this.serviceFactory = null;
        this.httpClient = null;
        this._key = null;
        this._mapId = null;
        this._mapDef = null;
        this._mapInstance = null;
        this._defaultExtent = null;
        this._baseLayerDef = null;
        this._baseLayer = null;
        this._layerStates = null;
        this._layerCache = null;
        this._layerErrors= null;
        this._featureLayer = null;
        this._featureLayerVisible = true;
        this._tools = null;
        this.state = null;
        this._geoJsonLayerOpts = null;
    }


    getKey () {
        return this._key;
    }

    /**
     * Override default (JQuery-based) map service used by this instance
     * @param mapService - service to use to CRUD map objects
     * @deprecated use setServiceFactory instead
     */
    setService(mapService : MapService) {
        // this.mapService = mapService;
    }

    /**
     * @param factory - GeoPlatform ServiceFactory to instantiate services for maps and layers
     */
    setServiceFactory(factory : any) {
        this.svcCache = {}; //wipe out cached services
        this.serviceFactory = factory;
    }

    /**
     * @param httpClient - HttpClient impl to use with the new factory
     */
    setHttpClient(httpClient : any) {
        this.svcCache = {}; //wipe out cached services
        this.httpClient = httpClient;
    }

    /**
     * @param type - GeoPlatform Object model type to support ("Map", "Layer", etc)
     * @return item service implementation for the requested type
     */
    getService(type : string) : ItemService {
        if(!this.svcCache[type])
            this.svcCache[type] = this.serviceFactory(type, Config.ualUrl, this.httpClient);
        return this.svcCache[type];
    }

    /**
     * @param fn - callback when an error is encountered
     */
    setErrorHandler(fn) {
        this._layerErrorHandler = fn;
    }


    //-----------------
    getLayerStateIndex (layerId) {
        if(!layerId) return -1;
        for(let i=0; i<this._layerStates.length; ++i) {
            if(this._layerStates[i].layer && layerId === this._layerStates[i].layer.id) {
                return i;
            }
        }
        return -1;
        // return this._layerStates.indexOfObj(layerId, (id, state) => state.layer.id === id );
    }

    getLayerState (layerId) {
        let index = this.getLayerStateIndex(layerId);
        return index >= 0 ? this._layerStates[index] : null;
    }
    //-----------------


    initializeMapDefinition() {
        return {
            type: ItemTypes.MAP,
            title: "My New Map",
            label: "My New Map",
            description: "This map needs a description",
            createdBy: null,
            baseLayer: this._baseLayerDef,
            layers: [],
            keywords: [],
            themes: [],
            resourceTypes: ['http://www.geoplatform.gov/ont/openmap/GeoplatformMap']
        };
    }

    /**
     * @param metadata object
     * @return object definition of the current map suitable for sending to WMVR
     */
    getMapResourceContent(metadata ?: any) {

        metadata = metadata || {};

        //map layers
        metadata.layers = this._layerStates.map(state => {
            let result = {
                visibility : state.visibility || true,
                opacity : isNaN(state.opacity) ? 1.0 : state.opacity*1,
                layer: {
                    id: state.layer.id,
                    uri: state.layer.uri,
                    label: state.layer.label
                }
            };
            return result;
        });
        // ... UAL should support accepting just an id here, so we'll do just that
        metadata.baseLayer = {
            id: this._baseLayerDef.id,
            uri: this._baseLayerDef.uri,
            label: this._baseLayerDef.label
        };

        metadata.annotations = this._featureLayer ?
            { title: "Map Features", geoJSON: this._featureLayer.toGeoJSON() } : null;

        //geographic extent
        let extent = this._mapInstance.getBounds();
        metadata.extent = {
            minx: extent.getWest(),
            miny: extent.getSouth(),
            maxx: extent.getEast(),
            maxy: extent.getNorth()
        };

        return metadata;
    }

    /**
     * @return Leaflet toolbar
     */
    getDrawControlToolbar() {
        if(!(this._mapInstance as any).drawControl) return null;
        var toolbars = (this._mapInstance as any).drawControl._toolbars;
        var toolbar = null;
        for(var key in toolbars) {
            if(toolbars.hasOwnProperty(key)) {
                if(toolbars[key]._modes) {
                    toolbar = toolbars[key];
                    break;
                }
            }
        }
        return toolbar;
    }

    /**
     * @param error Leaflet tile load error (.target is layer, .tile is image)
     */
    handleLayerError(error) {
        // console.log("MapInstance.handleLayerError() - " +
        //     "Layer's tile failed to load: " + error.tile.src);
        if(!this._layerCache) {
            console.log("Unable to find layer in layer cache. Layer error is " + error);
            return;
        }
        var layer = error.target;
        for(var id in this._layerCache) {
            if(this._layerCache[id] === layer) {
                this.processLayerError(error, id);
                break;
            }
        }
    }

    /**
     * Given a Leaflet tile load error and the responsible layer id,
     * Try to isolate the cause of the error using the proxy
     * and notify listeners that an error has occurred
     */
    processLayerError(error : Error, id : string) {

        var finder = (l) => { return l.id === id || (l.layer && l.layer.id === id); };

        if(!this._layerErrors.find(finder)) {

            let obj = this.logLayerError(id, "Layer ('" + id + "') failed to completely load. " +
                "It may be inaccessible or misconfigured.");

            var url = (error as any).tile.src;
            var params = {id:id};
            url.substring(url.indexOf("?")+1, url.length).split('&').forEach(function(param) {
                var p = param.split('=');
                params[p[0]] = p[1];
            });

            let layerService = this.getService(ItemTypes.LAYER) as LayerService;
            if(layerService) {
                layerService.validate(id, params)
                .catch(e => {
                    var def = this._layerStates.find(finder);
                    if(def) {
                        obj.message = "Layer '" + def.layer.label + "' failed to completely load. " +
                                "Reported cause: " + e.message;
                    }
                    this.notify('layer:error', obj);
                });
            }
        }
    }

    /**
     * @param layerId - identifier of layer generating the error
     * @param errorMsg - message of the error
     */
    logLayerError(layerId, errorMsg) {
        // console.log("MapInstance.logLayerError() - layer "  + id +
        //     " generated error '" + errorMsg + "'");
        let err = { id: layerId, message: errorMsg };
        this._layerErrors.push(err);
        if(this._layerErrorHandler) {
            this._layerErrorHandler(err);
        }
        return err;
    }

    /* -- State Management of internal model -- */

    touch (event ?: any, ...options) {
        this.state.dirty = true;
        if(event) {
            if(arguments.length > 1) {
                this.notify.apply(this, Array.prototype.slice.call(arguments));
            } else
                this.notify(event);
            // console.log("Dirtying map for " + event);
        }
        // else console.log("Dirtying map");
    }
    clean() {
        // console.log("Cleaning map");
        this.state.dirty = false;
    }
    /* --------------------------------------- */




    /* ==============================================
        Map manipulation operations
       ============================================== */

    setMap (map : Map) { this._mapInstance = map; }

    /**
     * @return  map instance
     */
    getMap () : Map { return this._mapInstance; }

    /** @return definition of map */
    getMapDefinition () : any { return this._mapDef; }

    /** @return identifier of map */
    getMapId () : string { return this._mapId; }

    /**
     * Focuses the map on the specified lat/lng coordinate
     * @param lat number
     * @param lng number
     * @param zoom number (optional)
     */
    setView (lat : number, lng : number, zoom ?: number) {
        let z = zoom;
        if(typeof(z) === 'undefined')
            z = this._mapInstance.getZoom();
        this._mapInstance.setView([lat,lng], z);
        this.touch('map:view:changed');
    }

    /**
     * Retrieve the current center of the map
     * @return [lat,lng]
     */
    getView () : number[] {
        var latLng = this._mapInstance.getCenter();
        return [latLng.lat, latLng.lng];
    }

    /**
     * @return integer current zoom level of the map
     */
    getZoom () : number {
        return this._mapInstance.getZoom();
    }

    /**
     * Zoom to the map's default extent
     * If the map is saved, this will be the saved viewport
     * otherwise, it will be CONUS
     */
    zoomToDefault () {
        if(!this._mapInstance) return;
        if(this._defaultExtent) {
            this._mapInstance.fitBounds([
                [this._defaultExtent.miny, this._defaultExtent.minx],
                [this._defaultExtent.maxy, this._defaultExtent.maxx]
            ]);
        } else {
            console.log("MapInstance.zoomToDefault() - No default extent specified");
            this._mapInstance.setView([38, -96], 5);
        }
        try {
            this.touch('map:view:changed');
        } catch(e) { }
    }

    /**
     * @param extent - either a GP extent object or Leaflet LatLngBounds object
     */
    setExtent(extent : LatLngBounds|any) {
        if(!extent) return;
        if( typeof(extent.minx) !== 'undefined' &&
            typeof(extent.miny) !== 'undefined' &&
            typeof(extent.maxx) !== 'undefined' &&
            typeof(extent.maxy) !== 'undefined' ) {
            //GP model extent
            this._mapInstance.fitBounds([
                [extent.miny, extent.minx],
                [extent.maxy, extent.maxx]
            ]);
        } else if(typeof(extent.getWest) !== 'undefined') {
            //L.LatLngBounds
            this._mapInstance.fitBounds(extent);
        } else {

        }
    }


    /* ==============================================
        Layer operations
       ============================================== */


    /**
     * @param layer Leaflet Layer instance or object definition
     */
    setBaseLayer (layer : any) {

        let promise = null;
        if(!layer) {
            let svc = this.getService(ItemTypes.LAYER) as LayerService;
            promise = DefaultBaseLayer.get(svc);
        } else
            promise = Promise.resolve(layer);

        promise.then( layer => {

            let leafletLayer = LayerFactory.create(layer);
            if(!leafletLayer) {
                console.log("Warning: MapInstance could not create base " +
                    "layer for '" + layer.id + "'");
                return;
            }

            this._mapInstance.addLayer(leafletLayer);

            (leafletLayer as any).setZIndex(0);  //set at bottom

            let oldBaseLayer = this._baseLayer;
            if(oldBaseLayer) {
                this._mapInstance.removeLayer(oldBaseLayer);
            }

            //remember new base layer
            this._baseLayer = leafletLayer;
            this._baseLayerDef = layer;

            //will notify listeners
            this.touch('baselayer:changed', layer, leafletLayer);
            // this.notify('baselayer:changed', layer, leafletLayer);

        })
        .catch(e => {
            console.log(`MapInstance.setBaseLayer() - Error getting base layer for map : ${e.message}`);
            this.logLayerError( layer.id, "Error setting baselayer on map " +
                "because of the following error(s): " + e.message );
        });
    }

    /**
     * @return array of base layers definitions that can be used
     */
    // getBaseLayerOptions () {
    //     return this._baseLayerOptions;
    // },

    getBaseLayer () : any { return this._baseLayerDef; }

    /**
     * @return list of layer states containing layer information
     */
    getLayers () : any[] { return this._layerStates; }

    getLayerErrors () : any[] { return this._layerErrors; }

    clearLayerErrors () {
        this._layerErrors = [];
        this.notify('layer:error');
    }

    clearOverlays () {
        if(!this._layerCache) return;
        for(var i=this._layerStates.length-1; i>=0; --i) {
            var state = this._layerStates[i];
            var layerInstance = this._layerCache[state.layer.id];
            if(layerInstance) {
                layerInstance.off("layer:error");
                this._layerCache[state.layer.id] = null;
                this._mapInstance.removeLayer(layerInstance);
            }
        }
        this._layerStates = [];
        this.touch('layers:changed');

        //TODO stop listening for layer events
    }

    /**
     * @param layers - list of layers (NOTE: not wrapped by layer states, this method applies that)
     */
    addLayers (layers : any|any[] ) {
        if(!this._layerCache) {
            console.log("WARN: attempting to add layers to an empty cache");
            return;
        }

        if(!this._layerCache) {
            console.log("WARN: Attempting to add layers to a map with no layer cache");
            return;
        }

        if(!layers) return;
        if(typeof(layers.push) === 'undefined') {
            layers = [layers];
        }

        layers.forEach( (obj,index) => {

            let layer = null, state = null;

            if(obj.type && obj.type===ItemTypes.LAYER) { //is a layer
                layer = obj;
            } else if(obj.layer) {  //is layer state
                layer = obj.layer;  // containing a layer
                state = obj;
            }

            if(!layer) {
                console.log("MapInstance.addLayers() - layer (" + index +
                    ") is not a Layer or a Layer state. Ignoring...");
                return;  //layer info is missing, skip it
            }

            //DT-442 prevent adding layer that already exists on map
            if(this._layerCache[layer.id]) return;

            if(!state) {
                try {
                    //wrapped in try{}catch because layer may contain circular reference
                    // which will cause error when used by JSON methods
                    let layerCopy = JSON.parse(JSON.stringify(layer));
                    state = {
                        opacity: 1,
                        visibility: true,
                        layer: layerCopy
                    };
                } catch(e) {
                    throw new Error("Unable to add layer to map because of " + e.message);
                }
            }

            let z = layers.length - index;
            state.zIndex = z;

            this.addLayerWithState(layer, state);

        });

        this.touch('layers:changed');
    }

    /**
     * @param layer - GeoPlatform Layer instance
     * @param state - GeoPlatform Layer State
     */
    addLayerWithState(layer, state) {

        var leafletLayer = null;
        try {
            if(!layer || !state)
                throw new Error("Invalid argument, missing layer and or state");

            leafletLayer = LayerFactory.create(layer);
            if(!leafletLayer) {
                let msg = "Could not create leaflet instance for GP Layer '" + layer.id + "'.";
                if(!layer.services || !layer.services.length) {
                    msg += '  The layer instance has no services included, ' +
                        'which will prevent most layers from being displayed.';
                }
                throw new Error(msg);
            }

        } catch(e) {
            this.logLayerError( layer.id,
                "Layer '" + layer.label + "' could not be added to the " +
                "map instance; " + e.message);
        }

        if(!leafletLayer) return;

        //cache leaflet object first
        if(this._layerCache) this._layerCache[layer.id] = leafletLayer;

        //listen for layer errors so we can inform the user
        // that a layer hasn't been loaded in a useful way
        leafletLayer.on('tileerror', (e) => { this.handleLayerError(e); });

        this._mapInstance.addLayer(leafletLayer);

        if( !isNaN(state.zIndex) && leafletLayer.setZIndex )
            leafletLayer.setZIndex(state.zIndex);

        this._layerStates.push(state);

        this.notify('layer:added', layer, leafletLayer);


        // if layer is initially "off" or...
        // if layer is initially not 100% opaque
        if(!state.visibility || state.opacity < 1) {
            // initialize layer visibility and opacity async, or else
            // some of the layers won't get properly initialized
            setTimeout( (layer, state) => {
                this.setLayerVisibility(layer, state.visibility);
                this.setLayerOpacity(layer, state.opacity);
                //TODO notify of change

                //DT-2102 timeout needs to be large enough or else
                // feature layers won't get opacity updated on map load
            }, 2000, leafletLayer, state);
        }
    }

    /**
     * @param from - position of layer being moved
     * @param to - desired position to move layer to
     */
    moveLayer (from : number, to : number) {
        if(!this._layerCache) return;

        if(!this._layerCache) return;

        if(isNaN(from)) return;

        //end of list
        if(isNaN(to)) to = this._layerStates.length-1;

        let copy = this._layerStates.splice(from, 1)[0];    //grab layer being moved
        this._layerStates.splice(to, 0, copy);

        for(let z=1, i=this._layerStates.length-1; i>=0; --i,++z) {
            let layerState = this._layerStates[i];
            let layerInstance = this._layerCache[ layerState.layer.id ];
            if(layerInstance) {
                layerInstance.setZIndex(z);
                layerState.zIndex = z;
            }
        }

        this.touch('layers:changed', this.getLayers());
    }

    /**
     *
     */
    removeLayer (id) {

        if(!this._layerCache) return;
        var layerInstance = this._layerCache[id];
        if(layerInstance) {

            //remove layer from tracked defs array
            let index = this.getLayerStateIndex(id);
            // console.log("MapInstance.removeLayer(" + id + ")");
            if(index >= 0 && index < this._layerStates.length)
                this._layerStates.splice(index, 1);

            //stop listening for errors
            layerInstance.off("layer:error");

            //remove layer from map
            this._mapInstance.removeLayer(layerInstance);

            //remove layer from cache
            this._layerCache[id] = null;
        }
        this.touch('layers:changed');
    }

    /**
     *
     */
    toggleLayerVisibility (id) {
        if(!this._layerCache) return;
        var layerInstance = this._layerCache[id];
        if(layerInstance) {
            let state = this.getLayerState(id);
            state.visibility = !state.visibility;

            if(layerInstance._currentImage) {
                //ESRI Image Service layers have an IMG element
                // that gets modified and replaced every map event (zoom/pan)
                // so we can't just toggle classes like on other layers.
                //Instead, we need to use the ESRI setOpacity method to toggle
                // but need to update layer state as well.
                layerInstance.setOpacity(state.visibility ? 1 : 0);
                state.opacity = layerInstance.getOpacity();
                return;
            }

            this.setLayerVisibility(layerInstance, state.visibility);
        }
    }

    /**
     * Note: this does not update layer definition state. Use
     * MapInstance.toggleLayerVisibility to do that and adjust
     * rendered layer's visibility.
     *
     * @param layerInstance - leaflet layer instance
     * @param visible - flag indicating visibility of layer
     */
    setLayerVisibility (layerInstance : Layer, visible : boolean) {

        if((layerInstance as any).setVisibility) {
            //using custom method provided in src/layer/module.js
            (layerInstance as any).setVisibility(visible);

        } else if((layerInstance as any)._container) {
            //otherwise, using jquery on dom directly
            let el = jQuery((layerInstance as any)._container);
            // if(visible) el.removeClass("invisible");
            // else el.addClass('invisible');
            el.css({'display': visible ? '' : 'none'});
        }

        this.touch('map:layer:changed');
    }

    /**
     *
     */
    updateLayerOpacity (id : string, opacity : number) {

        if(!this._layerCache) return;
        var layerInstance = this._layerCache[id];

        //if layer id is for base layer...
        if(!layerInstance && this._baseLayerDef.id === id) {
            layerInstance = this._baseLayer;
        }

        //adjust rendered leaflet layer
        opacity = this.setLayerOpacity(layerInstance, opacity);

        // if overlay layer, update state value
        let state = this.getLayerState(id);
        if(state) state.opacity = opacity;

    }

    /**
     * Note: this method does not update the associated Layer Definition
     * state value for opacity. Use MapInstance.updateLayerOpacity() to
     * both update state and adjust rendered layer.
     *
     * @param layerInstance - leaflet layer instance
     * @param opacity - value between 0 and 1.0 or 0 and 100
     * @return normalized opacity value between 0 and 1.0
     */
    setLayerOpacity (layerInstance : Layer, opacity : number) : number {
        if(layerInstance && (layerInstance as any).setOpacity) {
            if(opacity > 1.0) opacity = opacity / 100.0;
            (layerInstance as any).setOpacity(opacity);
            this.touch('map:layer:changed');
        }
        return opacity;
    }

    /**
     * @param GeoPlatform Layer instance
     * @return Leaflet layer instance representing that layer or null
     */
    getLeafletLayerFor (gpLayer : any) : Layer {
        if(!gpLayer || !this._layerCache) return null;
        let leafletLayer = this._layerCache[gpLayer.id];
        return leafletLayer || null;
    }

    /**
     *
     */
    toggleGetFeatureInfo (layerId : string) {
        if(!this._layerCache) return;
        var layerInstance = this._layerCache[layerId];
        if(layerInstance) {
            if(typeof(layerInstance.enableGetFeatureInfo) !== 'undefined') {
                if(layerInstance.isGetFeatureInfoEnabled()) {
                    layerInstance.disableGetFeatureInfo();
                    jQuery((this._mapInstance as any)._container).removeClass('selectable-cursor');
                } else {
                    layerInstance.enableGetFeatureInfo();
                    jQuery((this._mapInstance as any)._container).addClass('selectable-cursor');
                }
            }

        }
    }


    /* ==============================================
       Feature operations
       ============================================== */


    /**
     * @return array of features on the map
     */
    getFeatures () : any[] {
        if(this._featureLayer) {
            let geojson = this._featureLayer.toGeoJSON();
            return (geojson as any).features;
        }
        return [];
    }

    /**
     * @param json geojson object or array of geojson objects
     */
    addFeatures (json : any) {

        if(!json) return;

        if(typeof(json.push) !== 'undefined') {
            //array of features
            for(var i=0; i<json.length; ++i)
                this.addFeature(json[i], false);
            this.touch('features:changed');

        } else if(json.features) {
            this.addFeatures(json.features);

        } else { //single feature
            this.addFeature(json, true);
        }

    }

    /**
     * @param json geojson object
     */
    addFeature (json : any, fireEvent ?: boolean) {
        // var type = json.type;
        // var coordinates = json.coordinates;

        if(!this._featureLayer) {

            // _featureLayer = geoJSON([], _geoJsonLayerOpts).addTo(_mapInstance);
            this._featureLayer = featureGroup().addTo(this._mapInstance);

        }

        // _featureLayer.addData(json);
        var opts = jQuery.extend({}, this._geoJsonLayerOpts);
        geoJSON(json, opts).eachLayer((l)=>this.addFeatureLayer(l));

        if(typeof(fireEvent) === 'undefined' || fireEvent === true)
            this.touch('features:changed');
        else this.touch();

        // console.log(JSON.stringify(_featureLayer.toGeoJSON()));

    }

    /**
     * @param featureJson object defining a GeoJSON feature
     */
    updateFeature (featureJson : any) {
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if(layer) {

            (layer as any).feature = featureJson;

            //update style
            layer.setStyle(featureJson.properties.style);

            //rebind label in case that changed
            var label = featureJson.properties.label ||
                "Untitled " + featureJson.geometry.type + " Feature";
            layer.bindTooltip(label);

            // layer.redraw();
            this.touch("map:feature:changed");
        }
    }

    /**
     * Replace an existing L.Path-based layer with one using
     * the supplied Feature GeoJSON object.  Removes the existing
     * layer and adds a new one created from the GeoJSON.
     *
     * @param featureJson object defining GeoJSON feature
     */
    replaceFeature (featureJson : any) {

        //find existing layer for this feature
        var layer = this.getFeatureLayer(featureJson.properties.id);
        if(layer) {

            //remove existing
            this._featureLayer.removeLayer(layer);

            //add replacement
            geoJSON(featureJson, this._geoJsonLayerOpts)
                .eachLayer((l)=>this.addFeatureLayer(l));

            this.touch("map:feature:changed");
        }
    }

    /**
     * @param featureId identifier of feature to focus the map on
     */
    focusFeature (featureId : string) {
        var layer = this.getFeatureLayer(featureId);
        if(layer) {
            if( typeof(layer.getBounds) !== 'undefined') {
                let extent = layer.getBounds();
                this._mapInstance.fitBounds(extent);
            } else if(typeof( (layer as any).getLatLng) !== 'undefined') {
                let latLng = (layer as any).getLatLng();
                this._mapInstance.panTo(latLng);
            } else {
                console.log("MapInstance.focusFeature() - Cannot focus feature because it has no bounds or lat/lng");
            }
        } else {
            console.log("MapInstance.focusFeature() - Cannot focus feature because it has no layer");
        }
    }

    /**
     * @param featureId : string
     */
    removeFeature (featureId) {
        var layer = this.getFeatureLayer(featureId);
        if(layer && this._featureLayer) {
            this._featureLayer.removeLayer(layer);
            this.touch('features:changed');
        }
    }

    /**
     *
     */
    removeFeatures () {
        if(this._featureLayer) {
            this._featureLayer.clearLayers();
            this.touch("features:changed");
        }
    }

    /**
     *
     */
    getFeatureLayer ( featureId ?: string ) : FeatureGroup {
        //if no feature was specified, return root feature layer
        if(!featureId) return this._featureLayer;

        //otherwise, find feature...
        if(!this._featureLayer) return null;

        var features = this._featureLayer.getLayers();
        for(var i=0; i<features.length; ++i) {
            if( (features[i] as any).feature &&
                (features[i] as any).feature.properties.id === featureId) {
                return (features[i] as any);
            }
        }
        return null;
    }

    toggleFeaturesLayer () {
        if(!this._featureLayer) return false;    //ignore if not rendered yet

        this._featureLayerVisible = !this._featureLayerVisible;
        this.setFeatureLayerVisibility(this._featureLayer, this._featureLayerVisible);
        return this._featureLayerVisible;
    }

    /**
     * @param  feature - Leaflet feature instance
     * @param  visibility - flag
     */
    setFeatureVisibility (feature, visibility : boolean) {
        this.setFeatureLayerVisibility(feature, visibility);
    }

    getFeaturesLayerVisibility () {
        return this._featureLayerVisible;
    }


    /*
     * method for adding feature layers to the map
     * when these layers may be layer groups.
     * finds leaf node layers and adds them to the
     * map's feature group
     */
    addFeatureLayer(layer) {
        this._addFeatureLayer(layer);
        this.touch("features:changed");
    }

    /**
     * Internal method, use 'addFeatureLayer' instead
     * @param layer
     */
    _addFeatureLayer(layer : Layer) {
        if(!(layer as any).feature && layer instanceof LayerGroup) {
            layer.eachLayer( (child) => {
                this._addFeatureLayer(child);
            });
        } else {
            this._featureLayer.addLayer(layer);
        }
    }


    //toggle visibility of parent feature layer
    setFeatureLayerVisibility(layer, visibility) {
        if(!layer) return;
        this._featureLayerVisible = visibility;

        if(layer.getLayers) {
            layer.getLayers().forEach( (child) => {
                this.setFeatureLayerVisibility(child, visibility);
            });

        } else {
            let container = layer._container || layer._path;
            if(container)
                container.style.display = visibility ? '' : 'none';
        }
    }



    /* ==============================================
       Map lifecycle operations
       ============================================== */

    /**
     * @param metadata
     * @return resolving persisted map
     */
    save (metadata : any) : Promise<any> {
        return this.saveMap(metadata);
    }

    /**
     * @param md object containing metadata properties for map
     */
    saveMap (md : any) : Promise<any> {

        let metadata = md || {};

        //add GeoPlatformMap resource type if not already present
        const gpMapType = 'http://www.geoplatform.gov/ont/openmap/GeoplatformMap';
        metadata.resourceTypes = metadata.resourceTypes || [];
        if(metadata.resourceTypes.indexOf(gpMapType) < 0)
            metadata.resourceTypes.push(gpMapType);

        var content = this.getMapResourceContent(metadata);

        //ensure the two name properties line up
        if(content.title && content.title !== content.label) {
            content.label = content.title;
        } else if(content.label && !content.title) {
            content.title = content.label;
        }

        // console.log("Updating: " + JSON.stringify(map));
        return new Promise<any>( (resolve, reject) => {
            this.getService(ItemTypes.MAP).save(content)
            .then( result => {

                //track new map's info so we can update it with next save
                if(!this._mapId)
                    this._mapId = result.id;

                this._mapDef = result;
                this._defaultExtent = result.extent;
                this.clean();
                resolve(result);
            })
            .catch(err=>{
                console.log("MapCore MapInstance.saveMap() - " +
                    "The requested map could not be saved because: " + err.message);
                let e = new Error("The requested map could not be saved because of the following error(s): " +
                    err.message);
                reject(e);
            });
        });

    }

    /**
     * Retrieve a map's descriptor from the registry
     * @param mapId identifier of map
     * @return resolving the map object
     */
    fetchMap (mapId : string) : any {
        //Having to send cache busting parameter to avoid CORS header cache
        // not sending correct Origin value
        return this.getService(ItemTypes.MAP).get(mapId);
    }

    /**
     * Retrieve a map's descriptor and load it as the
     * current map managed by this service
     * @param mapId identifier of map
     * @return resolving the map object
     */
    loadMap (mapId : string) : any {

        return new Promise<any>( (resolve, reject) => {

            this.fetchMap(mapId).then(map => {

                if(!map) {
                    throw new Error("The requested map ('" + mapId +
                        "') came back null");

                } else if(typeof(map) === 'string') {
                    throw new Error("The requested map ('" + mapId +
                        "') came back as a string");

                } else if((map as any).message) {
                    throw new Error("There was an error loading the requested map ('" +
                        mapId + "'): " + (map as any).message);
                }


                //loading a map by its ID, so we need to increment it's view count
                if('development' !== Config.env) {

                    setTimeout( (map) => {
                        //update view count
                        let views = map.statistics ? (map.statistics.numViews||0) : 0;
                        let patch = [ { op: 'replace', path: '/statistics/numViews', value: views+1 } ];
                        this.getService(ItemTypes.MAP).patch(map.id, patch)
                        // this.mapService.patch(map.id, patch)
                        .then( updated => { map.statistics = updated.statistics; })
                        .catch( e => {
                            console.log("MapInstance.loadMap() - Error updating view " +
                                "count for map ('" + mapId + "'): " + e);
                        });
                    }, 1000, map);

                }

                //load the map into the viewer
                this.loadMapFromObj(map);

                resolve(map);
            })
            .catch( err => {
                console.log("MapInstance.loadMap() - " +
                    "The requested map could not be loaded because " + err.message);
                let e = new Error("The requested map ('" + mapId +
                    "') could not be loaded because of the following error(s): " +
                    err.message);
                reject(e);
            });
        });
    }

    /**
     * Load a map from its descriptor as the current
     * map managed by this service
     * @param map object
     */
    loadMapFromObj (map : any) {

        // console.log("Loading Map Object");
        // console.log(map);

        this._mapId = map.id;
        this._mapDef = map;

        map.extent = this.ensureExtent(map.extent);

        //set extent from loaded map
        this._defaultExtent = map.extent;
        var extent = map.extent;

        //remove existing layers
        this._mapInstance.eachLayer((l) => {
            this._mapInstance.removeLayer(l);
        });
        this._layerCache = {};
        this._layerStates = [];

        //set new base layer
        this.setBaseLayer(map.baseLayer);

        //add layers from loaded map
        this.addLayers(map.layers);

        //add features
        if(map.annotations && map.annotations.geoJSON) {
            let fc = map.annotations.geoJSON;
            if(fc.features)
                this.addFeatures(fc.features);
            else
                this.addFeatures([fc]);
        }

        this._mapInstance.fitBounds([
            [extent.miny, extent.minx],
            [extent.maxy, extent.maxx]
        ]);

        this.clean();
        this.notify('map:loaded', map);

    }


    /**
     * @param extent
     * @return corrected or default extent
     */
    ensureExtent( extent : any ) : any {

        let west  = !extent || isNaN(extent.minx) ? -179.0 : extent.minx*1.0;
        let east  = !extent || isNaN(extent.maxx) ?  179.0 : extent.maxx*1.0;
        let south = !extent || isNaN(extent.miny) ?  -89.0 : extent.miny*1.0;
        let north = !extent || isNaN(extent.maxy) ?   89.0 : extent.maxy*1.0;

        //ensure x,y is ordered correctly
        let t;
        if(west > east) {
            t = Math.min(west, east);
            east = Math.max(west, east);
            west = t;
        }
        if(south > north) {
            t = Math.min(south, north);
            north = Math.max(south, north);
            south = t;
        }

        //prevent out-of-bounds extents
        if(west < -180.0) west = -179.0;
        if(east > 180.0)  east =  179.0;
        if(south < -90.0) south = -89.0;
        if(north > 90.0)  north =  89.0;

        return { minx : west, miny : south, maxx : east, maxy : north };
    }


    /**
     *
     */
    destroyMap () {
        // console.log("Destroying Map");
        this._mapInstance = null;
        this._layerCache = null;
        this._layerStates = null;
        this._featureLayer = null;
    }


    /**
     * Used to take an existing map that is already persisted on the
     * server and unlink it here in the client so that it will be saved
     * as a completely new map when mapService.saveMap(...) is next called
     */
    setAsNewMap (mapToUse) {
        this._mapId = null;
        this._mapDef = mapToUse || this.initializeMapDefinition();
    }


    /* ==============================================
        Tool operations
       ============================================== */

    registerTool (id, tool) {
        this._tools[id] = tool;
    }

    unregisterTool (id) {
        this._tools[id] = null;
    }

    enableTool (id, finish) {
        if(!this._tools[id]) return false;
        this._tools[id].activate(function() {
            this.notify('tool:disabled', id);
        });
        this.notify('tool:enabled', id);
    }


    /* ----------- MISC ------------ */

    //https://github.com/gsklee/ngStorage
    cacheMap () {

        if(this.state && this.state.dirty) {
            var map = this.getMapResourceContent();
            //use exploded layer info
            map.layers = this._layerStates.slice(0);
            // $sessionStorage.map = map;
        }
    }

    restoreMap () {
        // if($sessionStorage.map) {
        //     console.log("Restoring cached map");
        //     let map = $sessionStorage.map;
        //     // console.log(JSON.stringify(map));
        //     $sessionStorage.map = null;
        //     this.loadMapFromObj(map);
        // }
    }
    /* ---------------------------- */
}
